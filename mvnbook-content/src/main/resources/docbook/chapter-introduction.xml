<?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="introduction" lang="fr">
  <title>Introduction à Apache Maven</title>
  <para>Bien qu'il existe de nombreuses références à Maven sur internet, on ne
  trouve pas un seul document correctement écrit sur Maven et qui puisse
  servir à la fois de véritable référence et d'introduction. Ce que nous avons essayé de faire ici est d'écrire un tel document avec son matériel de référence.
  </para>
  <section id="introduction-sect-whatIsMaven">
    <title>Maven... De quoi s'agit il ?</title>
    <para>La réponse à cette question dépend de votre point de vue.
 La plus grande partie des utilisateurs de Maven vont l'appeler un “outil de build” : c'est-à-dire un outil qui permet de produire des artefacts déployables à partir du code source. Pour les gestionnaires de projet et les ingénieurs en charge du build, Maven ressemble plus à un outil de gestion de projet. Quelle est la différence ? Un outil de build comme Ant se concentre essentiellement sur les tâches de prétraitement, de compilation, de packaging, de test et de distribution. Un outil de gestion de projet comme Maven fournit un ensemble de fonctionnalités qui englobe celles d'un outil de build.  Maven apporte, en plus de ses fonctionnalités de build, sa capacité à produire des rapports, générer un site web et ainsi facilite la communication entre les différents membres de l'équipe.
    </para>
    <para>La définition plus formelle d' 
      <ulink url="http://maven.apache.org">Apache Maven
      </ulink> : Maven est un outil de gestion de projet qui comprend un modèle objet de projet, un ensemble de standards, un cycle de vie, un système de gestion des dépendances et la logique pour exécuter certaines fonctions de plugins à des étapes précises de ce cycle de vie. Lorsque vous utilisez Maven, vous décrivez votre projet selon un modèle objet de projet clair, Maven peut alors lui appliquer la logique transverse d'un ensemble de plugins (partagés ou spécifiques).
    </para>
    <para>Ne vous laissez pas impressionner par le fait que Maven est un "outil de gestion de projet". Si vous cherchiez juste un outil de build alors Maven restera l'homme de la situation. D'ailleurs, les premiers chapitres de ce livre vont traiter le cas d'utilisation le plus courant : l'utilisation de Maven pour construire et distribuer votre projet. </para>
  </section>
  <section id="installation-sect-conventionConfiguration">
    <title>Convention plutôt que Configuration</title>
    <para>Le concept de convention plutôt que configuration est très simple. Les systèmes, les bibliothèques et les frameworks devraient avoir un comportement par défaut raisonnable.  Un système devrait "juste fonctionner" sans avoir à exiger une configuration superflue. Des frameworks populaires comme
      <ulink url="http://www.rubyonrails.org/">Ruby on Rails</ulink> et
      <acronym>EJB3</acronym> ont commencé à appliquer ces principes en réaction à la complexité de la configuration de frameworks tels que les spécifications initiales
      <acronym>EJB</acronym> 2.1. Une illustration de ce principe de convention plutôt que configuration est la persistance
      <acronym>EJB3</acronym> : pour rendre une classe persistante tout ce que vous avez à faire est de l'annoter avec
      <classname>@Entity.</classname>  Le framework va considérer que les noms de la table et des colonnes seront ceux de la classe et de ses attributs. Vous pouvez modifier les noms par défaut si vous en ressentez le besoin, mais dans la plupart des cas, utiliser le comportement par défaut du framework permet une exécution plus rapide du projet.
    </para>
    <para>Maven intègre ce concept en ayant un comportement logique par défaut. Sans configuration spécifique, le code source est supposé se trouver dans
      <filename>\${basedir}/src/main/java</filename> et  les différentes ressources dans
      <filename>\${basedir}/src/main/resources</filename>. Les tests eux sont supposés être dans
      <filename>\${basedir}/src/test</filename>, et un projet est supposé produire un fichier
      <acronym>JAR</acronym>. Maven suppose que vous voulez compiler en bytecode dans
      <filename>\${basedir}/target/classes</filename> et ensuite créer votre fichier
      <acronym>JAR</acronym> distribuable dans
      <filename>\${basedir}/target</filename>. Même si tout cela peut sembler trivial, n'oubliez pas que pour la plupart des scripts Ant vous devez définir les emplacements de ces différents répertoires. Ant n'a pas la moindre idée d'où se trouve le code source et les différentes ressources; vous devez le lui indiquer. L'adoption par Maven de ce principe de convention plutôt que configuration va plus loin que les répertoires, les plugins au c&oelig;ur de Maven appliquent un ensemble de conventions pour compiler le code source, packager les éléments à distribuer, produire des sites web, et bien d'autres traitements. La force de Maven vient de ses "convictions", il a un cycle de vie bien défini et un ensemble de plugins de base pour construire et assembler un logiciel.  Si vous suivez les conventions, Maven ne va vous demander quasiment aucun effort - vous n'avez qu'à mettre votre code source dans le bon répertoire et Maven s'occupe du reste.
    </para>
    <para>Une des conséquences des systèmes respectant le principe de "convention plutôt que configuration" est que leurs utilisateurs peuvent se sentir contraints de suivre une certaine méthodologie. S'il est vrai que Maven a fait certains choix qui ne doivent pas être remis en cause, la plupart des valeurs par défaut peuvent être adaptées.
       Par exemple, il est tout à fait possible de modifier l'emplacement du code source et des ressources pour un projet, de redéfinir les noms des fichiers
      <acronym>JAR</acronym>, et il est possible d'adapter presque tous les comportements aux spécificités de votre projet par le développement de plugins spécifiques. Si vous ne souhaitez pas suivre les conventions, Maven vous permettra de changer les valeurs par défaut selon vos propres besoins.
    </para>
  </section>
  <section id="installation-sect-common-interface">
    <title>Une Interface Commune</title>
    <para>Avant que Maven ne fournisse une interface commune pour construire un logiciel, chaque projet avait une personne dédiée pour gérer son système de build complètement personnalisé. Les développeurs devaient prendre du temps sur leurs développements pour apprendre les arcanes de chaque nouveau projet auquel ils voulaient contribuer. En 2001, vous aviez une approche très différente pour construire un projet comme
      <ulink
    url="http://turbine.apache.org/">Turbine
      </ulink> par rapport à un projet comme
      <ulink
    url="http://tomcat.apache.org">Tomcat
      </ulink>. Si un nouvel outil d'analyse statique du code source de code sortait, ou si un nouveau framework de tests unitaires était développé, tout le monde devait s'arrêter de développer et voir comment l'intégrer dans l'environnement de build spécifique à chaque projet. Comment exécuter les tests unitaires ? Il existait des milliers de réponses à cette question. Cette époque se caractérisait par des discussions sans fin sur les outils et les procédures pour construire un logiciel. Le monde d'avant Maven était un monde inefficace, l'âge de "l'Ingénieur du Build".
    </para>
    <para>Aujourd'hui, la plupart des développeurs du libre ont utilisé ou utilisent Maven pour gérer leurs nouveaux projets logiciels. Cette transition n'est pas le simple passage d'un outil de build à un autre, mais l'adoption d'une interface commune de construction de projet. Pendant que les logiciels devenaient modulaires, les systèmes de build devenaient de plus en plus complexes et le nombre de projets a crevé le plafond. Avant Maven, lorsque vous vouliez récupérer le code source de projets comme
      <ulink url="http://activemq.apache.org">Apache ActiveMQ</ulink> ou
      <ulink url="http://servicemix.apache.org">Apache ServiceMix</ulink> depuis Subversion et le construire à partir de ses sources, vous deviez passer plus d'une heure à essayer de comprendre comment fonctionnait le système de build de chacun de ces projets. De quoi a t'on besoin pour construire ce projet ? Quelles bibliothèques dois-je télécharger ? Ensuite, où dois-je les mettre ? Quelles tâches dois je exécuter dans le build ? Dans le meilleur des cas, il fallait quelques minutes pour comprendre comment construire un logiciel, dans le pire (par exemple l'antique implémentation de l'API Servlet du projet Jakarta), construire le logiciel était si complexe qu'il fallait plusieurs heures à un nouveau contributeur pour pouvoir modifier le code source et compiler le projet. De nos jours, il suffit de récupérer le source et d'exécuter la commande
      <command>mvn
    install
      </command>.
    </para>
    <para>Même si Maven fournit tout un ensemble d'avantages, dont la gestion des dépendances et la réutilisation de comportements communs de build par ses plugins, la raison principale de son succès vient de la création d'une interface unifiée pour construire un logiciel. En voyant qu'un projet comme
      <ulink
    url="http://wicket.apache.org">Apache Wicket
      </ulink> utilise Maven, on imagine aisément qu'il suffit de récupérer le code source et que la commande mvn install va construire ce projet sans trop de problèmes. Vous savez où insérer la clef de contact, que la pédale d'accélérateur se trouve à droite et le frein à gauche.
    </para>
  </section>
  <section id="installation-sect-universal-reuse">
    <title>Réutilisation Universelle grâce aux Plugins Maven</title>
    <para>Le c&oelig;ur de Maven est assez stupide, il ne sait pas faire grand-chose à part parser quelques documents
      <acronym>XML</acronym> et garder les traces d'un cycle de vie et de quelques plugins. Maven a été conçu pour déléguer la responsabilité du build à un ensemble de Plugins Maven qui vont affecter le Cycle de Vie de Maven et fournir différentes actions : les goals. Avec Maven, tout se passe dans les goals des plugins, c'est là que le code source est compilé, le bytecode est packagé, les sites sont publiés et que toute autre tâche nécessaire à vote build se produit. Le Maven que vous téléchargez chez Apache n'y connaît rien en packaging de fichier
      <acronym>WAR</acronym> ou en exécution de tests JUnit; la plus grande partie de l'intelligence de Maven se trouve dans les plugins, plugins qui sont récupérés du dépôt Maven. En effet, la première fois que vous exécutez une commande comme
      <command>mvn install</command> avec une installation de Maven vierge, elle récupère les plugins Maven de base du dépôt Central Maven Repository. C'est plus qu'une astuce pour réduire la taille de la distribution Maven à télécharger, c'est par ce moyen que vous pouvez mettre à jour un plugin pour apporter de nouvelles possibilités au build de votre projet. C'est parce que Maven récupère les dépendances et les plugins depuis des dépôts distants que vous pouvez réutiliser une logique de build universelle.
    </para>
    <para>Le plugin Maven Surefire est le plugin qui a en charge l'exécution des tests unitaires. À un moment donné, entre la version 1.0 et la version utilisée actuellement quelqu'un a décidé d'apporter le support du framework de tests unitaires TestNG en plus de celui de JUnit. Cette mise à jour s'est faite sans casser la compatibilité ascendante.  Si vous utilisez le plugin Surefire pour compiler et exécuter vos tests unitaires JUnit 3, et que vous le mettez à jour, vos tests continuent à s'exécuter sans erreur. Mais vous avez obtenu une nouvelle fonctionnalité, vous pouvez d'exécuter des tests avec TestNG. Et en plus, vous pouvez d'exécuter des tests unitaires JUnit 4 annotés. Tout cela sans avoir à mettre à jour votre installation de Maven ou à installer quoi que ce soit. Et plus  important encore, vous n'avez rien changé à votre projet si ce n'est le numéro de version d'un plugin dans un unique fichier de configuration de Maven, le Project Object Model (POM).</para>
    <para>C'est ce même mécanisme que l'on retrouve dans tout Maven.
    Maven dispose de plugins pour tout faire, de la compilation du code Java, à la génération de rapports 
    et au déploiement sur un serveur d'applications.    
    Maven a extrait les tâches de la construction d'un projet dans des plugins 
    qui sont centralisés pour leur maintenance et partagés universellement. 
    Si l'état de l'art change pour une étape quelconque du build, si un nouveau framework de tests unitaires sort, 
    si de nouveaux outils deviennent disponibles, vous n'avez plus à ajouter une nouvelle verrue 
    à votre système personnalisé de build pour en profiter.  
    Vous allez bénéficier du fait que les plugins sont téléchargés depuis un dépôt distant 
    et maintenus centralement. C'est tout cela qu'implique la notion de réutilisation universelle 
    par les plugins Maven.
    </para>
  </section>
  <section id="installation-sect-conceptual">
    <title>Le Modèle Conceptuel d'un "Projet"</title>
    <para>Avec Maven vous modélisez un projet. Vous ne faites plus simplement de la compilation de code en bytecode, vous décrivez un projet logiciel et vous lui assignez un ensemble unique de coordonnées. Vous définissez les attributs qui lui sont propres. Quelle est sa licence ? Quels sont ses développeurs et ses contributeurs ? De quels autres projets dépend t-il ? Maven est plus qu'un simple "outil de build", c'est plus qu'une amélioration des outils tels que Ant et make, c'est une plateforme qui s'appuie sur de nouvelles sémantiques pour les projets logiciels et le développement. La définition d'un modèle pour tous les projets fait émerger de nouvelles caractéristiques telles que :</para>
    <variablelist>
      <varlistentry>
        <term>La Gestion des Dépendances</term>
        <listitem>
          <para>Puisque chaque projet est identifié de manière unique par un identifiant de groupe, un identifiant d'artefact et un numéro de version, les projets peuvent utiliser ces coordonnées pour déclarer leurs dépendances. </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Des Dépôts Distants</term>
        <listitem>
          <para>En liaison avec la gestion de dépendance, nous pouvons utiliser les coordonnées définies dans le Project Object Model (
            <acronym>POM</acronym>) de Maven pour construire des dépôts d'artefacts Maven.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Réutilisation Universelle de la Logique de Build</term>
        <listitem>
          <para>Les plugins contiennent toute la logique de traitement. Ils s'appuient sur les données et 
          paramètres de configuration définit dans le Project Object Model (<acronym>POM</acronym>) 
          Ils ne sont pas conçus pour fonctionner avec des fichiers spécifiques à des endroits connus.</para>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Portabilité / Intégration dans des outils</term>
        <listitem>
          <para>Les outils tels qu'Eclipse, NetBeans, et IntelliJ ont maintenant un endroit unique pour aller récupérer les informations sur un projet. Avant Maven, chaque
            <acronym>EDI</acronym> conservait à sa manière ce qui était, plus ou moins, son propre Project Object Model (
            <acronym>POM</acronym>). Maven a standardisé cette description, et alors que chaque EDI continue à maintenir ses propres fichiers décrivant le projet, ils peuvent être facilement générés à partir du modèle.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Facilités pour la Recherche et le  Filtrage des Artefacts Projet</term>
        <listitem>
          <para>Des outils tels que Nexus vous permettent d'indexer et de rechercher les contenus d'un dépôt à partir des informations contenues dans le
            <acronym>POM</acronym>.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section id="installation-sect-mavenAlternativeAnt">
    <title>Maven est il une alternative à XYZ ?</title>
    <para>Bien sûr, Maven est une alternative à Ant, mais
      <ulink
    url="http://ant.apache.org">Apache Ant
      </ulink> continue à être un outil excellent, et largement utilisé. Il fut le champion des builds Java pendant des années, et vous pouvez intégrer vos scripts Ant au build Maven de votre projet très facilement. C'est une utilisation très commune dans un projet Maven. D'un autre coté, tandis que de plus en plus de projets open source migrent vers la plateforme de gestion de projet Maven, les développeurs se rendent compte que Maven ne fait pas que simplifier la gestion du build, il permet l'émergence d'une interface commune entre les développeurs et les projets logiciels. Maven est plus une plateforme qu'un outil, lorsque vous considérez Maven comme une alternative à Ant, vous comparez des pommes à des oranges. "Maven" est plus qu'un simple outil de build.
    </para>
    <para>C'est cela qui rend les débats sur Maven ou Ant, Maven ou Buildr, Maven ou Gradle inintéressants. Maven ne se réduit pas aux seuls mécanismes de votre système de build, il ne se contente pas de scripter les différentes tâches de votre build, mais il encourage l'émergence d'un ensemble de standards, d'une interface commune, d'un cycle de vie, d'un format de dépôt, d'un standard d'organisation des répertoires, etc. 
    Peu importe le format du
      <acronym>POM</acronym>
      <acronym>(XML</acronym> ou
      <acronym>YAML</acronym> ou Ruby). Maven est bien plus que tout cela, et Maven fait référence à bien plus que l'outil en lui-même. Quand ce livre parle de Maven, il fait référence à la constellation de logiciels, de systèmes, et de standards qui le supportent. Buildr, Ivy, Gradle, tous ces outils interagissent avec le format de dépôt que Maven a permis de créer, et vous pourriez tout aussi facilement utiliser repository manager comme Nexus pour gérer des builds écrits entièrement avec Ant.
    </para>
    <para>Bien que Maven soit une alternative à ces outils, la communauté doit abandonner cet esprit de lutte sanglante pour s'approprier utilisateurs et développeurs. C'est peut-être ainsi que ça se passe entre grosses entreprises, mais cela ne correspond pas à la manière de faire des communautés opensource.  Les gros titres tels que "Qui sera le vainqueur ? Ant ou Maven ?" ne sont pas très constructifs. Si vous exigez de nous une réponse, bien sûr que nous dirons que Maven est une meilleure alternative que Ant comme technologie fondamentale pour un build; en même temps, les frontières de Maven changent tout le temps, et la communauté Maven cherche en permanence de nouvelles voies pour le rendre plus &oelig;cuménique, plus interopérable, plus coopératif. Les principes au c&oelig;ur de Maven sont le build déclaratif, la gestion des dépendances, les dépôts, la réutilisation universelle grâce aux plugins, cependant la concrétisation de ces idées n'a que peu d'importance par rapport au fait que la communauté opensource collabore pour améliorer l'efficacité des builds à "l'échelle de l'entreprise".</para>
  </section>
  <section id="installation-sect-compare-ant-maven" label="">
    <title>Comparaison de Maven et de Ant</title>
    <para>Les auteurs de ce livre n'ont pas pour objectif de créer de l'animosité entre Apache Ant et Apache Maven.
    cependant nous sommes conscients que pour la plupart des organisations il faut faire un choix entre Apache Ant et Apache Maven. 
    Dans cette section, nous allons comparer ces deux outils.
    </para>
    <para>Ant excelle dans le processus de build, c'est un système de build héritant de make avec des cibles et des dépendances. Chaque cible se compose d'un ensemble d'instructions codées en
      <acronym>XML</acronym>. Il existe une tâche
      <sgmltag>copy</sgmltag>, une tâche
      <sgmltag>javac</sgmltag>, tout comme une tâche
      <sgmltag>jar</sgmltag>. Quand vous utilisez Ant, vous lui fournissez  un ensemble d'instructions spécifiques pour compiler et packager le résultat. Prenons par exemple ce simple fichier
      <filename>build.xml</filename> :</para>
    <example id="ex-ant-sample">
      <title>Simple fichier build.xml pour Ant</title>
      <programlisting language="xml">&lt;project name="my-project" default="dist" basedir="."&gt;
    &lt;description&gt;
        simple example build file
    &lt;/description&gt;
  &lt;!-- set global properties for this build --&gt;
  &lt;property name="src" location="src/main/java"/&gt;
  &lt;property name="build" location="target/classes"/&gt;
  &lt;property name="dist"  location="target"/&gt;

  &lt;target name="init"&gt;
    &lt;!-- Create the time stamp --&gt;
    &lt;tstamp/&gt;
    &lt;!-- Create the build directory structure used by compile --&gt;
    &lt;mkdir dir="\${build}"/&gt;
  &lt;/target&gt;

  &lt;target name="compile" depends="init"
        description="compile the source " &gt;
    &lt;!-- Compile the java code from \${src} into \${build} --&gt;
    &lt;javac srcdir="\${src}" destdir="\${build}"/&gt;
  &lt;/target&gt;

  &lt;target name="dist" depends="compile"
        description="generate the distribution" &gt;
    &lt;!-- Create the distribution directory --&gt;
    &lt;mkdir dir="\${dist}/lib"/&gt;

    &lt;!-- Put everything in \${build} into the MyProject-\${DSTAMP}.jar file --&gt;
    &lt;jar jarfile="\${dist}/lib/MyProject-\${DSTAMP}.jar" basedir="\${build}"/&gt;
  &lt;/target&gt;

  &lt;target name="clean"
        description="clean up" &gt;
    &lt;!-- Delete the \${build} and \${dist} directory trees --&gt;
    &lt;delete dir="\${build}"/&gt;
    &lt;delete dir="\${dist}"/&gt;
  &lt;/target&gt;
&lt;/project&gt;</programlisting>
</example>
    <para>Dans cet exemple, on peut voir qu'il faut dire à Ant exactement ce qu’il doit faire. On a une cible compile qui inclut la tâche
      <varname>javac</varname> pour compiler le code source du répertoire
      <filename>src/main/java</filename> dans le répertoire
      <filename>target/classes</filename>. Vous devez indiquer à Ant exactement où se trouve votre code source, où le bytecode produit devra être sauvé, et comment packager tout cela dans un fichier
      <acronym>JAR</acronym>. Même si des développements récents tendent à rendre Ant moins procédural, pour un développeur
Ant reste un langage de code procédural en  
      <acronym>XML</acronym>.
    </para>
    <para>Comparons l'exemple Ant précédent avec un exemple Maven. Avec Maven, pour créer un fichier JAR à partir de code source Java, tout ce que vous avez à faire est de créer un simple
      <filename>pom.xml</filename>, mettre votre code source dans
      <filename>\${basedir}/src/main/java</filename> et exécuter la commande
      <command>mvn
    install
      </command> depuis la ligne de commande. Le contenu du
      <filename>pom.xml</filename> Maven qui permet d'obtenir le même résultat que
le simple fichier Ant décrit dans l'
      <xref linkend="ex-ant-sample" /> est le suivant :
    </para>
    <example id="ex-maven-sample">
      <title>Un Simple pom.xml pour Maven</title>
      <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;my-project&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
&lt;/project&gt;</programlisting>
    </example>
    <para>C'est tout ce dont vous avez besoin dans votre
      <filename>pom.xml</filename>. Exécuter
      <command>mvn install</command> depuis la ligne de commande va traiter les ressources, compiler le source, exécuter les tests unitaires, créer un
      <acronym>JAR</acronym>, et installer ce
      <acronym>JAR</acronym> dans le dépôt local pour qu'il soit réutilisable par d'autres projets. Toujours sans rien modifier, vous pouvez exécuter la commande
      <command>mvn site</command> et vous trouverez un fichier
      <filename>index.html</filename> dans
      <filename>target/site</filename> contenant des liens vers la JavaDoc et quelques rapports sur votre code source.
    </para>
    <para>
    Certes, c'est l'exemple de projet le plus simple possible. 
    Il ne contient rien d'autre que du code source et produit un
      <acronym>JAR</acronym>. C'est un projet qui suit les conventions de Maven et qui ne demande aucune dépendance ou personnalisation. Si nous voulons personnaliser le comportement, notre
      <filename>pom.xml</filename> va grossir, et dans les plus gros projets vous pouvez trouver une collection de
      <acronym>POM</acronym>s Maven très complexes qui contiennent beaucoup de configuration de plugins et de déclarations de dépendances. Mais, même lorsque les fichiers
      <acronym>POM</acronym> de votre projet grossissent, ils contiennent des informations d'une nature différente de celles du fichier de build Ant d'un projet de taille similaire. Les
      <acronym>POM</acronym>s Maven contiennent des déclarations : "C'est un projet
      <acronym>JAR</acronym>", et "Le code source se trouve dans
      <filename>src/main/java</filename>". Les scripts Ant contiennent des instructions explicites : "Ceci est le projet", "Le code source se trouve dans
      <filename>src/main/java</filename>", "Exécuter javac sur ce répertoire, "Mettre les résultats dans
      <filename>target/classes</filename>", "Créer un
      <acronym>JAR</acronym> à partir de ....", etc. Là où Ant se doit d'être explicite avec le traitement, il y a quelque chose "d'inné" chez Maven qui sait où se trouve le code source et ce qu'il doit en faire.
    </para>
    <para>Les différences entre Ant et Maven dans cet exemple sont :</para>
    <para>
      <variablelist>
        <varlistentry>
          <term>Apache Ant</term>
          <listitem>
            <para>
              <itemizedlist>
                <listitem>
                  <para>Ant de dispose d'aucune convention formelle ni comportement par défaut. Il vous faut indiquer à Ant
                    <emphasis>exactement</emphasis> où trouver le source et où mettre les résultats. Des conventions informelles ont émergé au cours du temps, mais elles n'ont pas été intégrées au produit.
                  </para>
                </listitem>
                <listitem>
                  <para>Ant est procédural. Il faut lui indiquer exactement ce qu'il doit faire et quand le faire. Il faut lui dire de compiler, puis de copier, puis de compresser.</para>
                </listitem>
                <listitem>
                  <para>Ant n'a pas de cycle de vie. Vous devez définir des fonctions et les dépendances de ces fonctions. Vous devez ensuite rattacher une série de tâches à chaque fonction manuellement. </para>
                </listitem>
              </itemizedlist>
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Apache Maven</term>
          <listitem>
            <para>
              <itemizedlist>
                <listitem>
                  <para>Maven possède ses conventions. Il sait où se trouve le code source car vous suivez une convention. 
                  Le plugin Maven Compiler place le bytecode dans
                    <filename>target/classes</filename> et produit un fichier
                    <acronym>JAR</acronym> dans le répertoire target.
                  </para>
                </listitem>
                <listitem>
                  <para>Maven est déclaratif. Tout ce que vous avez à faire est de créer un fichier
                    <filename>pom.xml</filename> et mettre votre code source dans le répertoire par défaut. Maven s'occupe du reste.
                  </para>
                </listitem>
                <listitem>
                  <para>Maven possède son propre cycle de vie que vous invoquez lorsque vous exécutez la 
                  commande <command>mvn install</command>. Cette commande demande à Maven d'exécuter une série d'étapes jusqu'à la fin du cycle de vie. Une des conséquences de ce parcours du cycle de vie, est que Maven exécute un certain nombre de goals de plugins par défaut qui vont réaliser certaines tâches comme de compiler et de créer un
                    <acronym>JAR</acronym>.
                  </para>
                </listitem>
              </itemizedlist>
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
    <para>Maven intègre une certaine intelligence sur les tâches communes sous la forme de plugins Maven. 
    Si vous voulez écrire et exécuter des tests unitaires, tout ce que vous avez à faire est d'écrire ces tests 
    et de les mettre dans <filename>\${basedir}/src/test/java</filename>, ajouter une dépendance de type test sur TestNG ou JUnit, 
      et exécuter la commande <command>mvn test</command>. 
      Si vous voulez déployer une application web et non plus un <acronym>JAR</acronym>, 
      tout ce que vous avez à faire est de changer le type de votre projet en <varname>war</varname> et de positionner le docroot sur
      <filename>\${basedir}/src/main/webapp</filename>. 
      Bien sûr, vous pourriez faire tout cela avec Ant mais vous devriez tout écrire depuis le début. Dans Ant, vous devriez commencer par définir où devrait se trouver le fichier
      <acronym>JAR</acronym> de JUnit, ensuite vous devriez créer un classpath qui contienne ce fichier
      <acronym>JAR</acronym> de JUnit, puis vous devriez indiquer à Ant où devrait se trouver le code source des tests, écrire une fonction pour compiler le code source des tests en bytecode, et pour exécuter ces tests unitaires avec JUnit.
    </para>
    <para>Sans l'apport des technologies comme antlibs et Ivy (et même avec ces technologies complémentaires), Ant laisse l'impression d'un build procédural personnalisé. Un ensemble efficace de
      <acronym>POM</acronym>s Maven dans un projet qui respecte les conventions de Maven a peu de
      <acronym>XML</acronym>, aussi surprenant que cela puisse paraître, en comparaison de Ant. Un autre avantage de Maven est qu'il s'appuie sur des plugins Maven très largement diffusés et partagés. Tout le monde utilise le plugin Maven Surefire pour les tests unitaires, et si quelqu'un ajoute le support d'un nouveau framework de tests unitaires, vous obtenez cette nouvelle fonctionnalité dans votre build juste en incrémentant le numéro de version de ce plugin particulier dans le
      <acronym>POM</acronym> de votre projet.
    </para>
    <para>La décision d'utiliser Maven ou Ant n'est pas une décision binaire, et Ant a toujours sa place pour les builds complexes. Si votre build contient un traitement très spécifique, ou si vous avez écrit des scripts Ant pour remplir une tâche particulière de manière spécifique qui ne peut être adaptée aux standards Maven, vous pouvez toujours utiliser ces scripts dans Maven. Ant est disponible sous la forme d'un des principaux plugins de Maven. Des plugins personnalisés de Maven peuvent être écrits en utilisant Ant, et les projets Maven peuvent être configurés pour exécuter des scripts Ant durant le cycle de vie du projet Maven.</para>
  </section>
</chapter>
