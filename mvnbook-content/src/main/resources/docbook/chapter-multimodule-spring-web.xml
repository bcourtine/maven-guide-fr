<?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="multimodule-web-spring"><title>Projet Multi-module Enterprise</title>  <section id="multimodule-web-spring-sect-intro"><title>Introduction</title> <para>Dans ce chapitre, nous créons un projet multimodule qui transfome les projets<indexterm class="startofrange" id="enterprise1a"> <primary>multimodule project (example)</primary> <secondary>multimodule enterprise project</secondary> </indexterm><indexterm class="startofrange" id="enterprise1b"> <primary>Web applications</primary> <secondary>multimodule enterprise project example</secondary> </indexterm><indexterm class="startofrange" id="enterprise1c"> <primary>enterprise project, multimodule (example)</primary> </indexterm> exemples du <xref linkend="multimodule" /> et du <xref linkend="web" /> en un projet utilisant à la fois le framework Spring et Hibernate pour réaliser une application web et une application en ligne de commande qui lisent les données du flux Yahoo! Weather. Le code <varname>simple-weather</varname> développé dans le <xref linkend="customizing" /> va être combiné à celui du projet <varname>simple-webapp</varname> écrit dans le <xref linkend="web" />. Tout au long de la réalisation de le projet multimodule, nous explorerons Maven et les différentes manières de l'utiliser pour réaliser des projets modulaires et favoriser la réutilisation. </para> <section id="multimodule-web-spring-sect-downloading-example"><title>Télécharger l'Exemple de ce Chapitre</title> <para>Le projet multi-module développé dans cet exemple consiste en une version modifiée des projets développés dans le <xref linkend="customizing" /> et le <xref linkend="web" />, et nous n'allons pas utiliser le plugin Archetype pour générer la structure de ce projet multi-module. Nous vous recommandons chaudement de télécharger une copie du code de l'exemple comme référence supplémentaire à votre lecture de ce chapitre Sans les exemples, vous ne pourrez pas recréer le code d'exemple de ce chapitre. Le projet exemple de ce chapitre peut être téléchargé avec le code d'exemple de ce livre à l'adresse <ulink
      url="http://www.sonatype.com/book/mvn-examples-1.0.zip">http://www.sonatype.com/book/mvn-examples-1.0.zip</ulink> ou <ulink
      url="http://www.sonatype.com/book/mvn-examples-1.0.tar.gz">http://www.sonatype.com/book/mvn-examples-1.0.tar.gz</ulink>. Décompressez cette archive dans le répertoire de votre choix, et allez dans le répertoire <filename>ch07/</filename>. Dans le répertoire <filename>ch07/</filename> vous trouverez un répertoire <filename>simple-parent/</filename> qui contient le projet Maven multi-module qui sera développé dans ce chapitre. Dans le répertoire <filename>simple-parent/</filename> vous trouverez un <filename>pom.xml</filename> et les cinq répertoires des sous-modules <filename>simple-model/</filename>, <filename>simple-persist/</filename>, <filename>simple-command/</filename>, <filename>simple-weather/</filename> et <filename>simple-webapp/</filename>. Si vous souhaitez suivre avec le code d'exemple affiché dans un navigateur web, allez à <ulink
      url="http://www.sonatype.com/book/examples-1.0">http://www.sonatype.com/book/examples-1.0</ulink> et cliquez sur le répertoire <filename>ch07/</filename>. </para> </section> <section id="multimodule-web-spring-sect-project-description"><title>Projet d'Entreprise Multi-module</title> <para>Présenter la complexité d'un gros projet d'entreprise dépasse de loin l'objectif de ce livre. De tels projets se caractérisent par de nombreuses bases de données, l'intégration à des systèmes externes, et des sous projets qui peuvent être répartis sur différents services. Ces projets se composent habituellement de milliers de lignes de code, et demandent les efforts de dizaines voir de centaines de développeurs. Si un exemple complet ne tiendrait pas dans ce livre, nous pouvons vous proposer un projet d'exemple qui suggère la complexité d'une grosse application d'Entreprise. Dans la conclusion nous vous donnons quelques pistes pour gérer la modularité au delà de ce qui a été présenté dans ce chapitre.</para> <para>Dans ce chapitre, nous allons étudier un projet Maven multi-module qui va produire deux applications: un outil de requêtage en ligne de commade pour le flux de Yahoo! Weather et une application web qui requête le flux Yahoo! Weather. Ces deux applications vont enregistrer les résultats des equêtes dnas une base de données embarquée. Chacune permettra à l'utilisateur de récupérer les données historisées de la météo depuis cette base de données embarquée. Les deux applications vont réutiliser la même logique métier et vont partager la bibilothèque de persistance. L'exemple de ce chapitre est construit autour du code parsant Yahoo! Weather introduit dans le <xref linkend="customizing" />. Ce projet se divise en cinq sous-modules présentés dans la <xref linkend="fig-multimodule-web-spring-projects" />. </para> <figure id="fig-multimodule-web-spring-projects"><title>Relations entre modules dans une application d'Entreprise Multi-module</title> <mediaobject> <imageobject role="web"> <imagedata fileref="figs/web/multimodule-web-spring_projects.png"
                       scalefit="1" width="8in" /> </imageobject> <imageobject role="print"> <imagedata fileref="figs/print/multimodule-web-spring_projects.pdf"
                       format="PDF" /> </imageobject> </mediaobject> </figure> <para>Dans <xref linkend="fig-multimodule-web-spring-projects" />, vous pouvez voir qu'il existe cinq sous-modules de simple-parent, il s'agit de: </para> <variablelist> <varlistentry><term>simple-model</term> <listitem> <para>Ce module définit un mdoèle objet assez simple qui représente les données renvoyées par le flux Yahoo! Weather. Ce modèle objet contient les classes <classname>Weather</classname>, <classname>Condition</classname>, <classname>Atmosphere</classname>, <classname>Location</classname>, et <classname>Wind</classname>. Lorsque notre application parse le flux Yahoo! Weather, les parsers définis dans <varname>simple-weather</varname> vont parser le <acronym>XML</acronym> et créer des objets <classname>Weather</classname> qui sont utilisés par l'application. Ce projet contient des objets métier annotés avec des Annotations Hibernate 3 qui sont utilisées par le module simple-persist pour associer chacun de ces objets à une table dans la base de données relationnelle. </para> </listitem> </varlistentry> <varlistentry><term>simple-weather</term> <listitem> <para>This module contains all of the logic required to retrieve data from the Yahoo! Weather feed and parse the resulting <acronym>XML</acronym>. The <acronym>XML</acronym> returned from this feed is converted into the model objects defined in <varname>simple-model</varname>. <varname>simple-weather</varname> has a dependency on <varname>simple-model</varname>. <varname>simple-weather</varname> defines a <classname>WeatherService</classname> object which is referenced by both the <varname>simple-command</varname> and <varname>simple-webapp</varname> projects. </para> </listitem> </varlistentry> <varlistentry><term>simple-persist</term> <listitem> <para>This module contains some Data Access Objects (<acronym>DAO</acronym>) which are configured to store <classname>Weather</classname> objects in an embedded database. Both of the applications defined in this multi-module project will use the <acronym>DAO</acronym>s defined in <varname>simple-persist</varname> to store data in an embedded database. The <acronym>DAO</acronym>s defined in this project understand and return the model objects defined in <varname>simple-model</varname>. <varname>simple-persist</varname> has a direct dependency on <varname>simple-model</varname> and it depends upon the Hibernate Annotations present on the model objects. </para> </listitem> </varlistentry> <varlistentry><term>simple-webapp</term> <listitem> <para>The web application project contains two Spring <acronym>MVC</acronym> Controller implementations which use the <classname>WeatherService</classname> defined in <varname>simple-weather</varname> and the <acronym>DAO</acronym>s defined in <varname>simple-persist</varname>. <varname>simple-webapp</varname> has a direct dependency on <varname>simple-weather</varname> and <varname>simple-persist</varname>; it has a transitive dependency on <varname>simple-model</varname>. </para> </listitem> </varlistentry> <varlistentry><term>simple-command</term> <listitem> <para>This module contains a simple command-line tool which can be used to query the Yahoo! Weather feed. This project contains a class with a static <methodname>main() </methodname>function and interacts with the <classname>WeatherService</classname> defined in <varname>simple-weather</varname> and the <acronym>DAO</acronym>s defined in <varname>simple-persist</varname>. <varname>simple-command</varname> has a direct dependency on <varname>simple-weather</varname> and <varname>simple-persist</varname>; is has a transitive dependency on <varname>simple-model</varname>.</para> </listitem> </varlistentry> </variablelist> <para>This chapter contains a contrived example simple enough to introduce in a book, yet complex enough to justify a set of five submodules. Our contrived example has a model project with five classes, a persistence library with two service classes, and a weather parsing library with five or six classes, but a real-world system might have a model project with a hundred objects, several persistence libraries, and service libraries spanning multiple departments. Although we’ve tried to make sure that the code contained in this example is straightforward enough to comprehend in a single sitting, we’ve also gone out of our way to build a modular project. You might be tempted to look at the examples in this chapter and walk away with the idea that Maven encourages too much complexity given that our model project has only five classes. Although using Maven does suggest a certain level of modularity, do realize that we’ve gone out of our way to complicate our simple example projects for the purpose of demonstrating Maven’s multimodule features. </para> </section> <section id="multimodule-web-spring-sect-example-tech"><title>Technology Used in this Example</title> <para>This chapter's example involves some technology which, while popular, is not directly related to Maven. These technologies are the Spring Framework and Hibernate. The Spring Framework is an Inversion of Control (<acronym>IoC</acronym>) container and a set of frameworks that aim to simplify interaction with various <acronym>J2EE</acronym> libraries. Using the Spring Framework as a foundational framework for application development gives you access to a number of helpful abstractions that can take much of the meddlesome busywork out of dealing with persistence frameworks like Hibernate or iBatis or enterprise <acronym>API</acronym>s like <acronym>JDBC</acronym>, <acronym>JNDI</acronym>, and <acronym>JMS</acronym>. The Spring Framework has grown in popularity over the past few years as a replacement for the heavy weight enterprise standards coming out of Sun Microsystems. Hibernate is a widely used Object-Relational Mapping framework which allows you to interact with a relational database as if it were a collection of Java objects. This example focuses on building a simple web application and a command-line application that uses the Spring Framework to expose a set of reusable components to applications and which also uses Hibernate to persist weather data in an embedded database.</para> <para>We’ve decided to include references to these frameworks to demonstrate how one would construct projects using these technologies when using Maven. Although we make brief efforts to introduce these technologies throughout this chapter, we will not go out of our way to fully explain these technologies. For more information about the Spring Framework, please see the project’s web site at <ulink
      url="http://www.springframework.org/"></ulink>. For more information about Hibernate and Hibernate <phrase role="keep-together">Annotations</phrase>, please see the project’s web site at <ulink url="http://www.hibernate.org"></ulink>. This chapter uses Hyper-threaded Structured Query Language Database (<acronym>HSQLDB</acronym>) as an embedded database; for more information about this database, see the project’s web site at <ulink
      url="http://hsqldb.org/"></ulink>. </para> </section> </section> <section id="multimodule-web-spring-sect-simple-parent"><title>The Simple Parent Project</title> <para>This <varname>simple-parent</varname> project has a<indexterm class="startofrange" id="enterprise2a"> <primary>simple parent project (example)</primary> <secondary>multimodule enterprise</secondary> </indexterm><indexterm class="startofrange" id="enterprise2b"> <primary>multimodule project (example)</primary> <secondary>multimodule enterprise project</secondary> <tertiary>simple parent project</tertiary> </indexterm><indexterm class="startofrange" id="enterprise2c"> <primary>Web applications</primary> <secondary>multimodule enterprise project example</secondary> <tertiary>simple parent project</tertiary> </indexterm><indexterm class="startofrange" id="enterprise2d"> <primary>enterprise project, multimodule (example)</primary> <secondary>simple parent project</secondary> </indexterm> <filename>pom.xml</filename> that references five submodules: <varname>simple-command</varname>, <varname>simple-model</varname>, <varname>simple-weather</varname>, <varname>simple-persist</varname>, and <varname>simple-webapp</varname>. The top-level <filename>pom.xml</filename> is shown in <xref linkend="ex-multimodule-web-spring-parent" />. </para> <example id="ex-multimodule-web-spring-parent"><title>simple-parent Project POM</title> <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
  &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;name&gt;Chapter 7 Simple Parent Project&lt;/name&gt;
 
  &lt;modules&gt;
    &lt;module&gt;simple-command&lt;/module&gt;
    &lt;module&gt;simple-model&lt;/module&gt;
    &lt;module&gt;simple-weather&lt;/module&gt;
    &lt;module&gt;simple-persist&lt;/module&gt;
    &lt;module&gt;simple-webapp&lt;/module&gt;
  &lt;/modules&gt;

  &lt;build&gt;
    &lt;pluginManagement&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
          &lt;configuration&gt;
            &lt;source&gt;1.5&lt;/source&gt;
            &lt;target&gt;1.5&lt;/target&gt;
          &lt;/configuration&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
   &lt;/pluginManagement&gt; 
  &lt;/build&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;

</programlisting> </example> <note> <para>If you are already familiar with Maven POMs, you might notice that this top-level POM does not define a <sgmltag>dependencyManagement</sgmltag> element. The <sgmltag>dependencyManagement</sgmltag> element allows you to define dependency versions in a single, top-level POM, and it is introduced in <xref linkend="optimizing" />.</para> </note> <para>Note the similarities of this parent <acronym>POM</acronym> to the parent <acronym>POM</acronym> defined in <xref linkend="ex-multimodule-parent-pom" />. The only real difference between these two <acronym>POM</acronym>s is the list of submodules. Where that example only listed two submodules, this parent <acronym>POM</acronym> lists five submodules. The next few sections explore each of these five submodules in some detail. Because our example uses Java annotations, we've configured the compiler to target the Java 5 <acronym>JVM</acronym>. </para> </section> <section id="multimodule-web-spring-sect-simple-model-project"><title>The Simple Model Module</title> <para>The first thing most enterprise projects need is an object model. An object model captures the core set of domain objects in any system. A banking system might have an object model which consists of an <classname>Account</classname>, <classname>Customer</classname>, and <classname>Transaction</classname> object, or a system to capture and communicate sports scores might have a <classname>Team</classname> and a <classname>Game</classname> object. Whatever it is, there's a good chance that you've modeled the concepts in your system in an object model. It is a common practice in Maven projects to separate this project into a separate project which is widely referenced. In this system we are capturing each query to the Yahoo! Weather feed with a <classname>Weather</classname> object which references four other objects. Wind direction, chill, and speed are stored in a <classname>Wind</classname> object. Location data including the zip code, city, region, and country are stored in a <classname>Location</classname> class. Atmospheric conditions such as the humidity, maximum visibility, barometric pressure, and whether the pressure is rising or falling is stored in an <classname>Atmosphere</classname> class. A textual description of conditions, the temperature, and the date of the observation is stored in a <classname>Condition</classname> class. </para> <figure><title>Simple Object Model for Weather Data</title> <mediaobject> <imageobject role="web"> <imagedata fileref="figs/web/multimodule-web-spring_object-model.png"
                     format="PNG" scalefit="1" width="" /> </imageobject> <imageobject role="print"> <imagedata fileref="figs/print/multimodule-web-spring_object-model.pdf"
                     format="PDF" /> </imageobject> </mediaobject> </figure> <para>The <filename>pom.xml</filename> file for this simple model object contains one dependency that bears some explanation. Our object model is<indexterm> <primary>Hibernate annotations</primary> </indexterm><indexterm> <primary>annotations (Hibernate)</primary> </indexterm> annotated with Hibernate Annotations. We use these annotations to map the model objects in this model to tables in a relational database. The dependency is <varname>org.hibernate:</varname><varname>hibernate-annotations:</varname><varname>3.3.0.ga</varname>. Take a look at the <filename>pom.xml</filename> shown in <xref linkend="example_simple-model_pom.xml" />, and then look at the next few examples for some illustrations of these annotations. </para> <example id="example_simple-model_pom.xml"><title>simple-model pom.xml</title> <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;simple-model&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;Simple Object Model&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-commons-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting> <para>In <filename>src/main/java/org/sonatype/mavenbook/weather/model</filename>, we have <filename>Weather.java</filename>, which contains the annotated <classname>Weather</classname> model object. The <classname>Weather</classname> object is a simple Java bean. This means that we have private member variables like <varname>id</varname>, <varname>location</varname>, <varname>condition</varname>, <varname>wind</varname>, <varname>atmosphere</varname>, and <varname>date</varname> exposed with public getter and setter methods that adhere to the following pattern: if a property is named <literal>name</literal>, there will be a public no-arg getter method named <methodname>getName()</methodname>, and there will be a one-argument <phrase>setter</phrase> named <methodname
      role="keep-together">setName(String name)</methodname>. Although we show the getter and setter method for the <varname>id</varname> property, we’ve omitted most of the getters and setters for most of the other properties to save a few trees. See <xref linkend="example_weather_model_object" />. </para> </example> <example id="example_weather_model_object"><title>Annotated Weather Model Object</title> <programlisting language="java">package org.sonatype.mavenbook.weather.model;

import javax.persistence.*;

import java.util.Date;

@Entity
@NamedQueries({
  @NamedQuery(name="Weather.byLocation", 
              query="from Weather w where w.location = :location")
})
public class Weather {

    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Integer id;

    @ManyToOne(cascade=CascadeType.ALL)
    private Location location;

    @OneToOne(mappedBy="weather",cascade=CascadeType.ALL)
    private Condition condition;

    @OneToOne(mappedBy="weather",cascade=CascadeType.ALL)
    private Wind wind;

    @OneToOne(mappedBy="weather",cascade=CascadeType.ALL)
    private Atmosphere atmosphere;

    private Date date;
    
    public Weather() {}

    public Integer getId() { return id; }
    public void setId(Integer id) { this.id = id; }

    // All getter and setter methods omitted...
}
</programlisting> </example> <para>In the <classname>Weather</classname> class, we are using Hibernate annotations to provide guidance to the <varname>simple-persist</varname> project. These annotations are used by Hibernate to map an object to a table in a relational database. Although a full explanation of Hibernate annotations is beyond the scope of this chapter, here is a brief<indexterm> <primary sortas="Entity annotation (Hibernate)">@Entity annotation (Hibernate)</primary> </indexterm> explanation for the curious. The <classname>@Entity</classname> annotation marks this class as a persistent entity. We’ve omitted the<indexterm> <primary sortas="Table annotation (Hibernate)">@Table annotation (Hibernate)</primary> </indexterm> <classname>@Table</classname> annotation on this class, so Hibernate is going to use the name of the class as the name of the table to map <classname>Weather</classname> to. The<indexterm> <primary sortas="NamedQueries annotation (Hibernate)">@NamedQueries annotation (Hibernate)</primary> </indexterm> <classname>@NamedQueries</classname> annotation defines a query that is used by the <classname>WeatherDAO</classname> in <varname>simple-persist</varname>. The query language in the<indexterm> <primary sortas="NamedQuery annotation (Hibernate)">@NamedQuery annotation (Hibernate)</primary> </indexterm> <classname>@NamedQuery</classname> annotation is written in something<indexterm> <primary>HQL (Hibernate Query Language)</primary> </indexterm> called Hibernate Query Language (<acronym>HQL</acronym>). Each member variable is annotated with annotations that define the type of column and any relationships implied by that column: </para> <variablelist> <varlistentry><term role="plain"><varname>Id</varname></term> <listitem> <para>The <varname>id</varname> property is annotated with <classname>@Id</classname>. This marks the <varname>id</varname> property as the property that contains the primary key in a database table. The <classname>@GeneratedValue</classname> controls how new primary key values are generated. In the case of <varname>id</varname>, we’re using the <varname>IDENTITY</varname> <classname>GenerationType</classname>, which will use the underlying database’s identity generation facilities. </para> </listitem> </varlistentry> <varlistentry><term role="plain"><varname>Location</varname></term> <listitem> <para>Each <classname>Weather</classname> object instance corresponds to a <classname>Location</classname> object. A <classname>Location</classname> object represents a zip code, and the <classname>@ManyToOne</classname> makes sure that <classname>Weather</classname> objects that point to the same <classname>Location</classname> object reference the same instance. The <varname>cascade</varname> attribute of the <classname>@ManyToOne</classname> makes sure that we persist a <classname>Location</classname> object every time we persist a <classname>Weather</classname> object. </para> </listitem> </varlistentry> <varlistentry><term role="plain"><varname>Condition</varname>, <varname>Wind</varname>, <varname>Atmosphere</varname></term> <listitem> <para>Each of these objects is mapped as a <classname>@OneToOne</classname> with the <classname>CascadeType</classname> of <varname>ALL</varname>. This means that every time we save a <classname>Weather</classname> object, we’ll be inserting a row into the <varname>Weather</varname> table, the <varname>Condition</varname> table, the <varname>Wind</varname> table, and the <varname>Atmosphere</varname> table. </para> </listitem> </varlistentry> <varlistentry><term role="plain"><varname>Date</varname></term> <listitem> <para><varname>Date</varname> is not annotated. This means that Hibernate is going to use all of the column defaults to define this mapping. The column name is going to be <literal>date</literal>, and the column type is going to be the appropriate time to match the <classname>Date</classname> object.</para> <note> <para>If you have a property you wish to omit from a table mapping, you would annotate that property with <classname>@Transient</classname>.</para> </note> </listitem> </varlistentry> </variablelist> <para>Next, take a look at one of the secondary model objects, <classname>Condition</classname>, shown in <xref linkend="example_condition_model_object" />. This class also resides in <filename>src/main/java/org/sonatype/mavenbook/weather/model</filename>. </para> <example id="example_condition_model_object"><title>simple-model's Condition model object.</title> <programlisting language="java">package org.sonatype.mavenbook.weather.model;

import javax.persistence.*;

@Entity
public class Condition {

    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Integer id;

    private String text;
    private String code;
    private String temp;
    private String date;

    @OneToOne(cascade=CascadeType.ALL)
    @JoinColumn(name="weather_id", nullable=false)
    private Weather weather;

    public Condition() {}

    public Integer getId() { return id; }
    public void setId(Integer id) { this.id = id; }

    // All getter and setter methods omitted...
}</programlisting> </example> <para>The <classname>Condition</classname> class resembles the <classname>Weather</classname> class. It is annotated as an <classname>@Entity</classname>, and it has similar annotations on the <varname>id</varname> property. The <varname>text</varname>, <varname>code</varname>, <varname>temp</varname>, and <varname>date</varname> properties are all left with the default column settings, and the <varname>weather</varname> property is annotated with a <classname>@OneToOne</classname> annotation and another annotation that references the associated <classname>Weather</classname> object with a foreign key column named <varname>weather_id</varname>. </para> </section> <section id="multimodule-web-spring-sect-simple-weather"><title>The Simple Weather Module</title> <para>The next module we’re going to examine could be considered something<indexterm class="startofrange" id="enterprise4a"> <primary>multimodule project (example)</primary> <secondary>multimodule enterprise project</secondary> <tertiary>Simple Weather module of</tertiary> </indexterm><indexterm class="startofrange" id="enterprise4b"> <primary>Web applications</primary> <secondary>multimodule enterprise project example</secondary> <tertiary>Simple Weather module of</tertiary> </indexterm><indexterm class="startofrange" id="enterprise4c"> <primary>enterprise project, multimodule (example)</primary> <secondary>Simple Weather module of</secondary> </indexterm> of a “service.” The Simple Weather module is the module that contains all of the logic necessary to retrieve and parse the data from the Yahoo! Weather <acronym>RSS</acronym> feed. Although Simple Weather contains three Java classes and one JUnit test, it is going to present a single component, <classname>WeatherService</classname>, to both the Simple Web Application and the Simple Command-line Utility. Very often an enterprise project will contain several <acronym>API</acronym> modules that contain critical business logic or logic that interacts with external systems. A banking system might have a module that retrieves and parses data from a third-party data provider, and a system to display sports scores might interact with an <acronym>XML</acronym> feed that presents real-time scores for basketball or soccer. In <xref linkend="example_simple-weather_module_pom" />, this module encapsulates all of the network activity and <acronym>XML</acronym> parsing that is involved in the interaction with Yahoo! Weather. Other modules can depend on this module and simply call out to the <methodname
    role="keep-together">retrieveForecast() </methodname>method on <classname>WeatherService</classname>, which takes a zip code as an argument and which returns a <classname>Weather</classname> object. </para> <example id="example_simple-weather_module_pom"><title>simple-weather Module POM</title> <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;simple-weather&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;Simple Weather API&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-model&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j&lt;/artifactId&gt;
      &lt;version&gt;1.2.14&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;dom4j&lt;/groupId&gt;
      &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
      &lt;version&gt;1.6.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;jaxen&lt;/groupId&gt;
      &lt;artifactId&gt;jaxen&lt;/artifactId&gt;
      &lt;version&gt;1.1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
      &lt;version&gt;1.3.2&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;

</programlisting> </example> <para>The <varname>simple-weather</varname> <acronym>POM</acronym> extends the <varname>simple-parent</varname> <acronym>POM</acronym>, sets the packaging to <varname>jar</varname>, and then adds the following dependencies: </para> <variablelist> <varlistentry><term><literal>org.sonatype.mavenbook.ch07:simple-model:1.0</literal></term> <listitem> <para><varname>simple-weather</varname> parses the Yahoo! Weather <acronym>RSS</acronym> feed into a <classname>Weather</classname> object. It has a direct dependency on <varname>simple-model</varname>. </para> </listitem> </varlistentry> <varlistentry><term><literal>log4j:log4j:1.2.14</literal></term> <listitem> <para><varname>simple-weather</varname> uses the Log4J library to print log messages. </para> </listitem> </varlistentry> <varlistentry><term><literal>dom4j:dom4j:1.6.1 and jaxen:jaxen:1.1.1</literal></term> <listitem> <para>Both of these dependencies are used to parse the <acronym>XML</acronym> returned from Yahoo! Weather. </para> </listitem> </varlistentry> <varlistentry><term><literal>org.apache.commons:commons-io:1.3.2 (scope=test)</literal></term> <listitem> <para>This <literal>test</literal>-scoped dependency is used by the <classname>YahooParserTest</classname>.</para> </listitem> </varlistentry> </variablelist> <para>Next is the <classname>WeatherService</classname> class, shown in <xref linkend="example_weatherservice_class" />. This class is going to look very similar to the <classname>WeatherService</classname> class from <xref linkend="multimodule-weather-service" />. Although the <classname>WeatherService</classname> is the same, there are some subtle differences in this chapter’s example. This version’s <methodname>retrieveForecast() </methodname>method returns a <classname>Weather</classname> object, and the formatting is going to be left to the applications that call <classname>WeatherService</classname>. The other major change is that the <classname>YahooRetriever</classname> and <classname>YahooParser</classname> are both bean properties of the <classname>WeatherService</classname> bean. </para> <example id="example_weatherservice_class"><title>The WeatherService class</title> <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.io.InputStream;

import org.sonatype.mavenbook.weather.model.Weather;

public class WeatherService {

  private YahooRetriever yahooRetriever;
  private YahooParser yahooParser;

  public WeatherService() {}

  public Weather retrieveForecast(String zip) throws Exception {
    // Retrieve Data
    InputStream dataIn = yahooRetriever.retrieve(zip);

    // Parse DataS
    Weather weather = yahooParser.parse(zip, dataIn);

    return weather;
  }

  public YahooRetriever getYahooRetriever() {
    return yahooRetriever;
  }

  public void setYahooRetriever(YahooRetriever yahooRetriever) {
    this.yahooRetriever = yahooRetriever;
  }

  public YahooParser getYahooParser() {
    return yahooParser;
  }

  public void setYahooParser(YahooParser yahooParser) {
    this.yahooParser = yahooParser;
  }
}
</programlisting> </example> <para>Finally, in this project we have an <acronym>XML</acronym> file that is used by the Spring Framework to create something called an<indexterm> <primary>ApplicationContext (Spring Framework)</primary> </indexterm> <classname>ApplicationContext</classname>. First, some explanation: both of our applications, the web application and the command-line utility, need to interact with the <classname>WeatherService</classname> class, and they both do so by retrieving an instance of this class from a Spring <classname>ApplicationContext</classname> using the name <varname>weatherService</varname>. Our web application uses a Spring <acronym>MVC</acronym> controller that is associated with an instance of <classname>WeatherService</classname>, and our command-line utility loads the <classname>WeatherService</classname> from an <classname>ApplicationContext</classname> in a static <methodname>main() </methodname>function. To encourage reuse, we’ve included an <filename>applicationContext-weather.xml</filename> file in <filename>src/main/resources</filename>, which is available on the classpath. Modules that depend on the <varname>simple-weather</varname> module can load this application context using the <classname>ClasspathXmlApplicationContext</classname> in the Spring Framework. They can then reference a named instance of the <classname>WeatherService</classname> named <varname>weatherService</varname>. </para> <example><title>Spring Application Context for the simple-weather Module</title> <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
             http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
    default-lazy-init="true"&gt;

    &lt;bean id="weatherService" 
             class="org.sonatype.mavenbook.weather.WeatherService"&gt;
      &lt;property name="yahooRetriever" ref="yahooRetriever"/&gt;
      &lt;property name="yahooParser" ref="yahooParser"/&gt;
    &lt;/bean&gt;    

    &lt;bean id="yahooRetriever" 
             class="org.sonatype.mavenbook.weather.YahooRetriever"/&gt;    

    &lt;bean id="yahooParser" 
             class="org.sonatype.mavenbook.weather.YahooParser"/&gt;
&lt;/beans&gt;</programlisting> </example> <para>This document defines three beans: <varname>yahooParser</varname>, <varname>yahooRetriever</varname>, and <varname>weatherService</varname>. The <varname>weatherService</varname> bean is an instance of <classname>WeatherService</classname>, and this <acronym>XML</acronym> document populates the <varname>yahooParser</varname> and <varname>yahooRetriever</varname> properties with references to the named instances of the corresponding classes. Think of this <filename>applicationContext-weather.xml</filename> file as defining the architecture of a subsystem in this multi-module project. Projects like <varname>simple-webapp</varname> and <varname>simple-command</varname> can reference this context and retrieve an instance of <classname>WeatherService</classname> which already has relationships to instances of <classname>YahooRetriever</classname> and <classname>YahooParser</classname>. </para> </section> <section id="multimodule-web-spring-sect-simple-persist"><title>The Simple Persist Module</title> <para>This module defines two very simple Data Access Objects (DAOs). A DAO<indexterm> <primary>DAO (Data Access Objects)</primary> </indexterm><indexterm class="startofrange" id="enterprise5a"> <primary>multimodule project (example)</primary> <secondary>multimodule enterprise project</secondary> <tertiary>Simple Persist module of</tertiary> </indexterm><indexterm class="startofrange" id="enterprise5b"> <primary>Web applications</primary> <secondary>multimodule enterprise project example</secondary> <tertiary>Simple Persist module of</tertiary> </indexterm><indexterm class="startofrange" id="enterprise5c"> <primary>enterprise project, multimodule (example)</primary> <secondary>Simple Persist module of</secondary> </indexterm> is an object that provides an interface for persistence operations. In an application that makes use of an Object-Relational Mapping (ORM) framework such as Hibernate, DAOs are usually defined around objects. In this project, we are defining two DAO objects: <varname
    role="keep-together">WeatherDAO</varname> and <varname>LocationDAO</varname>. The <varname>WeatherDAO</varname> class allows us to save a <varname>Weather</varname> object to a database and retrieve a <varname>Weather</varname> object by <literal>id</literal>, and to retrieve <varname>Weather</varname> objects that match a specific <varname>Location</varname>. The <varname>LocationDAO</varname> has a method that allows us to retrieve a <varname>Location</varname> object by zip code. First, let’s take a look at the <literal>simple-persist</literal> POM in <xref linkend="ex-simple-persist-POM" />. </para> <example id="ex-simple-persist-POM"><title>simple-persist POM</title> <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;simple-persist&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;Simple Persistence API&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-model&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate&lt;/artifactId&gt;
      &lt;version&gt;3.2.5.ga&lt;/version&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;javax.transaction&lt;/groupId&gt;
          &lt;artifactId&gt;jta&lt;/artifactId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-commons-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
      &lt;version&gt;2.4&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring&lt;/artifactId&gt;
      &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting> </example> <para>This <acronym>POM</acronym> file references <varname>simple-parent</varname> as a parent <acronym>POM</acronym>, and it defines a few dependencies. The dependencies listed in <varname>simple-persist</varname>'s <acronym>POM</acronym> are: </para> <variablelist> <varlistentry><term><literal>org.sonatype.mavenbook.ch07:simple-model:1.0</literal></term> <listitem> <para>Just like the <varname>simple-weather</varname> module, this persistence module references the core model objects defined in <varname>simple-model</varname>. </para> </listitem> </varlistentry> <varlistentry><term><literal>org.hibernate:hibernate:3.2.5.ga</literal></term> <listitem> <para>We define a dependency on Hibernate version 3.2.5.ga, but notice that we’re excluding a dependency of Hibernate. We’re doing this because the <varname>javax.</varname><varname>transaction:</varname><varname>javax</varname> <indexterm> <primary>dependencies</primary> <secondary>javax.transaction:javax (unavailable)</secondary> </indexterm><indexterm> <primary>javax.transaction:javax dependency (unavailable)</primary> </indexterm>dependency is not available in the public Maven repository. This dependency happens to be one of those Sun dependencies that has not yet made it into the free central Maven repository. To avoid an annoying message telling us to go download these nonfree dependencies, we simple exclude this dependency from Hibernate and add a dependency on... </para> </listitem> </varlistentry> <varlistentry><term><literal>javax.servlet:servlet-api:2.4</literal></term> <listitem> <para>Since this project contains a Servlet, we need to include the Servlet API version 2.4. </para> </listitem> </varlistentry> <varlistentry><term><literal>org.springframework:spring:2.0.7</literal></term> <listitem> <para>This includes the entire Spring Framework as a dependency<indexterm> <primary>Spring Framework</primary> </indexterm>.</para> <note> <para>It is generally a good practice to depend on only the components of Spring you happen to be using. The Spring Framework project has been nice enough to create focused artifacts such as <varname>spring-hibernate3</varname>.</para> </note> </listitem> </varlistentry> </variablelist> <para>Why depend on Spring? When it comes to Hibernate integration, Spring allows us to leverage helper classes such as <classname>HibernateDaoSupport</classname>. For an example of what is possible with the help of <classname>HibernateDaoSupport</classname>, take a look at the code for the <classname>WeatherDAO</classname> in <xref linkend="ex-persist-weatherdao-class" />. </para> <example id="ex-persist-weatherdao-class"><title>simple-persist's WeatherDAO Class</title> <programlisting>package org.sonatype.mavenbook.weather.persist;

import java.util.ArrayList;
import java.util.List;

import org.hibernate.Query;
import org.hibernate.Session;
import org.springframework.orm.hibernate3.HibernateCallback;
import org.springframework.orm.hibernate3.support.HibernateDaoSupport;

import org.sonatype.mavenbook.weather.model.Location;
import org.sonatype.mavenbook.weather.model.Weather;

public class WeatherDAO extends HibernateDaoSupport  <co
          id="coDef-hibDao-extends" linkends="coRef-hibDao-extends" />{ public WeatherDAO() {} public void save(Weather weather) { <co id="coDef-hibDao-2"
          linkends="coRef-hibDao-2" />getHibernateTemplate().save( weather ); } public Weather load(Integer id) { <co id="coDef-hibDao-3"
          linkends="coRef-hibDao-3" />return (Weather) getHibernateTemplate().load( Weather.class, id); } @SuppressWarnings("unchecked") public List&lt;Weather&gt; recentForLocation( final Location location ) { return (List&lt;Weather&gt;) getHibernateTemplate().execute( new HibernateCallback() { <co id="coDef-hibDao-4"
          linkends="coRef-hibDao-4" />public Object doInHibernate(Session session) { Query query = getSession().getNamedQuery("Weather.byLocation"); query.setParameter("location", location); return new ArrayList&lt;Weather&gt;( query.list() ); } }); }
}</programlisting> </example> <para>That's it. No really, you are done writing a class that can insert new rows, select by primary key, and find all rows in Weather that join to an id in the Location table. Clearly, we can't stop this book and insert the five hundred pages it would take to get you up to speed on the intricacies of Hibernate, but we can do some very quick explanation:</para> <calloutlist> <callout arearefs="coDef-hibDao-extends" id="coRef-hibDao-extends"> <para>This class extends <classname>HibernateDaoSupport</classname>. What this means is that the class is going to be associated with a Hibernate <classname>SessionFactory</classname> which it is going to use to create Hibernate <classname>Session</classname> objects. In Hibernate, every operation goes through a <classname>Session</classname> object, a <classname>Session</classname> mediates access to the underlying database and takes care of managing the connection to the JDBC <classname>DataSource</classname>. Extending <classname>HibernateDaoSupport</classname> also means that we can access the <classname>HibernateTemplate</classname> using <methodname>getHibernateTemplate()</methodname>. For an example of what can be done with the <classname>HibernateTemplate</classname>...</para> </callout> <callout arearefs="coDef-hibDao-2" id="coRef-hibDao-2"> <para>The <methodname>save() </methodname>method takes an instance of <classname>Weather</classname> and calls the <methodname>save() </methodname>method on a <classname>HibernateTemplate</classname>. The <classname>HibernateTemplate</classname> simplifies calls to common Hibernate operations and converts any database specific exceptions to runtime exceptions. Here we call out to <methodname>save() </methodname>which inserts a new record into the <classname>Weather</classname> table. Alternatives to <methodname>save() </methodname>are <methodname>update() </methodname>which updates an existing row, or <methodname>saveOrUpdate() </methodname>which would either save or update depending on the presence of a non-null <varname>id</varname> property in Weather.</para> </callout> <callout arearefs="coDef-hibDao-3" id="coRef-hibDao-3"> <para>The <methodname>load() </methodname>method, once again, is a one-liner that just calls a method on an instance of <classname>HibernateTemplate</classname>. <methodname>load() </methodname>on <classname>HibernateTemplate</classname> takes a <classname>Class</classname> object and a <classname>Serializable</classname> object. In this case, the<classname> Serializable</classname> corresponds to the <varname>id</varname> value of the <classname>Weather</classname> object to load.</para> </callout> <callout arearefs="coDef-hibDao-4" id="coRef-hibDao-4"> <para>This last method <methodname>recentForLocation() </methodname>calls out to a <classname>NamedQuery</classname> defined in the <classname>Weather</classname> model object. If you can think back that far, the <classname>Weather</classname> model object defined a named query <code>"Weather.byLocation" </code>with a query of <code>"from Weather w where w.location = :location"</code>. We're loading this <classname>NamedQuery</classname> using a reference to a Hibernate <classname>Session</classname> object inside a <classname>HibernateCallback</classname> which is executed by the <methodname>execute() </methodname>method on <classname>HibernateTemplate</classname>. You can see in this method that we're populating the named parameter location with the parameter passed in to the <methodname>recentForLocation() </methodname>method.</para> </callout> </calloutlist> <para>Now is a good time for some clarification. <classname>HibernateDaoSupport</classname> and <classname>HibernateTemplate</classname> are classes from the Spring Framework. They were created by the Spring Framework to make writing Hibernate <acronym>DAO</acronym> objects painless. To support this <acronym>DAO</acronym>, we’ll need to do some configuration in the <varname>simple-persist</varname> Spring <classname>ApplicationContext</classname> definition. The XML document shown in <xref linkend="ex-persist-spring" /> is stored in <filename>src/main/resources</filename> in a file named <filename
    role="keep-together">applicationContext-persist.xml</filename>. </para> <example id="ex-persist-spring"><title>Spring Application Context for simple-persist</title> <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
             http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"
    default-lazy-init="true"&gt;

    &lt;bean id="sessionFactory"
class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt;
        &lt;property name="annotatedClasses"&gt;
            &lt;list&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Atmosphere&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Condition&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Location&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Weather&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Wind&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="hibernateProperties"&gt;
            &lt;props&gt;
                &lt;prop key="hibernate.show_sql"&gt;false&lt;/prop&gt;
                &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt;
                &lt;prop key="hibernate.transaction.factory_class"&gt;
                  org.hibernate.transaction.JDBCTransactionFactory
                &lt;/prop&gt;
                &lt;prop key="hibernate.dialect"&gt;
                  org.hibernate.dialect.HSQLDialect
                &lt;/prop&gt;
                &lt;prop key="hibernate.connection.pool_size"&gt;0&lt;/prop&gt;
                &lt;prop key="hibernate.connection.driver_class"&gt;
                  org.hsqldb.jdbcDriver
                &lt;/prop&gt;
                &lt;prop key="hibernate.connection.url"&gt;
                  jdbc:hsqldb:data/weather;shutdown=true
                &lt;/prop&gt;
                &lt;prop key="hibernate.connection.username"&gt;sa&lt;/prop&gt;
                &lt;prop key="hibernate.connection.password"&gt;&lt;/prop&gt;
                &lt;prop key="hibernate.connection.autocommit"&gt;true&lt;/prop&gt;
                &lt;prop key="hibernate.jdbc.batch_size"&gt;0&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="locationDAO" 
             class="org.sonatype.mavenbook.weather.persist.LocationDAO"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;
    
    &lt;bean id="weatherDAO" 
             class="org.sonatype.mavenbook.weather.persist.WeatherDAO"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;
 &lt;/beans&gt;</programlisting> </example> <para>In this application context, we're accomplishing a few things. The <varname>sessionFactory</varname> bean is the bean from which the <acronym>DAO</acronym>s retrieve Hibernate <classname>Session</classname> objects. This bean is an instance of <classname>AnnotationSessionFactoryBean</classname> and is supplied with a list of <varname>annotatedClasses</varname>. Note that the list of annotated classes is the list of classes defined in our <varname>simple-model</varname> module. Next, the <varname>sessionFactory</varname> is configured with a set of Hibernate configuration properties (<varname>hibernateProperties</varname>). In this example, our Hibernate properties define a number of settings: </para> <variablelist> <varlistentry><term><literal>hibernate.dialect</literal></term> <listitem> <para>This setting controls how <acronym>SQL</acronym> is to be generated for our database. Since we are using the <acronym>HSQLDB</acronym> database, our database dialect is set to <classname>org.</classname><classname>hibernate.</classname><classname>dialect.</classname><classname>HSQLDialect</classname>. Hibernate has dialects for all major databases such as Oracle, MySQL, Postgres, and SQL Server. </para> </listitem> </varlistentry> <varlistentry><term><literal>hibernate.connection.*</literal></term> <listitem> <para>In this example, we’re configuring the <acronym>JDBC</acronym> connection properties from the Spring configuration. Our applications are configured to run against a <acronym>HSQLDB</acronym> in the <filename
          role="keep-together">./data/weather</filename> directory. In a real enterprise application, it is more likely you would use something like <acronym>JNDI</acronym> to externalize database configuration from your application’s code.</para> </listitem> </varlistentry> </variablelist> <para>Lastly, in this bean definition file, both of the <varname>simple-persist</varname> <acronym>DAO</acronym> objects are created and given a reference to the <varname>sessionFactory</varname> bean just defined. Just like the Spring application context in <varname>simple-weather</varname>, this <filename>applicationContext-persist.xml</filename> file defines the architecture of a submodule in a larger enterprise design. If you were working with a larger collection of persistence classes, you might find it useful to capture them in an application context which is separate from your application.</para> <para>There’s one last piece of the puzzle in <varname>simple-persist</varname>. Later in this chapter, we’re going to <indexterm> <primary>Maven Hibernate3 plugin</primary> </indexterm><indexterm> <primary>Hibernate3 plugin</primary> </indexterm>see how we can use the Maven Hibernate3 plugin to generate our database schema from the annotated model objects. For this to work properly, the Maven Hibernate3 plugin needs to read the <acronym>JDBC</acronym> connection configuration parameters, the list of annotated classes, and other Hibernate configuration from a file named<indexterm> <primary>hibernate.cfg.xml file</primary> </indexterm> <filename>hibernate.cfg.xml</filename> in <filename>src/main/resources</filename>. The purpose of this file (which duplicates some of the configuration in <filename>applicationContext-persist.xml</filename>) is to allow us to leverage the Maven Hibernate3 <phrase role="keep-together">plugin</phrase> to generate Data Definition Language (<acronym>DDL</acronym>) from nothing more than our annotations. See <xref linkend="ex-hibernate-cfg" />. </para> <example id="ex-hibernate-cfg"><title>simple-persist hibernate.cfg.xml</title> <programlisting language="xml">&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;
        
&lt;hibernate-configuration&gt;
  &lt;session-factory&gt;
        
    &lt;!-- SQL dialect --&gt;
    &lt;property name="dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/property&gt;
    
    &lt;!-- Database connection settings --&gt;
    &lt;property name="connection.driver_class"&gt;org.hsqldb.jdbcDriver&lt;/property&gt;
    &lt;property name="connection.url"&gt;jdbc:hsqldb:data/weather&lt;/property&gt;
    &lt;property name="connection.username"&gt;sa&lt;/property&gt;
    &lt;property name="connection.password"&gt;&lt;/property&gt;
    &lt;property name="connection.shutdown"&gt;true&lt;/property&gt;
    
    &lt;!-- JDBC connection pool (use the built-in one) --&gt;
    &lt;property name="connection.pool_size"&gt;1&lt;/property&gt;
    
    &lt;!-- Enable Hibernate's automatic session context management --&gt;
    &lt;property name="current_session_context_class"&gt;thread&lt;/property&gt;
    
    &lt;!-- Disable the second-level cache  --&gt;
    &lt;property name="cache.provider_class"&gt;
      org.hibernate.cache.NoCacheProvider
    &lt;/property&gt;
    
    &lt;!-- Echo all executed SQL to stdout --&gt;
    &lt;property name="show_sql"&gt;true&lt;/property&gt;
    
    &lt;!-- disable batching so HSQLDB will propagate errors correctly. --&gt;
    &lt;property name="jdbc.batch_size"&gt;0&lt;/property&gt;
    
    &lt;!-- List all the mapping documents we're using --&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Atmosphere"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Condition"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Location"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Weather"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Wind"/&gt;
        
  &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</programlisting> </example> <para>The contents of <xref linkend="ex-persist-spring" /> and <xref linkend="ex-multimodule-web-spring-parent" /> are redundant. While the Spring Application Context <acronym>XML</acronym> is going to be used by the web application and the command-line application, the <filename>hibernate.cfg.xml</filename> exists only to support the Maven Hibernate3 plugin. Later in this chapter, we'll see how to use this <filename>hibernate.cfg.xml</filename> and the Maven Hibernate3 plugin to generate a database schema based on the annotated object model defined in <varname>simple-model</varname>. This <filename>hibernate.cfg.xml</filename> file is the file that will configure the <acronym>JDBC</acronym> connection properties and enumerate the list of annotated model classes for the Maven Hibernate3 plugin. </para> </section> <section id="multimodule-web-spring-sect-simple-web"><title>The Simple Web Application Module</title> <para>The web application is defined in a <varname>simple-webapp</varname> <indexterm class="startofrange" id="enterprise6a"> <primary>multimodule project (example)</primary> <secondary>multimodule enterprise project</secondary> <tertiary>Simple Web Application of</tertiary> </indexterm><indexterm class="startofrange" id="enterprise6b"> <primary>Web applications</primary> <secondary>multimodule enterprise project example</secondary> <tertiary>Simple Web Application of</tertiary> </indexterm><indexterm class="startofrange" id="enterprise6c"> <primary>enterprise project, multimodule (example)</primary> <secondary>Simple Web Application of</secondary> </indexterm>project. This simple web application project is going to define two Spring <acronym>MVC</acronym> Controllers: <classname>WeatherController</classname> and <classname
    role="keep-together">HistoryController</classname>. Both of these controllers are going to reference components defined in <varname>simple-weather</varname> and <varname>simple-persist</varname>. The Spring container is configured in this application’s <filename>web.xml</filename>, which references the <filename>applicationContext-weather.xml</filename> file in <varname
    role="keep-together">simple-weather</varname> and the <filename>applicationContext-persist.xml</filename> file in <varname>simple-persist</varname>. The component architecture of this simple web application is shown in <xref linkend="fig-web-components" />. </para> <figure id="fig-web-components"><title>Spring MVC Controllers Referencing Components in simple-weather and simple-persist.</title> <mediaobject> <imageobject role="web"> <imagedata fileref="figs/web/multimodule-web-web-spring.png"
                     scalefit="1" width="" /> </imageobject> <imageobject role="print"> <imagedata fileref="figs/print/multimodule-web-web-spring.pdf"
                     format="PDF" /> </imageobject> </mediaobject> </figure> <para>The POM for <varname>simple-webapp</varname> is shown in <xref linkend="example_pom-for-simple-webapp" />. </para> <example id="example_pom-for-simple-webapp"><title>POM for simple-webapp</title> <programlisting>&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;

  &lt;artifactId&gt;simple-webapp&lt;/artifactId&gt;
  &lt;packaging&gt;war&lt;/packaging&gt;
  &lt;name&gt;Simple Web Application&lt;/name&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;  <co id="co-springweb-1" linkends="coref-springweb-1" />&lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt; &lt;artifactId&gt;simple-weather&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt; &lt;artifactId&gt;simple-persist&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;version&gt;2.0.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity&lt;/artifactId&gt; &lt;version&gt;1.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;simple-webapp&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt;  <co id="coDef-spring-web-2" linkends="coRef-spring-web-2" />&lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt; &lt;dependencies&gt; <co id="coDef-spring-web-3"
          linkends="coRef-spring-web-3" />&lt;dependency&gt; &lt;groupId&gt;hsqldb&lt;/groupId&gt; &lt;artifactId&gt;hsqldb&lt;/artifactId&gt; &lt;version&gt;1.8.0.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;  <co
          id="coDef-spring-web-4" linkends="coRef-spring-web-4" />&lt;artifactId&gt;hibernate3-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;configuration&gt; &lt;components&gt; &lt;component&gt; &lt;name&gt;hbm2ddl&lt;/name&gt; &lt;implementation&gt;annotationconfiguration&lt;/implementation&gt;  <co
          id="coDef-spring-web-5" linkends="coRef-spring-web-5" />&lt;/component&gt; &lt;/components&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;hsqldb&lt;/groupId&gt; &lt;artifactId&gt;hsqldb&lt;/artifactId&gt; &lt;version&gt;1.8.0.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;
&lt;/project&gt;
</programlisting> </example> <para>As this book progresses and the examples become more and more substantial, you’ll notice that the <filename>pom.xml</filename> begins to take on some weight. In this POM, we’re configuring four dependencies and two plugins. Let’s go through this POM in detail and dwell on some of the important configuration points:</para> <calloutlist> <callout arearefs="co-springweb-1" id="coref-springweb-1"> <para>This <varname>simple-webapp</varname> project defines four dependencies: the Servlet 2.4 specification, the simple-weather service library, the simple-persist persistence library, and the entire Spring Framework 2.0.7.</para> </callout> <callout arearefs="coDef-spring-web-2" id="coRef-spring-web-2"> <para>The Maven Jetty plugin couldn’t be easier to add to this <indexterm> <primary>Maven Jetty plugin</primary> </indexterm><indexterm> <primary>Jetty plugin</primary> </indexterm>project; we simply add a <literal>plugin</literal> element that references the appropriate <literal>groupId</literal> and <literal>artifactId</literal>. The fact that this plugin is so trivial to configure means that the plugin developers did a good job of providing adequate defaults that don’t need to be overridden in most cases. If you did need to override the configuration of the Jetty plugin, you would do so by providing a <literal>configuration</literal> element.</para> </callout> <callout arearefs="coDef-spring-web-3" id="coRef-spring-web-3"> <para>In our build configuration, we're going to be configuring the Maven Hibernate3 Plugin to hit an embedded HSQLDB instance. For the Maven Hibernate 3 plugin to successfully connect to this database using JDBC, the plugin will need reference the HSQLDB JDBC driver on the classpath. To make a dependency available for a plugin, we add a <sgmltag>dependency</sgmltag> declaration right inside <sgmltag>plugin</sgmltag> declaration. In this case, we're referencing hsqldb:hsqldb:1.8.0.7. The Hibernate plugin also needs the JDBC driver to create the database, so we have also added this dependency to its configuration.</para> </callout> <callout arearefs="coDef-spring-web-4" id="coRef-spring-web-4"> <para>The Maven Hibernate plugin is when this POM starts to get <indexterm> <primary>Maven Hibernate plugin</primary> </indexterm><indexterm> <primary>Hibernate plugin</primary> </indexterm>interesting. In the next section, we’re going to run the <literal>hbm2ddl</literal> goal to generate a HSQLDB database. In this <filename>pom.xml</filename>, we’re including a reference to version 2.0 of the <literal>hibernate3-maven-plugin</literal> hosted by the Codehaus Mojo plugin.</para> </callout> <callout arearefs="coDef-spring-web-5" id="coRef-spring-web-5"> <para>The Maven Hibernate3 plugin has different ways to obtain Hibernate mapping information that are appropriate for different usage scenarios of the Hibernate3 plugin. If you were using Hibernate Mapping XML (<filename>.hbm.xml</filename>) files, and you wanted to generate model classes using the <literal>hbm2java</literal> goal, you would set your implementation to configuration. If you were using the Hibernate3 plugin to reverse engineer a database to produce <filename>.hbm.xml</filename> files and model classes from an existing database, you would use an implementation of <literal>jdbcconfiguration</literal>. In this case, we’re simply using an existing annotated object model to generate a database. In other words, we have our Hibernate mapping, but we don’t yet have a database. In this usage scenario, the appropriate implementation value is <literal>annotationconfiguration</literal>. The Maven Hibernate3 plugin is discussed in more detail in the later section <xref linkend="multimodule-web-spring-sect-spring-running-web" />.</para> </callout> </calloutlist> <note> <para>A common mistake is to use the <sgmltag>extensions</sgmltag> configuration to add dependencies required by a plugin. This is strongly discouraged as the extensions can cause classpath pollution across your project, among other nasty side-effects. Additionally, the extensions behavior is being reworked in 2.1 and you'll eventually need to change it anway. The only normal use for <sgmltag>extensions</sgmltag> is to define new wagon implementations</para> </note> <para>Next, we turn our attention to the two Spring MVC controllers that will handle all of the requests. Both of these controllers reference the beans defined in <varname>simple-weather</varname> and <varname>simple-persist</varname>. </para> <example><title>simple-webapp WeatherController</title> <programlisting language="java">package org.sonatype.mavenbook.web;

import org.sonatype.mavenbook.weather.model.Weather;
import org.sonatype.mavenbook.weather.persist.WeatherDAO;
import org.sonatype.mavenbook.weather.WeatherService;
import javax.servlet.http.*;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

public class WeatherController implements Controller {

  private WeatherService weatherService;
  private WeatherDAO weatherDAO;

  public ModelAndView handleRequest(HttpServletRequest request,
      HttpServletResponse response) throws Exception {

    String zip = request.getParameter("zip");
    Weather weather = weatherService.retrieveForecast(zip);
    weatherDAO.save(weather);
    return new ModelAndView("weather", "weather", weather);
  }

  public WeatherService getWeatherService() {
    return weatherService;
  }

  public void setWeatherService(WeatherService weatherService) {
    this.weatherService = weatherService;
  }

  public WeatherDAO getWeatherDAO() {
    return weatherDAO;
  }

  public void setWeatherDAO(WeatherDAO weatherDAO) {
    this.weatherDAO = weatherDAO;
  }
}</programlisting> </example> <para><varname>WeatherController</varname> implements the Spring MVC Controller interface that mandates the presence of a <methodname>handleRequest() </methodname>method with the signature shown in the example. If you look at the meat of this method, you’ll see that it invokes the <methodname>retrieveForecast() </methodname>method on the <varname>weatherService</varname> instance variable. Unlike the previous chapter, which had a Servlet that instantiated the <classname>WeatherService</classname> class, the <classname>WeatherController</classname> is a bean with a <varname>weatherService</varname> property. The Spring IoC container is responsible for wiring the controller to the <varname>weatherService</varname> component. Also notice that we’re not using the <classname role="keep-together">WeatherFormatter</classname> in this Spring controller implementation; instead, we’re passing the <classname>Weather</classname> object returned by <methodname>retrieveForecast() </methodname>to the constructor of <classname>ModelAndView</classname>. This <classname>ModelAndView</classname> class is going to be used to render a <indexterm> <primary>Velocity template</primary> </indexterm>Velocity template, and this template will have references to a <varname>\${weather}</varname> variable. The <filename>weather.vm</filename> template is stored in <filename>src/main/webapp/WEB-INF/vm</filename> and is shown in <xref linkend="ex-weather-vm" />.</para> <para>In the <classname>WeatherController</classname>, before we render the output of the forecast, we pass the <classname>Weather</classname> object returned by the <classname>WeatherService</classname> to the <methodname>save() </methodname>method on <classname>WeatherDAO</classname>. Here we are saving this <classname>Weather</classname> object—using Hibernate—to an HSQLDB database. Later, in <classname>HistoryController</classname>, we will see how we can retrieve a history of weather forecasts that were saved by the <classname>WeatherController</classname>. </para> <example id="ex-weather-vm"><title>weather.vm template rendered by WeatherController</title> <programlisting language="xml">&lt;b&gt;Current Weather Conditions for:
  \${weather.location.city}, \${weather.location.region}, 
  \${weather.location.country}&lt;/b&gt;&lt;br/&gt;
  
&lt;ul&gt;
  &lt;li&gt;Temperature: \${weather.condition.temp}&lt;/li&gt;
  &lt;li&gt;Condition: \${weather.condition.text}&lt;/li&gt;
  &lt;li&gt;Humidity: \${weather.atmosphere.humidity}&lt;/li&gt;
  &lt;li&gt;Wind Chill: \${weather.wind.chill}&lt;/li&gt;
  &lt;li&gt;Date: \${weather.date}&lt;/li&gt;
&lt;/ul&gt;
</programlisting> </example> <para>The syntax for this Velocity template is straightforward, variables are referenced using <code>\${} </code>notation. The expression between the curly braces references a property, or a property of a property on the <varname>weather</varname> variable which was passed to this template by the <classname>WeatherController</classname>.</para> <para>The <classname>HistoryController</classname> is used to retrieve recent forecasts that have been requested by the <classname>WeatherController</classname>. Whenever we retrieve a forecast from the <classname>WeatherController</classname>, that controller saves the <classname>Weather</classname> object to the database via the <classname>WeatherDAO</classname>. <classname>WeatherDAO</classname> then uses Hibernate to dissect the <classname>Weather</classname> object into a series of rows in a set of related database tables. The <classname>HistoryController</classname> is shown in <xref linkend="ex-spring-history" />. </para> <example id="ex-spring-history"><title>simple-web HistoryController</title> <programlisting language="java">package org.sonatype.mavenbook.web;

import java.util.*;
import javax.servlet.http.*;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;
import org.sonatype.mavenbook.weather.model.*;
import org.sonatype.mavenbook.weather.persist.*;

public class HistoryController implements Controller {

  private LocationDAO locationDAO;
  private WeatherDAO weatherDAO;

  public ModelAndView handleRequest(HttpServletRequest request,
      HttpServletResponse response) throws Exception {
    String zip = request.getParameter("zip");
    Location location = locationDAO.findByZip(zip);
    List&lt;Weather&gt; weathers = weatherDAO.recentForLocation( location );

    Map&lt;String,Object&gt; model = new HashMap&lt;String,Object&gt;();
    model.put( "location", location );
    model.put( "weathers", weathers );

    return new ModelAndView("history", model);
  }

  public WeatherDAO getWeatherDAO() {
    return weatherDAO;
  }

  public void setWeatherDAO(WeatherDAO weatherDAO) {
    this.weatherDAO = weatherDAO;
  }

  public LocationDAO getLocationDAO() {
    return locationDAO;
  }

  public void setLocationDAO(LocationDAO locationDAO) {
    this.locationDAO = locationDAO;
  }
}</programlisting> </example> <para>The <classname>HistoryController</classname> is wired to two <acronym>DAO</acronym> objects defined in <varname>simple-persist</varname>. The <acronym>DAO</acronym>s are bean properties of the <classname>HistoryController</classname>: <classname>WeatherDAO</classname> and <classname>LocationDAO</classname>. The goal of the <classname>HistoryController</classname> is to retrieve a <classname>List</classname> of <classname>Weather</classname> objects which correspond to the <varname>zip</varname> parameter. When the <classname>WeatherDAO</classname> saves the <classname>Weather</classname> object to the database, it doesn't just store the zip code, it stores a <classname>Location</classname> object which is related to the <classname>Weather</classname> object in the <varname>simple-model</varname>. To retrieve a <classname>List</classname> of <classname>Weather</classname> objects, the <classname>HistoryController</classname> first retrieves the <classname>Location</classname> object that corresponds to the <varname>zip</varname> parameter. It does this by invoking the <methodname>findByZip() </methodname>method on <classname>LocationDAO</classname>.</para> <para>Once the <classname>Location</classname> object has been retrieved, the <classname>HistoryController</classname> will then attempt to retrieve recent <classname>Weather</classname> objects that match the given <classname>Location</classname>. Once the <classname>List&lt;Weather&gt;</classname> has been retrieved, a <classname>HashMap</classname> is created to hold two variables for the <filename>history.vm</filename> Velocity template shown in <xref linkend="ex-spring-history-velocity" />. </para> <example id="ex-spring-history-velocity"><title>history.vm rendered by the HistoryController</title> <programlisting language="java">&lt;b&gt;
Weather History for: \${location.city}, \${location.region}, \${location.country}
&lt;/b&gt;
&lt;br/&gt;
  
#foreach( $weather in $weathers )
  &lt;ul&gt;
    &lt;li&gt;Temperature: $weather.condition.temp&lt;/li&gt;
    &lt;li&gt;Condition: $weather.condition.text&lt;/li&gt;
    &lt;li&gt;Humidity: $weather.atmosphere.humidity&lt;/li&gt;
    &lt;li&gt;Wind Chill: $weather.wind.chill&lt;/li&gt;
    &lt;li&gt;Date: $weather.date&lt;/li&gt;
  &lt;/ul&gt;
#end
</programlisting> </example> <para>The <filename>history.vm</filename> template in <filename>src/main/webapp/WEB-INF/vm</filename> references the <varname>location</varname> variable to print out information about the location of the forecasts retrieved from the <classname>WeatherDAO</classname>. This template then uses a Velocity control structure, <code>#foreach</code>, to loop through each element in the <varname>weathers</varname> variable. Each element in <varname>weathers</varname> is assigned to a variable named <varname>weather</varname> and the template between <code>#foreach </code>and <code>#end </code>is rendered for each forecast.</para> <para>You've seen these <classname>Controller</classname> implementations, and you've seen that they reference other beans defined in <varname>simple-weather</varname> and <varname>simple-persist</varname>, they respond to <acronym>HTTP</acronym> requests, and they yield control to some mysterious templating system that knows how to render Velocity templates. All of this magic is configured in a Spring application context in <filename>src/main/webapp/WEB-INF/weather-servlet.xml</filename>. This <acronym>XML</acronym> configures the controllers and references other Spring-managed beans, it is loaded by a <classname>ServletContextListener</classname> which is also configured to load the <filename>applicationContext-weather.xml</filename> and <filename>applicationContext-persist.xml</filename> from the classpath. Let's take a closer look at the <filename>weather-servlet.xml</filename> shown in <xref linkend="ex-spring-weather-servlet" />. </para> <example id="ex-spring-weather-servlet"><title>Spring Controller configuration weather-servlet.xml</title> <programlisting>&lt;beans&gt;  
     &lt;bean id="weatherController"  <co id="coDef-weather-servlet-1"
          linkends="coRef-weather-servlet-1" />class="org.sonatype.mavenbook.web.WeatherController"&gt; &lt;property name="weatherService" ref="weatherService"/&gt; &lt;property name="weatherDAO" ref="weatherDAO"/&gt; &lt;/bean&gt; &lt;bean id="historyController" class="org.sonatype.mavenbook.web.HistoryController"&gt; &lt;property name="weatherDAO" ref="weatherDAO"/&gt; &lt;property name="locationDAO" ref="locationDAO"/&gt; &lt;/bean&gt; &lt;!-- you can have more than one handler defined --&gt; &lt;bean id="urlMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="urlMap"&gt; &lt;map&gt; &lt;entry key="/weather.x"&gt;  <co
          id="coDef-weather-servlet-2" linkends="coRef-weather-servlet-2" />&lt;ref bean="weatherController" /&gt; &lt;/entry&gt; &lt;entry key="/history.x"&gt; &lt;ref bean="historyController" /&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="velocityConfig"  <co id="coDef-weather-servlet-3"
          linkends="coRef-weather-servlet-3" />class="org.springframework.web.servlet.view.velocity.VelocityConfigurer"&gt; &lt;property name="resourceLoaderPath" value="/WEB-INF/vm/"/&gt; &lt;/bean&gt; &lt;bean id="viewResolver"  <co id="coDef-weather-servlet-4"
          linkends="coRef-weather-servlet-4" />class="org.springframework.web.servlet.view.velocity.VelocityViewResolver"&gt; &lt;property name="cache" value="true"/&gt; &lt;property name="prefix" value=""/&gt; &lt;property name="suffix" value=".vm"/&gt; &lt;property name="exposeSpringMacroHelpers" value="true"/&gt; &lt;/bean&gt;
&lt;/beans&gt;
</programlisting> </example> <calloutlist> <callout arearefs="coDef-weather-servlet-1" id="coRef-weather-servlet-1"> <para>The <filename>weather-servlet.xml</filename> defines the two controllers as Spring-managed beans. <varname>weatherController</varname> has two properties which are references to <varname>weatherService</varname> and <varname>weatherDAO</varname>. <varname>historyController</varname> references the beans <varname>weatherDAO</varname> and <varname>locationDAO</varname>. When this <classname>ApplicationContext</classname> is created, it is created in an environment that has access to the <classname>ApplicationContext</classname>s defined in both <varname>simple-persist</varname> and <varname>simple-weather</varname>. In <xref linkend="ex-spring-webxml" /> you will see how Spring is configured to merge components from multiple Spring configuration files.</para> </callout> <callout arearefs="coDef-weather-servlet-2" id="coRef-weather-servlet-2"> <para>The <varname>urlMapping</varname> bean defines the <acronym>URL</acronym> patterns which invoke the <classname>WeatherController</classname> and the <classname>HistoryController</classname>. In this example, we are using the <classname>SimpleUrlHandlerMapping</classname> and mapping <filename>/weather.x</filename> to <classname>WeatherController</classname> and <filename>/history.x</filename> to <classname>HistoryController</classname>.</para> </callout> <callout arearefs="coDef-weather-servlet-3" id="coRef-weather-servlet-3"> <para>Since we are using the Velocity templating engine, we will need to pass in some configuration options. In the <varname>velocityConfig</varname> bean, we are telling Velocity to look for all templates in the <filename>/WEB-INF/vm</filename> directory.</para> </callout> <callout arearefs="coDef-weather-servlet-4" id="coRef-weather-servlet-4"> <para>Last, the <varname>viewResolver</varname> is configured with the class <classname>VelocityViewResolver</classname>. There are a number of <classname>ViewResolver</classname> implementations in Spring from a standard ViewResolver to render <acronym>JSP</acronym> or <acronym>JSTL</acronym> pages to a resolver which can render Freemarker templates. In this example, we're configuring the Velocity templating engine and setting the default prefix and suffix which will be automatically appended to the names of the template passed to <classname>ModelAndView</classname>.</para> </callout> </calloutlist> <para>Finally, the <varname>simple-webapp</varname> project was a <filename>web.xml</filename> which provides the basic configuration for the web application. The <filename>web.xml</filename> file is shown in <xref linkend="ex-spring-webxml" />. </para> <example id="ex-spring-web-xml"><title>web.xml for simple-webapp</title> <programlisting id="ex-spring-webxml">&lt;web-app id="simple-webapp" version="2.4" 
     xmlns="http://java.sun.com/xml/ns/j2ee" 
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
     xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee 
                         http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;
  &lt;display-name&gt;Simple Web Application&lt;/display-name&gt;
  
  &lt;context-param&gt;  <co id="coDef-spring-webx-1"
          linkends="coRef-spring-webx-1" />&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext-weather.xml classpath:applicationContext-persist.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt;  <co id="coDef-spring-webx-2"
          linkends="coRef-spring-webx-2" />&lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt;  <co id="coDef-spring-webx-3" linkends="coRef-spring-webx-3" />&lt;listener-class&gt; org.springframework.web.util.Log4jConfigListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;listener&gt; &lt;listener-class&gt;  <co id="coDef-spring-webx-4"
          linkends="coRef-spring-webx-4" />org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt;  <co id="coDef-spring-webx-5" linkends="coRef-spring-webx-5" />&lt;servlet-name&gt;weather&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt;  <co id="coDef-spring-webx-6"
          linkends="coRef-spring-webx-6" />&lt;servlet-name&gt;weather&lt;/servlet-name&gt; &lt;url-pattern&gt;*.x&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</programlisting> </example> <calloutlist> <callout arearefs="coDef-spring-webx-1" id="coRef-spring-webx-1"> <para>Here's a bit of magic which allows us to reuse the <filename>applicationContext-weather.xml</filename> and <filename>applicationContext-persist.xml</filename> in this project. The <varname>contextConfigLocation</varname> is used by the <classname>ContextLoaderListener</classname> to create an <classname>ApplicationContext</classname>. When the weather servlet is created, the <filename>weather-servlet.xml</filename> from <xref linkend="ex-spring-weather-servlet" /> is going to be evaluated with the <classname>ApplicationContext</classname> created from this <varname>contextConfigLocation</varname>. In this way, you can define a set of beans in another project and you can reference these beans via the classpath. Since the <varname>simple-persist</varname> and <varname>simple-weather</varname> <acronym>JAR</acronym>s are going to be in <filename>WEB-INF/lib</filename>, all we do is use the <literal>classpath:</literal> prefix to reference these files. (Another option would have been to copy these files to <filename>/WEB-INF</filename> and reference them with something like <filename>/WEB-INF/applicationContext-persist.xml</filename>).</para> </callout> <callout arearefs="coDef-spring-webx-2" id="coRef-spring-webx-2"> <para>The <varname>log4jConfigLocation</varname> is used to tell the <classname>Log4JConfigListener</classname> where to look for Log4J logging configuration. In this example, we tell Log4J to look in <filename>/WEB-INF/log4j.properties</filename>.</para> </callout> <callout arearefs="coDef-spring-webx-3" id="coRef-spring-webx-3"> <para>This makes sure that the Log4J system is configured when the web application starts. It is important to put this <classname>Log4JConfigListener</classname> before the<classname> ContextLoaderListener</classname>; otherwise, you may miss important logging messages which point to a problem preventing application startup. If you have a particularly large set of beans managed by Spring, and one of them happens to blow up on application startup, your application will fail. If you have logging initialized before Spring starts, you might have a chance to catch a warning or an error. If you don't have logging initialized before Spring starts up, you'll have no idea why your application refuses to start.</para> </callout> <callout arearefs="coDef-spring-webx-4" id="coRef-spring-webx-4"> <para>The <classname>ContextLoaderListener</classname> is essentially the Spring container. When the application starts, this listener will build an <classname>ApplicationContext</classname> from the <varname>contextConfigLocation</varname> parameter.</para> </callout> <callout arearefs="coDef-spring-webx-5" id="coRef-spring-webx-5"> <para>We define a Spring <acronym>MVC</acronym> <classname>DispatcherServlet</classname> with a name of <varname>weather</varname>. This will cause Spring to look for a Spring configuration file in <filename>/WEB-INF/weather-servlet.xml</filename>. You can have as many <classname>DispatcherServlet</classname>s as you need, a <classname>DispatcherServlet</classname> can contain one or more Spring <acronym>MVC</acronym> <classname>Controller</classname> implementations.</para> </callout> <callout arearefs="coDef-spring-webx-6" id="coRef-spring-webx-6"> <para>All requests ending in <filename>.x</filename> will be routed to the <varname>weather</varname> servlet. Note that the <filename>.x</filename> extension has no particular meaning, it is an arbitrary choice and you can use whatever <acronym>URL</acronym> pattern you like. </para> </callout> </calloutlist> </section> <section id="multimodule-web-spring-sect-spring-running-web"><title>Running the Web Application</title> <para>To run the web application, you’ll first need to build the database <indexterm class="startofrange" id="enterprise7a"> <primary>multimodule project (example)</primary> <secondary>multimodule enterprise project</secondary> <tertiary>running Web application</tertiary> </indexterm><indexterm class="startofrange" id="enterprise7b"> <primary>Web applications</primary> <secondary>multimodule enterprise project example</secondary> <tertiary>running Web application</tertiary> </indexterm><indexterm class="startofrange" id="enterprise7c"> <primary>enterprise project, multimodule (example)</primary> <secondary>running Web application</secondary> </indexterm><indexterm> <primary>Maven Hibernate3 plugin</primary> <secondary>building database using</secondary> </indexterm><indexterm> <primary>Hibernate3 plugin</primary> <secondary>building database using</secondary> </indexterm>using the Hibernate3 plugin. To do this, run the following from the <varname>simple-webapp</varname> project directory: </para><screen>$ <command>mvn hibernate3:hbm2ddl</command>
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'hibernate3'.
[INFO] org.codehaus.mojo: checking for updates from central
[INFO] ------------------------------------------------------------------------
[INFO] Building Chapter 7 Simple Web Application
[INFO]    task-segment: [hibernate3:hbm2ddl]
[INFO] ------------------------------------------------------------------------
[INFO] Preparing hibernate3:hbm2ddl
...
10:24:56,151  INFO org.hibernate.tool.hbm2ddl.SchemaExport - export complete
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
</screen> <para>Once you've done this, there should be a <filename>\${basedir}/data</filename> directory which will contain the HSQLDB database. You can then start the web application with: </para><screen>$ <command>mvn jetty:run</command>
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'jetty'.
[INFO] ------------------------------------------------------------------------
[INFO] Building Chapter 7 Simple Web Application
[INFO]    task-segment: [jetty:run]
[INFO] ------------------------------------------------------------------------
[INFO] Preparing jetty:run
...
[INFO] [jetty:run]
[INFO] Configuring Jetty for project: Chapter 7 Simple Web Application
...
[INFO] Context path = /simple-webapp
[INFO] Tmp directory =  determined at runtime
[INFO] Web defaults = org/mortbay/jetty/webapp/webdefault.xml
[INFO] Web overrides =  none
[INFO] Starting jetty 6.1.7 ...
2008-03-25 10:28:03.639::INFO:  jetty-6.1.7
...
2147 INFO  DispatcherServlet  - FrameworkServlet 'weather': \
           initialization completed in 1654 ms
2008-03-25 10:28:06.341::INFO:  Started SelectChannelConnector@0.0.0.0:8080
[INFO] Started Jetty Server
</screen> <para>Once Jetty is started, you can load <ulink
    url="http://localhost:8080/simple-webapp/weather.x?zip=60202">http://localhost:8080/simple-webapp/weather.x?zip=60202</ulink> and you should see the weather for Evanston, IL in your web browser. Change the ZIP code and you should be able to get your own weather report. </para><screen>Current Weather Conditions for: Evanston, IL, US

    * Temperature: 42
    * Condition: Partly Cloudy
    * Humidity: 55
    * Wind Chill: 34
    * Date: Tue Mar 25 10:29:45 CDT 2008
</screen>  </section> <section id="multimodule-web-spring-sect-simple-command"><title>The Simple Command Module</title> <para>The <varname>simple-command</varname> project is a command-line version of the <varname>simple-webapp</varname>. It is a utility that relies on the same dependencies: <varname>simple-persist</varname> and <varname>simple-weather</varname>. Instead of interacting with this application via a web browser, you would run the <classname>simple-command</classname> utility from the command-line. </para> <figure id="fig-multi-spring-command"><title>Command line application referencing simple-weather and simple-persist</title>  <mediaobject> <imageobject role="web"> <imagedata fileref="figs/web/multimodule-web-command-spring.png"
                     scalefit="1" width="" /> </imageobject> <imageobject role="print"> <imagedata fileref="figs/print/multimodule-web-command-spring.pdf"
                     format="PDF" /> </imageobject> </mediaobject> </figure> <example><title>POM for simple-command</title> <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;

  &lt;artifactId&gt;simple-command&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;name&gt;Simple Command Line Tool&lt;/name&gt;

  &lt;build&gt;
    &lt;finalName&gt;\${project.artifactId}&lt;/finalName&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;source&gt;1.5&lt;/source&gt;
          &lt;target&gt;1.5&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
       &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;descriptorRefs&gt;
            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
          &lt;/descriptorRefs&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate3-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.1&lt;/version&gt;
        &lt;configuration&gt;
          &lt;components&gt;
            &lt;component&gt;
              &lt;name&gt;hbm2ddl&lt;/name&gt;
              &lt;implementation&gt;annotationconfiguration&lt;/implementation&gt;
            &lt;/component&gt;
          &lt;/components&gt;
        &lt;/configuration&gt;
        &lt;dependencies&gt;
          &lt;dependency&gt;
            &lt;groupId&gt;hsqldb&lt;/groupId&gt;
            &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
            &lt;version&gt;1.8.0.7&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;           
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-weather&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.ch07&lt;/groupId&gt;
      &lt;artifactId&gt;simple-persist&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring&lt;/artifactId&gt;
      &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;hsqldb&lt;/groupId&gt;
      &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
      &lt;version&gt;1.8.0.7&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting> </example> <para>This <acronym>POM</acronym> creates an <acronym>JAR</acronym> file which will contain the <classname>org.sonatype.mavenbook.</classname><classname>weather.</classname><classname>Main</classname> class shown in <xref linkend="ex-spring-command-main-class" />. In this <acronym>POM</acronym> we configure the Maven Assembly plugin to use a built-in assembly descriptor named <varname>jar-with-dependencies</varname> which creates a single <acronym>JAR</acronym> file containing all the bytecode a project needs to execute including the bytecode from the project you are building and all the dependency bytecode. </para> <example id="ex-spring-command-main-class"><title>The Main class for simple-command</title> <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.util.List;

import org.apache.log4j.PropertyConfigurator;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import org.sonatype.mavenbook.weather.model.Location;
import org.sonatype.mavenbook.weather.model.Weather;
import org.sonatype.mavenbook.weather.persist.LocationDAO;
import org.sonatype.mavenbook.weather.persist.WeatherDAO;

public class Main {

  private WeatherService weatherService;
  private WeatherDAO weatherDAO;
  private LocationDAO locationDAO;

  public static void main(String[] args) throws Exception {
    // Configure Log4J
    PropertyConfigurator.configure(Main.class.getClassLoader().getResource(
        "log4j.properties"));

    // Read the Zip Code from the Command-line (if none supplied, use 60202)
    String zipcode = "60202";
    try {
      zipcode = args[0];
    } catch (Exception e) {
    }

    // Read the Operation from the Command-line (if none supplied use weather)
    String operation = "weather";
    try {
      operation = args[1];
    } catch (Exception e) {
    }

    // Start the program
    Main main = new Main(zipcode);

    ApplicationContext context = 
      new ClassPathXmlApplicationContext(
        new String[] { "classpath:applicationContext-weather.xml",
                       "classpath:applicationContext-persist.xml" });
    main.weatherService = (WeatherService) context.getBean("weatherService");
    main.locationDAO = (LocationDAO) context.getBean("locationDAO");
    main.weatherDAO = (WeatherDAO) context.getBean("weatherDAO");
    if( operation.equals("weather")) {
      main.getWeather();
    } else {
      main.getHistory();
    }
  }

  private String zip;

  public Main(String zip) {
    this.zip = zip;
  }

  public void getWeather() throws Exception {
    Weather weather = weatherService.retrieveForecast(zip);
    weatherDAO.save( weather );
    System.out.print(new WeatherFormatter().formatWeather(weather));
  }

  public void getHistory() throws Exception {
    Location location = locationDAO.findByZip(zip);
    List&lt;Weather&gt; weathers = weatherDAO.recentForLocation(location);
    System.out.print(new WeatherFormatter().formatHistory(location, weathers));
  }
}
</programlisting> </example> <para>The <classname>Main</classname> class has a reference to <classname>WeatherDAO</classname>, <classname>LocationDAO</classname>, and <classname>WeatherService</classname>. The static <methodname>main() </methodname>method in this class:</para> <itemizedlist> <listitem> <para>Reads the Zip Code from the first command line argument</para> </listitem> <listitem> <para>Reads the Operation from the second command line argument. If the operation is "weather", the latest weather will be retrieved from the web service. If the operation is "history", the program will fetch historical weather records from the local database.</para> </listitem> <listitem> <para>Loads a Spring <classname>ApplicationContext</classname> using two <acronym>XML</acronym> files loaded from <varname>simple-persist</varname> and <varname>simple-weather</varname></para> </listitem> <listitem> <para>Creates an instance of <classname>Main</classname></para> </listitem> <listitem> <para>Populates the <varname>weatherService</varname>, <varname>weatherDAO</varname>, and <varname>locationDAO</varname> with beans from the Spring <classname>ApplicationContext</classname></para> </listitem> <listitem> <para>Runs the appropriate method <methodname>getWeather() </methodname>or <methodname>getHistory() </methodname>depending on the specified operation.</para> </listitem> </itemizedlist> <para>In the web application we use Spring <classname>VelocityViewResolver</classname> to render a Velocity template. In the stand-alone implementation, we need to write a simple class which renders our weather data with a Velocity template. <xref linkend="ex-spring-weather-formatter" /> is a listing of the <classname>WeatherFormatter</classname>, a class with two methods that render the weather report and the weather history. </para> <example id="ex-spring-weather-formatter"><title>WeatherFormatter renders weather data using a Velocity template</title> <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringWriter;
import java.util.List;

import org.apache.log4j.Logger;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.Velocity;

import org.sonatype.mavenbook.weather.model.Location;
import org.sonatype.mavenbook.weather.model.Weather;

public class WeatherFormatter {

  private static Logger log = Logger.getLogger(WeatherFormatter.class);

  public String formatWeather( Weather weather ) throws Exception {
    log.info( "Formatting Weather Data" );
    Reader reader = 
      new InputStreamReader( getClass().getClassLoader().
                                 getResourceAsStream("weather.vm"));
    VelocityContext context = new VelocityContext();
    context.put("weather", weather );
    StringWriter writer = new StringWriter();
    Velocity.evaluate(context, writer, "", reader);
    return writer.toString();
  }

  public String formatHistory( Location location, List&lt;Weather&gt; weathers )  
        throws Exception {
    log.info( "Formatting History Data" );
    Reader reader = 
      new InputStreamReader( getClass().getClassLoader().
                                 getResourceAsStream("history.vm"));
    VelocityContext context = new VelocityContext();
    context.put("location", location );
    context.put("weathers", weathers );
    StringWriter writer = new StringWriter();
    Velocity.evaluate(context, writer, "", reader);
    return writer.toString();
  }
}
</programlisting> </example> <para>The <filename>weather.vm</filename> template simply prints the zip code's city, country, and region as well as the current temperature. The <filename>history.vm</filename> template prints the location and then iterates through the weather forecast records stored in the local database. Both of these templates are in <filename>\${basedir}/src/main/resources</filename>. </para> <example><title>The weather.vm Velocity template</title> <programlisting language="java">****************************************
Current Weather Conditions for:
  \${weather.location.city},
  \${weather.location.region},
  \${weather.location.country}
****************************************

 * Temperature: \${weather.condition.temp}
 * Condition: \${weather.condition.text}
 * Humidity: \${weather.atmosphere.humidity}
 * Wind Chill: \${weather.wind.chill}
 * Date: \${weather.date}
</programlisting>  </example> <example><title>The history.vm Velocity template</title> <para><programlisting>Weather History for:
\${location.city},
\${location.region},
\${location.country}


#foreach( $weather in $weathers )
****************************************
 * Temperature: $weather.condition.temp
 * Condition: $weather.condition.text
 * Humidity: $weather.atmosphere.humidity
 * Wind Chill: $weather.wind.chill
 * Date: $weather.date
#end</programlisting> </para> </example> </section> <section id="multimodule-web-spring-sect-running-simple-command"><title>Running the Simple Command</title> <para>The <varname>simple-command</varname> project is configured to create a single <acronym>JAR</acronym> containing the bytecode of the project and all of the bytecode from the dependencies. To create this assembly, run the <varname>assembly</varname> goal of the Maven Assembly plugin from the <varname>simple-command</varname> project directory: </para><screen>$ <command>mvn assembly:assembly</command>
[INFO] ------------------------------------------------------------------------
[INFO] Building Chapter 7 Simple Command Line Tool
[INFO]    task-segment: [assembly:assembly] (aggregator-style)
[INFO] ------------------------------------------------------------------------
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Nothing to compile - all classes are up to date
[INFO] [resources:testResources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:testCompile]
[INFO] Nothing to compile - all classes are up to date
[INFO] [surefire:test]
...
[INFO] [jar:jar]
[INFO] Building jar: .../simple-parent/simple-command/target/simple-command.jar
[INFO] [assembly:assembly]
[INFO] Processing DependencySet (output=)
[INFO] Building jar: .../simple-parent/simple-command/target
                                      /simple-command-jar-with-dependencies.jar
</screen> <para>The build progresses through the lifecycle compiling bytecode, running tests, and finally building a <acronym>JAR</acronym> for the project. Then the <varname>assembly:</varname><varname>assembly</varname> goal creates a <acronym>JAR</acronym> with dependencies by unpacking all of the dependencies to temporary directories and then collecting all of the bytecode into a single <acronym>JAR</acronym> in <filename>target/</filename> named <filename>simple-command-jar-with-dependencies.jar</filename>. This "uber" <acronym>JAR</acronym> weighs in at 15 MB.</para> <para>Before you run the command-line tool, you will need to invoke the <varname>hbm2ddl</varname> goal of the Hibernate3 plugin to create the HSQLDB database. Do this by running the following command from the <varname>simple-command</varname> directory:</para> <para><screen>$ <command>mvn hibernate3:hbm2ddl</command>
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'hibernate3'.
[INFO] org.codehaus.mojo: checking for updates from central
[INFO] ------------------------------------------------------------------------
[INFO] Building Chapter 7 Simple Command Line Tool
[INFO]    task-segment: [hibernate3:hbm2ddl]
[INFO] ------------------------------------------------------------------------
[INFO] Preparing hibernate3:hbm2ddl
...
10:24:56,151  INFO org.hibernate.tool.hbm2ddl.SchemaExport - export complete
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
</screen>Once you run this, you should see a <filename>data/</filename> directory under <varname>simple-command</varname>. This <filename>data/</filename> directory holds the HSQLDB database. To run the command-line weather forecaster, run the following from the <filename>simple-command/</filename> project directory: </para><screen>$ <command>java -cp target/simple-command-jar-with-dependencies.jar \
           org.sonatype.mavenbook.weather.Main 60202</command>
2321 INFO  YahooRetriever  - Retrieving Weather Data
2489 INFO  YahooParser  - Creating XML Reader
2581 INFO  YahooParser  - Parsing XML Response
2875 INFO  WeatherFormatter  - Formatting Weather Data
****************************************
Current Weather Conditions for:
  Evanston, 
  IL, 
  US
****************************************
  
 * Temperature: 75
 * Condition: Partly Cloudy
 * Humidity: 64
 * Wind Chill: 75
 * Date: Wed Aug 06 09:35:30 CDT 2008
</screen> <para>To run a history query, execute the following command: </para><screen>$ <command>java -cp target/simple-command-jar-with-dependencies.jar \
           org.sonatype.mavenbook.weather.Main 60202 history</command>
2470 INFO  WeatherFormatter  - Formatting History Data
Weather History for: 
Evanston, IL, US
  
****************************************
 * Temperature: 39
 * Condition: Heavy Rain
 * Humidity: 93
 * Wind Chill: 36
 * Date: 2007-12-02 13:45:27.187
****************************************
 * Temperature: 75
 * Condition: Partly Cloudy
 * Humidity: 64
 * Wind Chill: 75
 * Date: 2008-08-06 09:24:11.725
****************************************
 * Temperature: 75
 * Condition: Partly Cloudy
 * Humidity: 64
 * Wind Chill: 75
 * Date: 2008-08-06 09:27:28.475 </screen>  </section> <section id="multimodule-web-spring-sect-conclusion"><title>Conclusion</title> <para>We've spent a great deal of time on topics not directly related Maven to get this far. We've done this to present a complete and meaningful example project which you can use to implement real-world systems. We didn't take any short-cuts to produce slick, canned results quickly, and we're not going to dazzle you with some Ruby on Rails-esque wizardry and lead you to believe that you can create a finished Java Enterprise application in "10 easy minutes!" There's too much of this in the market, there are too many people trying to sell you the easiest framework that requires zero investment of time or attention. What we're trying to do in this chapter is present the entire picture, the entire ecosystem of a multi-module build. What we've done is present Maven in the context of a application which resembles something you could see in the wild—not the fast-food, 10 minute screen-cast that slings mud at Apache Ant and tries to convince you to adopt Apache Maven.</para> <para>If you walk away from this chapter wondering what it has to do with Maven, we've succeeded. We present a complex set of projects, using popular frameworks, and we tie them together using declarative builds. The fact that more than 60% of this chapter was spent explaining Spring and Hibernate should tell you that Maven, for the most part, stepped out of the way. It worked. It allowed us to focus on the application itself, not on the build process. Instead of spending time discussing Maven, and the work you would have to do to "build a build" that integrated with Spring and Hibernate, we talked almost exclusively about the technologies used in this contrived project. If you start to use Maven, and you take the time to learn it, you really do start to benefit from the fact that you don't have to spend time coding up some procedural build script. You don't have to spend your time worrying about mundane aspects of your build.</para> <para>You can use the skeleton project introduced in this chapter as the foundation for your own, and chances are that when you do, you'll find yourself creating more and more modules as you need them. For example, the project on which this chapter was based has two distinct model projects, two persistence projects which persist to dramatically different databases, several web applications, and a Java mobile application. In total, the real world system I based this on contains at least 15 interrelated modules. The point is that, you've seen the most complex multi-module example we're going to include in this book, but you should also know that this example just scratches the surface of what is possible with Maven. </para> <section id="multimodule-web-spring-sect-interface-projects"><title>Programming to Interface Projects</title> <para>This chapter explored a multi-module project which was more complex than the simple example presented in <xref linkend="multimodule" />, yet it was still a simplification of a real-world project. In a larger project, you might find yourself building a system resembling <xref linkend="fig-multimodule-web-spring-projects-complex" />. </para> <figure id="fig-multimodule-web-spring-projects-complex"><title>Programming to Interface Projects</title> <mediaobject> <imageobject role="web"> <imagedata fileref="figs/web/multimodule-web-spring_projects-complex.png"
                       scalefit="1" width="" /> </imageobject> <imageobject role="print"> <imagedata fileref="figs/print/multimodule-web-spring_projects-complex.pdf" /> </imageobject> </mediaobject> </figure> <para>When we use the term interface project we are referring to a Maven project which contains interfaces and constants only. In <xref linkend="fig-multimodule-web-spring-projects-complex" /> the interface projects would be <varname>persist-api</varname> and <varname>parse-api</varname>. If <varname>big-command</varname> and <varname>big-webapp</varname> are written to the interfaces defined in <varname>persist-api</varname>, then it is very easy to just swap in another implementation of the persistence library. This particular diagram shows two implementations of the <varname>persist-api</varname> project, one which stores data in an <acronym>XML</acronym> database, and the other which stores data in a relational database. If you use some of the concepts in this chapter, you can see how you could just pass in a flag to the program that swaps in a different Spring application context <acronym>XML</acronym> file to swap out data sources of persistence implementations. Just like the OO design of the application itself, it is often wise to separate the interfaces of an <acronym>API</acronym> from the implementation of the API into separate Maven projects.</para> </section> </section>
</chapter>
