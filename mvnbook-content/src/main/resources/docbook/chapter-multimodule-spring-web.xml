<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="multimodule-web-spring" lang="fr">
  <title>Un projet multimodule d'entreprise</title>

  <section id="multimodule-web-spring-sect-intro">
    <title>Introduction</title>

    <para>Dans ce chapitre, nous allons créer un projet multimodule à partir<indexterm class="startofrange" id="enterprise1a">
        <primary>projet multimodule (exemple)</primary>
        <secondary>projet multimodule d'entreprise</secondary>
      </indexterm><indexterm class="startofrange" id="enterprise1b">
        <primary>Applications Web</primary>
        <secondary>exemple de projet multimodule d'entreprise</secondary>
      </indexterm><indexterm class="startofrange" id="enterprise1c">
        <primary>projet d'entreprise, multimodule (exemple)</primary>
      </indexterm> des exemples du <xref linkend="multimodule" /> et du <xref
    linkend="web" />. Nous ferons évoluer ces exemples en un projet utilisant 
    les frameworks Spring et Hibernate pour créer deux applications :
    une application web et une application en ligne de commande. Ces deux applications
    permettront de lire le flux provenant du service Yahoo! Météo. Le code du projet 
    <varname>simple-weather</varname> développé dans le <xref linkend="customizing" /> 
    sera donc combiné au code du projet <varname>simple-webapp</varname> du <xref linkend="web" />. 
    Pour créer ce projet multimodule, nous allons explorer Maven et discuter des différentes manières
    de l'utiliser pour créer des projets modulaires encourageant la réutilisation.
    </para>

    <section id="multimodule-web-spring-sect-downloading-example">
      <title>Télécharger les sources de ce chapitre</title>

      <para>Le projet multimodule développé dans cet exemple se compose des versions modifiées 
      des projets développés dans le <xref linkend="customizing" /> et le <xref linkend="web" />,
      sans utiliser le plugin Maven Archetype pour le générer. Nous recommandons de télécharger le code 
      des exemples pour utiliser celui-ci comme code de référence lors de la lecture de ce chapitre.
      Sans ces exemples, vous ne serez pas capable de recréer la totalité du projet produit dans ce chapitre.
      Le projet contenant les exemples de ce chapitre peut être téléchargé à l'adresse suivante :</para>

      <screen>${examples.download.url}</screen>       
      
      <para>Une fois téléchargée, décompressez l'archive dans n'importe quel répertoire et entrez dans le répertoire <filename>ch-multi-spring/</filename>.
      Vous trouverez alors dans celui-ci un sous-répertoire <filename>simple-parent/</filename>      
      qui contient le projet Maven multimodule que nous allons développer dans ce chapitre.
      Dans le répertoire de ce projet, vous trouverez un fichier <filename>pom.xml</filename> et
      cinq sous-modules :
      <filename>simple-model/</filename>,
      <filename>simple-persist/</filename>,
      <filename>simple-command/</filename>,
      <filename>simple-weather/</filename> et
      <filename>simple-webapp/</filename>.</para>
    </section>

    <section id="multimodule-web-spring-sect-project-description">
      <title>Projet multimodule d'entreprise</title>

      <para>Présenter la complexité d'un projet d'entreprise d'envergure dépasse de loin la portée de ce livre.
      De tels projets sont souvent caractérisés par des problématiques bien spécifiques : bases de données multiples,
      intégration avec des systèmes externes, sous-projets divisés par départements... 
      Ce genre de projets comporte en général plusieurs milliers de lignes de codes et peut impliquer des dizaines, voire des centaines, de développeurs.
      S'il est évident que nous ne traiterons pas d'un projet de ce type dans son intégralité dans ce livre,
      nous allons tout de même vous fournir un exemple assez complet pour appréhender la complexité d'une application d'entreprise.
      Enfin, en conclusion, au-delà de ce qui est présenté dans ce chapitre, nous explorerons quelques pistes pour rendre vos applications modulaires.
      </para>

      <para>Dans ce chapitre, nous allons étudier un projet Maven multimodule qui produira deux applications :
      un outil en ligne de commande et une application web ; chacune de ces applications permettra d'interroger le flux Yahoo! Météo.
      Ces deux applications conserveront les résultats des différentes requêtes dans une base de données embarquée
      et permettront de récupérer l'historique des prévisions météorologiques stockées dans celle-ci.
      Les deux applications réutiliseront le même code métier et partageront une bibliothèque de persistance.
      L'exemple de ce chapitre est construit sur la base du code du parseur développé dans le <xref linkend="customizing" />.
      Ce projet est divisé en cinq sous-modules, dont voici la présentation sur la <xref linkend = "fig-multimodule-web-spring-projects"/>.</para>

      <figure id="fig-multimodule-web-spring-projects">
        <title>Relations entre les modules de l'application d'entreprise</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/multimodule-web-spring_projects.png" />
          </imageobject>

          <imageobject role="print">
            <imagedata align="center"
                       fileref="figs/print/multimodule-web-spring_projects.pdf"
                       format="PDF" scalefit="0" width="100%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Sur la <xref linkend="fig-multimodule-web-spring-projects" />,
      vous pouvez voir que projet <varname>simple-parent</varname> se compose de cinq sous-modules :
      </para>

      <variablelist>
        <varlistentry>
          <term>simple-model</term>

          <listitem>
            <para>Ce module définit un simple modèle d'objets correspondant aux données retournées par le flux  Yahoo! Météo.
            Ce modèle contient les objets suivants : <classname>Weather</classname>,
            <classname>Condition</classname>,
            <classname>Atmosphere</classname>,
            <classname>Location</classname>, et <classname>Wind</classname>.
            Lorsque notre application parse le flux Yahoo! Météo, 
            les parseurs définis dans le module <varname>simple-weather</varname> transforment le <acronym>XML</acronym>
            en une liste d'objets <classname>Weather</classname> qui sera ensuite utilisée dans les applications.
            Ce projet contient des objets du modèle annotés avec les annotations Hibernate3. 
            Le module <varname>simple-persist</varname> utilise ces objets pour associer chacun d'entre eux à une table de la base de données.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>simple-weather</term>

          <listitem>
            <para>Ce module contient toute la logique nécessaire pour récupérer des données du flux Yahoo! Météo et parser le <acronym>XML</acronym> obtenu.
            Ce <acronym>XML</acronym> est converti sous la forme d'objets du module <varname>simple-model</varname>.
            C'est pour cela que le module <varname>simple-weather</varname> doit dépendre du module <varname>simple-model</varname>.
            Enfin, <varname>simple-weather</varname> définit un service <classname>WeatherService</classname> qui est référencé par deux autres projets :
            <varname>simple-command</varname> et <varname>simple-webapp</varname>.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>simple-persist</term>

          <listitem>
            <para>Ce module contient les <acronym>DAO</acronym>s (Data Access Objects) qui permettent
            d'enregistrer les objets <classname>Weather</classname> dans la base de données.
            Ces <acronym>DAO</acronym>s seront utilisés par les deux applications de ce projet multimodule.
            Ils permettront également de faire le lien avec les objets du modèle du module <varname>simple-model</varname>. 
            Le module <varname>simple-persist</varname> a donc une dépendance directe au module <varname>simple-model</varname>
            et une dépendance vers le <acronym>JAR</acronym> contenant les Annotations Hibernate.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>simple-webapp</term>

          <listitem>
            <para>L'application web contient deux contrôleurs Spring <acronym>MVC</acronym> qui utilisent le service
            <classname>WeatherService</classname> défini dans le module <varname>simple-weather</varname> et les <acronym>DAO</acronym>s
            provenant du module <varname>simple-persist</varname>. 
            De plus, <varname>simple-webapp</varname> a une dépendance directe sur les modules 
            <varname>simple-weather</varname> et
            <varname>simple-persist</varname>. Ce module dépend donc transitivement du module <varname>simple-model</varname>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>simple-command</term>

          <listitem>
            <para>Ce module contient une application en ligne de commande qui permet d'interroger le flux Yahoo! Météo.
            Ce projet contient une classe avec une méthode statique <methodname>main()</methodname> qui interagit avec le service
            <classname>WeatherService</classname> défini dans le module <varname>simple-weather</varname> et les <acronym>DAO</acronym>s 
            du projet <varname>simple-persist</varname>. 
            Le module <varname>simple-command</varname> a une dépendance directe sur les modules <varname>simple-weather</varname> et
            <varname>simple-persist</varname> et une dépendance transitive au module <varname>simple-model</varname>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Ce chapitre contient un exemple assez simple pour être décrit dans un livre et 
      assez complexe pour justifier la création de cinq sous-modules.
      Notre exemple est organisé autour d'un modèle contenant cinq classes, 
      une bibliothèque de persistance avec deux classes de service 
      et une bibliothèque d'analyse grammaticale du flux météo contenant cinq ou six classes.
      Dans un cas réel, un projet peut avoir un modèle de plusieurs centaines de classes, 
      plusieurs bibliothèques de persistance et des bibliothèques de services partagées.
      Bien que nous ayons essayé de garder un exemple suffisamment simple pour être compris rapidement,
      nous vous proposons un projet bien plus complexe que le projet multimodule du chapitre précédent.
      Vous pourriez être tentés de regarder rapidement les exemples dans ce chapitre et penser que Maven 
      génère trop de complexité comparée à la taille du modèle d'objet.
      Bien que l'utilisation de Maven suggère un certain niveau de modularité, 
      comprenez bien que nous avons volontairement compliqué ici nos exemples dans le but de montrer les fonctionnalités Maven dans le cas de projets multimodule.</para>
    </section>

    <section id="multimodule-web-spring-sect-example-tech">
      <title>Technologies utilisées dans cet exemple</title>

      <para>L'exemple de ce chapitre implique un peu de technologies qui, même si elles sont populaires, ne sont pas directement liées à Maven.
      Ces technologies sont Spring et Hibernate.
      Spring est un conteneur <acronym>IoC</acronym> (Inversion of Control) accompagné par un ensemble de frameworks dont le but
      est de simplifier les interactions entre diverses bibliothèques <acronym>J2EE</acronym>.
      Utiliser Spring comme fondation pour le développement d'applications vous donne accès à un certain nombre d'abstractions très pratiques 
      qui permettent, entre autres, de faciliter l'intégration des framework de persistance comme Hibernate, iBatis ou d'<acronym>API</acronym> d'entreprise
      comme <acronym>JDBC</acronym>, <acronym>JNDI</acronym> et <acronym>JMS</acronym>.
      La popularité de Spring n'a cessé de s'accroître ces dernières années, permettant d'offrir une solution alternative aux lourds standards proposés par Sun Microsystems.
      Quant à Hibernate, il s'agit d'un framework d'<acronym>ORM</acronym> (Object-Relational Mapping) très largement utilisé
      qui permet d'interagir avec une base de données comme s'il s'agissait d'une liste d'objets Java.
      Cet exemple se concentre sur la construction d'une application web simple et d'une application en ligne de commande
      qui utilisent Spring pour exposer un ensemble réutilisable de composants et Hibernate pour sauvegarder les données météo dans une base embarquée.
      </para>

      <para>Nous avons décidé d'inclure des références à ces frameworks pour montrer comment on construirait des projets en utilisant ces mêmes technologies conjointement à Maven.
      Bien que nous introduisions ces technologies, ne s'agissant pas des priorités de ce chapitre, elles ne seront pas présentées dans leur intégralité.
      Pour plus d'informations sur Spring, référez-vous au site officiel dont l'adresse est <ulink url="http://www.springframework.org/"></ulink>.
      De même, pour plus d'informations sur Hibernate, en particulier sur ses <phrase role="keep-together">Annotations</phrase>, référez-vous au site du projet <ulink url="http://www.hibernate.org"></ulink>.
      Ce chapitre utilise <acronym>HSQLDB</acronym> (Hyper-threaded Structured Query Language Database) comme base de données embarquée. Pour plus d'informations sur celle-ci consultez le site du projet <ulink url="http://hsqldb.org/"></ulink>.
      </para>
    </section>
  </section>

  <section id="multimodule-web-spring-sect-simple-parent">
    <title>Le projet simple-parent</title>

    <para>Ce projet <varname>simple-parent</varname> contient<indexterm
        class="startofrange" id="enterprise2a">
        <primary>projet parent simple (exemple)</primary>
        <secondary>projet d'entreprise multimodule</secondary>
      </indexterm><indexterm class="startofrange" id="enterprise2b">
        <primary>projet multimodule (exemple)</primary>
        <secondary>projet d'entreprise multimodule</secondary>
        <tertiary>projet parent simple</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise2c">
        <primary>Applications Web</primary>
        <secondary>exemple de projet multimodule</secondary>
        <tertiary>projet parent simple</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise2d">
        <primary>projet d'entreprise, multimodule (exemple)</primary>
        <secondary>projet parent simple</secondary>
      </indexterm> un fichier <filename>pom.xml</filename> qui référence cinq sous-modules :
    <varname>simple-command</varname>,
    <varname>simple-model</varname>, <varname>simple-weather</varname>,
    <varname>simple-persist</varname> et <varname>simple-webapp</varname>.
    Le fichier <filename>pom.xml</filename> de plus haut niveau est affiché dans l'<xref linkend="ex-multimodule-web-spring-parent" />.</para>

    <example id="ex-multimodule-web-spring-parent">
      <title>POM du projet <varname>simple-parent</varname></title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;org.sonatype.mavenbook.multispring&lt;/groupId&gt;
  &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;name&gt;Multi-Spring Chapter Simple Parent Project&lt;/name&gt;
 
  &lt;modules&gt;
    &lt;module&gt;simple-command&lt;/module&gt;
    &lt;module&gt;simple-model&lt;/module&gt;
    &lt;module&gt;simple-weather&lt;/module&gt;
    &lt;module&gt;simple-persist&lt;/module&gt;
    &lt;module&gt;simple-webapp&lt;/module&gt;
  &lt;/modules&gt;

  &lt;build&gt;
    &lt;pluginManagement&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
          &lt;configuration&gt;
            &lt;source&gt;1.5&lt;/source&gt;
            &lt;target&gt;1.5&lt;/target&gt;
          &lt;/configuration&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
   &lt;/pluginManagement&gt; 
  &lt;/build&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;

</programlisting>
    </example>

    <note>
      <para>Si les POMs Maven vous sont déjà familiers, vous pouvez remarquer que ce POM de plus haut niveau ne définit pas de balise <sgmltag>dependencyManagement</sgmltag>.
      La balise <sgmltag>dependencyManagement</sgmltag> permet de définir la version des dépendances à un endroit centralisé dans un POM de haut-niveau.
      Ce mécanisme sera abordée dans le <xref linkend="optimizing" />.</para>
    </note>

    <para>Notez les similarités de ce <acronym>POM</acronym> parent et celui de l'<xref linkend="ex-multimodule-parent-pom" />.
    La seule réelle différence entre ces deux <acronym>POM</acronym>s est la liste de leurs sous-modules.
    Là où l'exemple précédent comptait deux sous-modules, ce <acronym>POM</acronym> en dénombre cinq.
    Les sections suivantes explorent en détail chacun de ces cinq sous-modules. 
    Notre exemple utilisant des annotations, nous avons configuré le compilateur pour cibler les <acronym>JVM</acronym> Java 5.      
    </para>
    
  </section>

  <section id="multimodule-web-spring-sect-simple-model-project">
    <title>Le module simple-model</title>

    <para>La première chose dont ont besoin la plupart des projets d'entreprise est un modèle objet.
    Un modèle objet rassemble la liste des principaux objets du domaine d'un système.
    Par exemple, un système bancaire pourrait avoir un modèle objet qui se compose des objets suivants :
    <classname>Compte</classname>, <classname>Client</classname> et <classname>Transaction</classname>.
    De la même manière, un système publiant des résultats sportifs pourrait contenir des objets <classname>Equipe</classname> et <classname>Match</classname>.
    Quoique vous fassiez, il est probable que vous ayez intégré les concepts de votre système dans un modèle objet.
    C'est pratique courante dans les projets Maven de séparer ce type de projet et de le référencer dans le reste du projet.
    Dans notre système, nous transformons chaque requête du flux Yahoo! Météo dans un objet <classname>Weather</classname> qui référence quatre autres objets.
    La direction, l'effet de froid relatif et la vitesse du vent sont stockées dans un objet <classname>Wind</classname>.
    Les données de localisation telles que le code postal, la ville, la région et le pays sont stockées dans la classe <classname>Location</classname>. 
    Les conditions atmosphériques telles que l'humidité, la visibilité, la pression barométrique et la tendance sont conservées dans une classe <classname>Atmosphere</classname>.         
    Enfin, la description textuelle des conditions, la température et la date de l'observation sont conservées dans une classe <classname>Condition</classname>.</para>

    <figure>
      <title>Modèle objet pour les données météo</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata fileref="figs/web/multimodule-web-spring_object-model.png" format="PNG" />
        </imageobject>

        <imageobject role="print">
           <imagedata align="center"
                     fileref="figs/print/multimodule-web-spring_object-model.pdf"
                     format="PDF" scalefit="0" width="100%" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Le fichier <filename>pom.xml</filename> de ce modèle objet contient une dépendance qui nécessite une explication.
    Notre modèle objet est<indexterm>
        <primary>Annotations Hibernate</primary>
      </indexterm><indexterm>
        <primary>annotations (Hibernate)</primary>
      </indexterm> annoté avec Hibernate Annotations. 
    Celles-ci sont utilisées pour associer ce modèle aux tables de la base de données relationnelle.
    Cette dépendance est <varname>org.hibernate:hibernate-annotations:3.3.0.ga</varname>. 
    Regardons le <filename>pom.xml</filename> affiché dans l'<xref linkend="example_simple-model_pom.xml" />, 
    ainsi que les quelques exemples d'utilisation de ces annotations.</para>

    <example id="example_simple-model_pom.xml">
      <title>POM du module simple-model</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.multispring&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;simple-model&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;Simple Object Model&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-commons-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>

      <para>Dans le dossier <filename>src/main/java/org/sonatype/mavenbook/weather/model</filename> se trouve le fichier <filename>Weather.java</filename>.
      Celui-ci contient l'objet <classname>Weather</classname> annoté. Il s'agit d'un simple Java bean.
      Cela veut dire qu'il contient des variables d'instance privées comme <varname>id</varname>,
      <varname>location</varname>, <varname>condition</varname>,
      <varname>wind</varname>, <varname>atmosphere</varname> et
      <varname>date</varname>. Celles-ci sont exposées par l'intermédiaire d'accesseurs publiques en suivant ce pattern :
      une propriété nommée <literal>name</literal> disposera d'un getter public sans argument nommé <methodname>getName()</methodname>,
      et d'un setter prenant en paramètre un argument nommé <methodname role="keep-together">setName(String name)</methodname>.
      Si nous montrons le getter et le setter de la propriété <varname>id</varname>, 
      nous avons omis volontairement la plupart des getters et des setters des autres propriétés afin de sauver quelques arbres.
      Consultez l'<xref linkend="example_weather_model_object" />.</para>

    </example>

    <example id="example_weather_model_object">
      <title>Objet Weather annoté</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather.model;

import javax.persistence.*;

import java.util.Date;

@Entity
@NamedQueries({
  @NamedQuery(name="Weather.byLocation", 
              query="from Weather w where w.location = :location")
})
public class Weather {

    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Integer id;

    @ManyToOne(cascade=CascadeType.ALL)
    private Location location;

    @OneToOne(mappedBy="weather",cascade=CascadeType.ALL)
    private Condition condition;

    @OneToOne(mappedBy="weather",cascade=CascadeType.ALL)
    private Wind wind;

    @OneToOne(mappedBy="weather",cascade=CascadeType.ALL)
    private Atmosphere atmosphere;

    private Date date;
    
    public Weather() {}

    public Integer getId() { return id; }
    public void setId(Integer id) { this.id = id; }

    // Nous avons omis les autres getter et setter...
}
</programlisting>
    </example>

    <para>La classe <classname>Weather</classname> utilise des annotations qui permettent de guider Hibernate pour associer cet objet à une table de la base de données relationnelle.
    Bien qu'une explication détaillée des annotations Hibernate dépasse les limites de ce chapitre, en voici quelques grandes lignes.<indexterm>
        <primary sortas="Entity annotation (Hibernate)">Annotation @Entity (Hibernate)</primary>
      </indexterm> L'annotation <classname>@Entity</classname> marque la classe comme entité persistante.
      Nous avons omis l'annotation <classname>@Table</classname> sur cette classe, <indexterm>
        <primary sortas="Table annotation (Hibernate)">Annotation @Table (Hibernate)</primary>
      </indexterm> ainsi, Hibernate va utiliser le nom de la classe comme nom de table. 
      L'annotation<indexterm>
        <primary sortas="NamedQueries annotation (Hibernate)">Annotation @NamedQueries (Hibernate)</primary>
      </indexterm> <classname>@NamedQueries</classname> définit une requête qui sera utilisée par le <classname>WeatherDAO</classname> dans le module <varname>simple-persist</varname>.   
      Le langage utilisé dans la requête de l'annotation<indexterm>
        <primary sortas="NamedQuery annotation (Hibernate)">Annotation @NamedQuery (Hibernate)</primary>
      </indexterm> <classname>@NamedQuery</classname> est écrit en<indexterm>
        <primary>HQL (Hibernate Query Language)</primary>
      </indexterm> <acronym>HQL</acronym> (Hibernate Query Language).
      Chaque champ de la classe est annoté par des annotations définissant le type des différentes colonnes à associer ainsi que les relations impliquées sur celles-ci :</para>

    <variablelist>
      <varlistentry>
        <term role="plain"><varname>Id</varname></term>

        <listitem>
          <para>La propriété <varname>id</varname> est annotée avec <classname>@Id</classname>. 
          Cette annotation marque ce champ comme propriété contenant la clé primaire de la table de base de données.
          L'annotation <classname>@GeneratedValue</classname> permet de contrôler comment les nouvelles valeurs de la clé primaire sont générées. 
          Dans le cas de notre propriété <varname>id</varname>, 
          nous utilisons la valeur <varname>IDENTITY</varname> de l'énumération <classname>GenerationType</classname>
          qui permet d'utiliser la génération d'identité fournie par la base de données sous-jacente.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term role="plain"><varname>Location</varname></term>

        <listitem>
          <para>Chaque instance de la classe <classname>Weather</classname> contient un objet <classname>Location</classname>.  
          Ce dernier représente un code postal. 
          Son annotation <classname>@ManyToOne</classname> vous assure que tous les objets <classname>Weather</classname> qui possèdent la même <classname>Location</classname>   
          pointent effectivement vers les mêmes instances.
          L'attribut <varname>cascade</varname> de l'annotation 
          <classname>@ManyToOne</classname> permet d'assurer qu'un objet <classname>Location</classname> soit enregistré
          à chaque sauvegarde d'un objet <classname>Weather</classname>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term role="plain"><varname>Condition</varname>,
        <varname>Wind</varname>, <varname>Atmosphere</varname></term>

        <listitem>
          <para>Chacun de ces objets est mappé avec une annotation <classname>@OneToOne</classname> dont la propriété <varname>cascade</varname> est à <classname>CascadeType</classname>.<varname>ALL</varname>.
          Cette propriété signifie qu'à chaque sauvegarde d'un objet <classname>Weather</classname> une ligne sera créée dans chacune des tables suivantes :
          <varname>Condition</varname>, <varname>Wind</varname> et <varname>Atmosphere</varname>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term role="plain"><varname>Date</varname></term>

        <listitem>
          <para>Le champ <varname>Date</varname> n'est pas annoté. 
          Cela signifie qu'Hibernate va utiliser la configuration par défaut pour son mapping.
          Le nom de la colonne sera <literal>date</literal> et possédera le type timestamp approprié pour un objet <classname>Date</classname>.</para>   

          <note>
            <para>Si vous désirez omettre une propriété du mapping, vous pouvez annoter celle-ci avec <classname>@Transient</classname>.</para>
          </note>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Ensuite, jetons un coup d'oeil à un second objet du modèle,
    <classname>Condition</classname>, affiché dans l'<xref linkend="example_condition_model_object" />. 
    Cette classe se trouve également dans le dossier <filename>src/main/java/org/sonatype/mavenbook/weather/model</filename>.</para>

    <example id="example_condition_model_object">
      <title>Classe Condition du module simple-model</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather.model;

import javax.persistence.*;

@Entity
public class Condition {

    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Integer id;

    private String text;
    private String code;
    private String temp;
    private String date;

    @OneToOne(cascade=CascadeType.ALL)
    @JoinColumn(name="weather_id", nullable=false)
    private Weather weather;

    public Condition() {}

    public Integer getId() { return id; }
    public void setId(Integer id) { this.id = id; }

    // Nous avons omis les autres getter et setter...
}</programlisting>
    </example>

    <para>La classe <classname>Condition</classname> ressemble à la classe <classname>Weather</classname>. 
    Elle est annotée avec <classname>@Entity</classname> et possède les mêmes annotations sur la propriété <varname>id</varname>. 
    Les champs <varname>text</varname>, <varname>code</varname>, <varname>temp</varname> et <varname>date</varname> ne 
    possèdent pas d'annotation et restent donc liés à la base de données selon la configuration par défaut.
    La propriété <varname>weather</varname> est annotée avec <classname>@OneToOne</classname> et <classname>@JoinColumn</classname> qui permettent de référencer
    l'objet <classname>Weather</classname> associé via la clé étrangère <varname>weather_id</varname>.</para>
  </section>

  <section id="multimodule-web-spring-sect-simple-weather">
    <title>Le module simple-weather</title>

    <para>Le prochain module que nous allons examiner pourrait être considéré comme<indexterm class="startofrange" id="enterprise4a">
        <primary>projet multimodule (exemple)</primary>
        <secondary>projet d'entreprise multimodule</secondary>
        <tertiary>Module Météo Simple</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise4b">
        <primary>Applications Web</primary>
        <secondary>exemple de projet d'entreprise multimodule</secondary>
        <tertiary>Module Météo Simple</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise4c">
        <primary>projet d'entrerprise, multimodule (exemple)</primary>
        <secondary>Module Météo Simple</secondary>
      </indexterm> un “service”.
    Ce module contient toute la logique nécessaire pour récupérer et parser les données provenant du flux <acronym>RSS</acronym> Yahoo! Météo.
    Bien qu'il ne contienne que trois classes Java et un test JUnit, 
    il permet d'exposer un composant simple, <classname>WeatherService</classname>, qui sera utilisé 
    par l'application web et par l'application en ligne de commande.
    Un projet d'entreprise contient très souvent plusieurs modules <acronym>API</acronym>
    permettant de centraliser la logique métier et les interactions avec des systèmes externes.
    Un système bancaire pourrait avoir un module qui récupère et analyse des données provenant d'un fournisseur tiers,
    et un système affichant des résultats sportifs pourrait interagir avec un flux <acronym>XML</acronym> 
    qui fourit les scores du basket ou du football en temps réel.
    Dans l'<xref linkend="example_simple-weather_module_pom" />, ce module renferme toute l'activité réseau et le parsing du flux <acronym>XML</acronym> provenant du service Yahoo! Météo.
    Les autres modules peuvent dépendre de celui-ci et simplement appeler la méthode <methodname
    role="keep-together">retrieveForecast()</methodname> du service <classname>WeatherService</classname> 
    qui prend en paramètre un code postal et retourne un objet <classname>Weather</classname>.</para>      

    <example id="example_simple-weather_module_pom">
      <title>POM du module simple-weather</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.multispring&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;simple-weather&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;Simple Weather API&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.multispring&lt;/groupId&gt;
      &lt;artifactId&gt;simple-model&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j&lt;/artifactId&gt;
      &lt;version&gt;1.2.14&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;dom4j&lt;/groupId&gt;
      &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
      &lt;version&gt;1.6.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;jaxen&lt;/groupId&gt;
      &lt;artifactId&gt;jaxen&lt;/artifactId&gt;
      &lt;version&gt;1.1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
      &lt;version&gt;1.3.2&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;

</programlisting>
    </example>

    <para>Le POM du module <varname>simple-weather</varname> étend
    celui du  <varname>simple-parent</varname>, configure le type de packaging à <varname>jar</varname>
    et ajoute les dépendances suivantes :</para>

    <variablelist>
      <varlistentry>
        <term><literal>org.sonatype.mavenbook.multispring:simple-model:1.0</literal></term>

        <listitem>
          <para>Le module <varname>simple-weather</varname> parse et le transforme le flux  <acronym>RSS</acronym> Yahoo! Météo en objet <classname>Weather</classname>.
          Il a donc une dépendance directe sur le module <varname>simple-model</varname>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>log4j:log4j:1.2.14</literal></term>

        <listitem>
          <para>Le module <varname>simple-weather</varname> utilise Log4J pour afficher ses messages de log.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>dom4j:dom4j:1.6.1 et jaxen:jaxen:1.1.1</literal></term>

        <listitem>
          <para>Ces deux dépendances sont utilisées pour parser le <acronym>XML</acronym> provenant de Yahoo! Météo.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>org.apache.commons:commons-io:1.3.2
        (scope=test)</literal></term>

        <listitem>
          <para>Cette dépendance dont le scope est <literal>test</literal> est utilisée par  <classname>YahooParserTest</classname>.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Analysons maintenant le service <classname>WeatherService</classname> de l'<xref linkend="example_weatherservice_class" />.
    Cette classe ressemble beaucoup au service <classname>WeatherService</classname> de l'<xref linkend="multimodule-weather-service" />.
    Bien qu'ils aient le même nom, le service de cet exemple comporte quelques légères différences.
    Dans cette version, la méthode <methodname>retrieveForecast()</methodname> retourne un objet <classname>Weather</classname>
    et le formatage est délégué à l'application appelant le service <classname>WeatherService</classname>.
    L'autre modification majeure concerne les classes <classname>YahooRetriever</classname> et <classname>YahooParser</classname>, 
    qui sont maintenant des propriétés du service <classname>WeatherService</classname>.</para> 

    <example id="example_weatherservice_class">
      <title>La classe WeatherService</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.io.InputStream;

import org.sonatype.mavenbook.weather.model.Weather;

public class WeatherService {

  private YahooRetriever yahooRetriever;
  private YahooParser yahooParser;

  public WeatherService() {}

  public Weather retrieveForecast(String zip) throws Exception {
    // Récupération des données
    InputStream dataIn = yahooRetriever.retrieve(zip);

    // Parsing des données
    Weather weather = yahooParser.parse(zip, dataIn);

    return weather;
  }

  public YahooRetriever getYahooRetriever() {
    return yahooRetriever;
  }

  public void setYahooRetriever(YahooRetriever yahooRetriever) {
    this.yahooRetriever = yahooRetriever;
  }

  public YahooParser getYahooParser() {
    return yahooParser;
  }

  public void setYahooParser(YahooParser yahooParser) {
    this.yahooParser = yahooParser;
  }
}
</programlisting>
    </example>

    <para>Pour finir, ce projet contient un fichier <acronym>XML</acronym> utilisé par Spring pour 
    créer ce qu'on appelle l'<indexterm>
        <primary>ApplicationContext (Spring Framework)</primary>
      </indexterm> <classname>ApplicationContext</classname> dont voici le fonctionnement :  
    nos applications web et en ligne de commande ont besoin d'interagir avec le service 
    <classname>WeatherService</classname>, pour cela elles récupèrent une instance de cette classe par l'intermédiaire 
    de l'<classname>ApplicationContext</classname> Spring en utilisant le nom de bean <varname>weatherService</varname>. 
    Notre application web utilise un contrôleur Spring <acronym>MVC</acronym>, celui-ci est associé à une instance du service <classname>WeatherService</classname>.
    L'application en ligne de commande charge ce même service à partir de la méthode statique <methodname>main()</methodname> grâce à l'<classname>ApplicationContext</classname>. 
    Afin d'encourager la réutilisation du code, nous avons inclus le fichier <filename>applicationContext-weather.xml</filename> dans le répertoire <filename>src/main/resources</filename>, le rendant ainsi accessible dans le classpath.
    Les projets qui dépendent du module <varname>simple-weather</varname> peuvent donc charger ce fichier en utilisant la classe <classname>ClasspathXmlApplicationContext</classname> fournie par Spring
    et ainsi récupérer une instance du service <classname>WeatherService</classname> par l'intermédiaire de son nom : <varname>weatherService</varname>.</para>

    <example>
      <title>ApplicationContext Spring du module simple-weather</title>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
             http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
    default-lazy-init="true"&gt;

    &lt;bean id="weatherService" 
             class="org.sonatype.mavenbook.weather.WeatherService"&gt;
      &lt;property name="yahooRetriever" ref="yahooRetriever"/&gt;
      &lt;property name="yahooParser" ref="yahooParser"/&gt;
    &lt;/bean&gt;    

    &lt;bean id="yahooRetriever" 
             class="org.sonatype.mavenbook.weather.YahooRetriever"/&gt;    

    &lt;bean id="yahooParser" 
             class="org.sonatype.mavenbook.weather.YahooParser"/&gt;
&lt;/beans&gt;</programlisting>
    </example>

    <para>Ce fichier déclare trois beans : <varname>yahooParser</varname>, <varname>yahooRetriever</varname> et <varname>weatherService</varname>.
    Le bean <varname>weatherService</varname> est une instance du service <classname>WeatherService</classname>. 
    Le fichier <acronym>XML</acronym> configure également les propriétés de ce bean
    <varname>yahooParser</varname> et <varname>yahooRetriever</varname> qui référencent les noms des deux instances de
    classes en question.
    Vous pouvez comparer ce fichier <filename>applicationContext-weather.xml</filename> à la définition de l'architecture d'un sous-système de ce projet multimodule. 
    Certains projets comme <varname>simple-webapp</varname> et <varname>simple-command</varname> peuvent référencer ce contexte 
    et récupérer une instance du service <classname>WeatherService</classname> configurée avec des instances des classes <classname>YahooRetriever</classname> et <classname>YahooParser</classname> en propriété.</para>

  </section>

  <section id="multimodule-web-spring-sect-simple-persist">
    <title>Le module simple-persist</title>

    <para>Ce module définit deux DAOs (Data Access Objects). Un DAO<indexterm>
        <primary>DAO (Data Access Objects)</primary>
      </indexterm><indexterm class="startofrange" id="enterprise5a">
        <primary>projet multimodule (exemple)</primary>
        <secondary>projet d'entreprise multimodule</secondary>
        <tertiary>Module de Persistance Simple de</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise5b">
        <primary>Applications Web</primary>
        <secondary>exemple de projet d'entreprise multimodule</secondary>
        <tertiary>Module de Persistance Simple de</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise5c">
        <primary>projet d'entreprise, multimodule (exemple)</primary>
        <secondary>Module de Persistance Simple de</secondary>
      </indexterm> est un objet qui fournit une interface aux opérations de persistances.
    Dans une application qui utilise un framework de mapping ORM (Object-Relational Mapping) comme Hibernate, un DAO est défini autour d'un objet.
    Dans ce projet, nous définissons deux objets DAOs :  <varname role="keep-together">WeatherDAO</varname> et <varname>LocationDAO</varname>.
    La classe <varname>WeatherDAO</varname> nous permet de sauvegarder un objet <varname>Weather</varname> dans la base de données,
    de le récupérer à partir de son <literal>id</literal> ou d'une <varname>Location</varname> spécifique.
    Le DAO <varname>LocationDAO</varname> contient une méthode qui permet la récupération d'un objet <varname>Location</varname> à partir d'un code postal. 
    Commençons par regarder le POM du module <literal>simple-persist</literal> dans l'<xref linkend="ex-simple-persist-POM" />.</para>

    <example id="ex-simple-persist-POM">
      <title>POM du module simple-persist</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.multispring&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;simple-persist&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;Simple Persistence API&lt;/name&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.multispring&lt;/groupId&gt;
      &lt;artifactId&gt;simple-model&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate&lt;/artifactId&gt;
      &lt;version&gt;3.2.5.ga&lt;/version&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;javax.transaction&lt;/groupId&gt;
          &lt;artifactId&gt;jta&lt;/artifactId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-commons-annotations&lt;/artifactId&gt;
      &lt;version&gt;3.3.0.ga&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
      &lt;version&gt;2.4&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring&lt;/artifactId&gt;
      &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>
    </example>


    <para>Ce <acronym>POM</acronym> référence celui du module <varname>simple-parent</varname> en <acronym>POM</acronym> parent et définit quelques dépendances. 
    Les dépendances listées dans le <acronym>POM</acronym> du module <varname>simple-persist</varname> sont :</para>

    <variablelist>
      <varlistentry>
        <term><literal>org.sonatype.mavenbook.multispring:simple-model:1.0</literal></term>

        <listitem>
          <para>Tout comme le module <varname>simple-weather</varname>, ce module de persistance 
          référence les objets du modèle définis dans le projet <varname>simple-model</varname>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>org.hibernate:hibernate:3.2.5.ga</literal></term>

        <listitem>
          <para>Nous définissions une dépendance sur la version 3.2.5.ga d'Hibernate. 
          Notez l'exclusion d'une dépendance transitive d'Hibernate, nous effectuons cela à cause de la dépendance 
          <varname>javax.</varname><varname>transaction:</varname><varname>jta</varname><indexterm>
              <primary>dépendances</primary>
              <secondary>javax.transaction:javax (non disponible)</secondary>
            </indexterm><indexterm>
              <primary>javax.transaction:javax dépendance (non disponible)</primary>
            </indexterm> qui n'est pas récupérable à partir du repository Maven public.
          Cette dépendance est l'une de ces dépendances Sun qui ne sont pas encore publiées dans le dépôt Maven libre 'central'.
          Afin d'éviter le message nous demandant d'aller télécharger cette dépendance, nous excluons simplement celle-ci d'Hibernate.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>javax.servlet:servlet-api:2.4</literal></term>

        <listitem>
          <para>Comme le projet contient une Servlet, nous devons inclure une version de Servlet API, ici la 2.4.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>org.springframework:spring:2.0.7</literal></term>

        <listitem>
          <para>Cette dépendance inclut l'intégration de Spring Framework<indexterm>
              <primary>Spring Framework</primary>
            </indexterm>.</para>

          <note>
            <para>C'est généralement une bonne pratique de dépendre uniquement des composants Spring que vous utilisez.
            Spring dispose d'ailleurs d'artefacts spécifiques tels que <varname>spring-hibernate3</varname>.</para>
          </note>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Pourquoi dépendre de Spring ? Lorsqu'il est utilisé avec son intégration Hibernate, Spring permet l'utilisation des classes Helpers comme <classname>HibernateDaoSupport</classname> facilitant l'utilisation d'Hibernate.   
    Pour savoir ce qu'il est possible de faire avec la classe <classname>HibernateDaoSupport</classname>, regardez le code de la classe <classname>WeatherDAO</classname> de l'<xref linkend="ex-persist-weatherdao-class" />.</para> 

    <example id="ex-persist-weatherdao-class">
      <title>Classe WeatherDAO du module simple-persist</title>

      <programlisting>package org.sonatype.mavenbook.weather.persist;

import java.util.ArrayList;
import java.util.List;

import org.hibernate.Query;
import org.hibernate.Session;
import org.springframework.orm.hibernate3.HibernateCallback;
import org.springframework.orm.hibernate3.support.HibernateDaoSupport;

import org.sonatype.mavenbook.weather.model.Location;
import org.sonatype.mavenbook.weather.model.Weather;

public class WeatherDAO extends HibernateDaoSupport <co
          id="coDef-hibDao-extends" linkends="coRef-hibDao-extends" /> {

    public WeatherDAO() {}

    public void save(Weather weather) {<co id="coDef-hibDao-2"
          linkends="coRef-hibDao-2" />
      getHibernateTemplate().save( weather );
    }

    public Weather load(Integer id) {<co id="coDef-hibDao-3"
          linkends="coRef-hibDao-3" />
      return (Weather) getHibernateTemplate().load( Weather.class, id);
    }

    @SuppressWarnings("unchecked")
    public List&lt;Weather&gt; recentForLocation( final Location location ) {
      return (List&lt;Weather&gt;) getHibernateTemplate().execute(
        new HibernateCallback() {<co id="coDef-hibDao-4"
          linkends="coRef-hibDao-4" />
        public Object doInHibernate(Session session) {
          Query query = getSession().getNamedQuery("Weather.byLocation");
          query.setParameter("location", location);
          return new ArrayList&lt;Weather&gt;( query.list() );
        }
      });
    }
}</programlisting>
    </example>

    <para>C'est tout ? Pas vraiment, mais cela suffit pour obtenir une classe qui permet d'insérer
    de nouvelles lignes, en récupérer par leur clé primaire et récupérer toutes les lignes
    <classname>Weather</classname> qui référent à un id de la table <classname>Location</classname>.
    Nous ne pouvons clairement pas arrêter ce livre et insérer les cinq cents pages qu'il faudrait
    pour comprendre les subtilités d'Hibernate, contentons-nous de quelques rapides explications :</para>

    <calloutlist>
      <callout arearefs="coDef-hibDao-extends" id="coRef-hibDao-extends">
        <para>Cette classe étend <classname>HibernateDaoSupport</classname>.
        Ce qui signifie que cette classe est associée à une <classname>SessionFactory</classname> Hibernate qui permet la création d'objets <classname>Session</classname> Hibernate.
        Avec Hibenate, chaque opération s'effectue par l'intermédiaire d'un objet <classname>Session</classname>, 
        celle-ci s'occupe des accès à la base de données et de la connexion via la <classname>DataSource</classname> JDBC.
        Étendre <classname>HibernateDaoSupport</classname> vous permet également d'accéder au template <classname>HibernateTemplate</classname> en utilisant la méthode <methodname>getHibernateTemplate()</methodname>.
        </para> 
      </callout>

      <callout arearefs="coDef-hibDao-2" id="coRef-hibDao-2">
        <para>La méthode <methodname>save()</methodname> prend une instance de la classe <classname>Weather</classname> et appelle la méthode <methodname>save()</methodname> de la classe <classname>HibernateTemplate</classname>. 
        L'<classname>HibernateTemplate</classname> simplifie les appels aux opérations standards d'Hibernate et convertit les exceptions typées des différentes bases de données en <classname>RuntimeException</classname>. 
        Appelons la méthode <methodname>save()</methodname> qui insère une nouvelle ligne dans la table <classname>Weather</classname>.
        La mise à jour d'une entité déjà en base passe par la méthode <methodname>update()</methodname>.
        La méthode <methodname>saveOrUpdate()</methodname> crée une nouvelle ligne ou la modifie en fonction de la présence d'une valeur non-nulle dans la propriété <varname>id</varname> de la classe.</para>
      </callout>

      <callout arearefs="coDef-hibDao-3" id="coRef-hibDao-3">
        <para>De la même manière, la méthode <methodname>load()</methodname> se contente d'appeler la méthode du même nom de l'instance <classname>HibernateTemplate</classname>.
        Cette méthode prend un objet <classname>Class</classname> et un <classname>Serializable</classname> en paramètres.
        Dans notre exemple, l'objet <classname>Serializable</classname> correspond à la valeur de <varname>id</varname> de l'objet <classname>Weather</classname> à charger.</para>
      </callout>

      <callout arearefs="coDef-hibDao-4" id="coRef-hibDao-4">
        <para>Cette dernière méthode <methodname>recentForLocation()</methodname> appelle une <classname>NamedQuery</classname> définie dans l'objet modèle <classname>Weather</classname>.
        Il s'agit de la requête nommée <code>"Weather.byLocation"</code> dont le code est <code>"from Weather w where w.location = :location"</code>. 
        Nous chargeons cette <classname>NamedQuery</classname> en utilisant une référence de la <classname>Session</classname> Hibernate 
        dans un <classname>HibernateCallback</classname> qui est lancé via un appel à la méthode <methodname>execute()</methodname> 
        de l'<classname>HibernateTemplate</classname>.   
        Dans cette méthode, nous remplissons le paramètre <varname>location</varname> avec le paramètre passé dans la méthode <methodname>recentForLocation()</methodname>.</para>  
      </callout>
    </calloutlist>

    <para>C'est maintenant le bon moment de clarifier certains points.
    Les classes <classname>HibernateDaoSupport</classname> et <classname>HibernateTemplate</classname> proviennent du framework Spring.
    Elles ont été créées par Spring pour faciliter l'écriture de <acronym>DAO</acronym>. 
    Pour cela, nous avons besoin de modifier la configuration de l'<classname>ApplicationContext</classname> Spring du module <varname>simple-persist</varname>.
    Le fichier XML de l'<xref linkend="ex-persist-spring" /> se trouve dans le dossier <filename>src/main/resources</filename> dans un fichier nommé <filename
    role="keep-together">applicationContext-persist.xml</filename>.</para>  

    <example id="ex-persist-spring">
      <title>ApplicationContext Spring du module simple-persist</title>

      <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
             http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"
    default-lazy-init="true"&gt;

    &lt;bean id="sessionFactory"
class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt;
        &lt;property name="annotatedClasses"&gt;
            &lt;list&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Atmosphere&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Condition&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Location&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Weather&lt;/value&gt;
                &lt;value&gt;org.sonatype.mavenbook.weather.model.Wind&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="hibernateProperties"&gt;
            &lt;props&gt;
                &lt;prop key="hibernate.show_sql"&gt;false&lt;/prop&gt;
                &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt;
                &lt;prop key="hibernate.transaction.factory_class"&gt;
                  org.hibernate.transaction.JDBCTransactionFactory
                &lt;/prop&gt;
                &lt;prop key="hibernate.dialect"&gt;
                  org.hibernate.dialect.HSQLDialect
                &lt;/prop&gt;
                &lt;prop key="hibernate.connection.pool_size"&gt;0&lt;/prop&gt;
                &lt;prop key="hibernate.connection.driver_class"&gt;
                  org.hsqldb.jdbcDriver
                &lt;/prop&gt;
                &lt;prop key="hibernate.connection.url"&gt;
                  jdbc:hsqldb:data/weather;shutdown=true
                &lt;/prop&gt;
                &lt;prop key="hibernate.connection.username"&gt;sa&lt;/prop&gt;
                &lt;prop key="hibernate.connection.password"&gt;&lt;/prop&gt;
                &lt;prop key="hibernate.connection.autocommit"&gt;true&lt;/prop&gt;
                &lt;prop key="hibernate.jdbc.batch_size"&gt;0&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="locationDAO" 
             class="org.sonatype.mavenbook.weather.persist.LocationDAO"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;
    
    &lt;bean id="weatherDAO" 
             class="org.sonatype.mavenbook.weather.persist.WeatherDAO"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;
 &lt;/beans&gt;</programlisting>
    </example>

    <para>Cet <classname>ApplicationContext</classname> définit plusieurs choses.
    Le bean <varname>sessionFactory</varname> est le bean par lequel les <acronym>DAO</acronym>s 
    pourront récupérer les <classname>Session</classname> Hibernate. Ce bean est une instance de la
    classe <classname>AnnotationSessionFactoryBean</classname> et fournit une liste
    d'<varname>annotatedClasses</varname>. Notez que cette liste de classes annotées est la liste
    des classes définies dans le module <varname>simple-model</varname>. Ensuite,
    la <varname>sessionFactory</varname> est configurée par l'intermédiaire d'une liste de propriétés
    de configuration Hibernate (<varname>hibernateProperties</varname>). Dans cet exemple, nous
    utilisons les propriétés Hibernate suivantes :</para>

    <variablelist>
      <varlistentry>
        <term><literal>hibernate.dialect</literal></term>

        <listitem>
          <para>Cette propriété permet de contrôler le <acronym>SQL</acronym> qui sera généré pour 
          notre base de données. Comme nous utilisons <acronym>HSQLDB</acronym>, nous choisissons
          le dialecte <classname>org.</classname><classname>hibernate.</classname><classname>dialect.</classname><classname>HSQLDialect</classname>.
          Hibernate possède nativement des dialectes pour la majorité des bases de données comme
          Oracle, MySQL, Postgres et SQL Server.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>hibernate.connection.*</literal></term>

        <listitem>
          <para>Dans cet exemple, nous configurons une connexion <acronym>JDBC</acronym> à partir de
          la configuration Spring. Nos applications sont configurées pour se lancer avec la base de
          données <acronym>HSQLDB</acronym> du répertoire <filename role="keep-together">./data/weather</filename>.
          Dans une vraie application d'entreprise, vous utiliseriez plutôt quelque chose comme
          <acronym>JNDI</acronym> pour externaliser la configuration de la base de données de votre
          code applicatif.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Dans la suite du fichier XML, sont définis les deux <acronym>DAO</acronym>s du module <varname>simple-persist</varname>.
    Chacun d'entre eux contient une référence vers la <varname>sessionFactory</varname> Hibernate que nous venons de définir.
    Comme l'<classname>ApplicationContext</classname> du module <varname>simple-weather</varname>,
    ce fichier <filename>applicationContext-persist.xml</filename> définit l'architecture du sous-module.
    Si vous travailliez avec un plus grand nombre de classes persistantes, vous pourriez trouver
    utile de les externaliser dans un <classname>ApplicationContext</classname> séparé.</para>

    <para>Il reste encore une dernière pièce du puzzle. Plus tard dans ce chapitre, nous verrons<indexterm>
        <primary>plugin Maven Hibernate3</primary>
      </indexterm><indexterm>
        <primary>plugin Hibernate3</primary>
      </indexterm> comment nous pouvons utiliser le plugin Maven Hibernate3 pour générer notre schéma 
      de base de données à partir des objets annotés du modèle. Pour cela, le plugin Maven Hibernate3
      a besoin de récupérer les paramètres de connexion <acronym>JDBC</acronym>, la liste des
      classes annotées et un autre fichier de configuration nommé<indexterm>
        <primary>fichier hibernate.cfg.xml</primary>
      </indexterm> <filename>hibernate.cfg.xml</filename> présent dans le répertoire
    <filename>src/main/resources</filename>. Le contenu de ce fichier (qui
    duplique une partie de la configuration du fichier <filename>applicationContext-persist.xml</filename>)
    nous permet l'utilisation du <phrase role="keep-together">plugin</phrase> Maven Hibernate3 pour générer le
    <acronym>DDL</acronym> (Data Definition Language) du schéma de la base de données. Consultez l'<xref linkend="ex-hibernate-cfg" />.</para>

    <example id="ex-hibernate-cfg">
      <title>Fichier hibernate.cfg.xml du module simple-persist</title>

      <programlisting language="xml">&lt;!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;
        
&lt;hibernate-configuration&gt;
  &lt;session-factory&gt;
        
    &lt;!-- dialecte SQL --&gt;
    &lt;property name="dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/property&gt;
    
    &lt;!-- Configuration des connexions --&gt;
    &lt;property name="connection.driver_class"&gt;org.hsqldb.jdbcDriver&lt;/property&gt;
    &lt;property name="connection.url"&gt;jdbc:hsqldb:data/weather&lt;/property&gt;
    &lt;property name="connection.username"&gt;sa&lt;/property&gt;
    &lt;property name="connection.password"&gt;&lt;/property&gt;
    &lt;property name="connection.shutdown"&gt;true&lt;/property&gt;
    
    &lt;!-- Pool de connexion JDBC (utilisation du built-in) --&gt;
    &lt;property name="connection.pool_size"&gt;1&lt;/property&gt;
    
    &lt;!-- Définit le scope des context Hibernate --&gt;
    &lt;property name="current_session_context_class"&gt;thread&lt;/property&gt;
    
    &lt;!-- Désactivation du cache de second niveau  --&gt;
    &lt;property name="cache.provider_class"&gt;
      org.hibernate.cache.NoCacheProvider
    &lt;/property&gt;
    
    &lt;!-- Affiche les requêtes sur stdout --&gt;
    &lt;property name="show_sql"&gt;true&lt;/property&gt;
    
    &lt;!-- Désactivation du batching, permet à HSQLDB de propager ses erreurs correctement. --&gt;
    &lt;property name="jdbc.batch_size"&gt;0&lt;/property&gt;
    
    &lt;!-- Liste de toutes les classes annontées --&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Atmosphere"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Condition"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Location"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Weather"/&gt;
    &lt;mapping class="org.sonatype.mavenbook.weather.model.Wind"/&gt;
        
  &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</programlisting>
    </example>

    <para>Les contenus de l'<xref linkend="ex-persist-spring" /> et de l'<xref linkend="ex-multimodule-web-spring-parent" /> sont redondants.
    Le <acronym>XML</acronym> de l'<classname>ApplicationContext</classname> Spring sera utilisé par l'application web et l'application en ligne de commande,
    le fichier <filename>hibernate.cfg.xml</filename> n'est présent que pour faire fonctionner le plugin Maven Hibernate3. 
    Plus tard dans ce chapitre, nous verrons comment utiliser ce fichier <filename>hibernate.cfg.xml</filename> et le plugin Maven Hibernate3
    pour générer le schéma de la base de données basé sur les objets annotés du projet <varname>simple-model</varname>.
    Ce fichier <filename>hibernate.cfg.xml</filename> configure les propriétés des connexions <acronym>JDBC</acronym> 
    et énumère la liste des objets annotés.</para>
  </section>

  <section id="multimodule-web-spring-sect-simple-web">
    <title>Le module simple-webapp</title>

    <para>L'application Web est définie dans le module <varname>simple-webapp</varname><indexterm class="startofrange" id="enterprise6a">
        <primary>projet multimodule (exemple)</primary>
        <secondary>projet d'entreprise multimodule</secondary>
        <tertiary>Simple Application Web</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise6b">
        <primary>Applications Web</primary>
        <secondary>exemple de projet d'entreprise multimodule</secondary>
        <tertiary>Simple Application Web</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise6c">
        <primary>projet d'entreprise, multimodule (exemple)</primary>
        <secondary>Simple Application Web</secondary>
      </indexterm>. Ce projet va définir deux contrôleurs Spring <acronym>MVC</acronym> : 
    <classname>WeatherController</classname> et <classname role="keep-together">HistoryController</classname>. 
    Ces deux contrôleurs vont référencer les composants des modules <varname>simple-weather</varname> et <varname>simple-persist</varname>.
    Le conteneur Spring est configuré dans le fichier <filename>web.xml</filename> de l'application web, celui-ci réfère le fichier
    <filename>applicationContext-weather.xml</filename> du module <varname role="keep-together">simple-weather</varname> et le fichier
    <filename>applicationContext-persist.xml</filename> du module <varname>simple-persist</varname>.
    L'architecture des composants de cette application web simple est montrée sur la <xref linkend="fig-web-components" />.</para> 

    <figure id="fig-web-components">
      <title>Contrôleurs Spring MVC référençant les modules simple-weather et simple-persist.</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata fileref="figs/web/multimodule-web-web-spring.png"  />
        </imageobject>

        <imageobject role="print">
          <imagedata fileref="figs/print/multimodule-web-web-spring.pdf" format="PDF"  align="center" scalefit="0" width="100%" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Le POM du module <varname>simple-webapp</varname> est affiché dans l'<xref linkend="example_pom-for-simple-webapp" />.</para>

    <example id="example_pom-for-simple-webapp">
      <title>POM du module simple-webapp</title>

      <programlisting>&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.multispring&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;

  &lt;artifactId&gt;simple-webapp&lt;/artifactId&gt;
  &lt;packaging&gt;war&lt;/packaging&gt;
  &lt;name&gt;Simple Web Application&lt;/name&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt; <co id="co-springweb-1" linkends="coref-springweb-1" />
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
      &lt;version&gt;2.4&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.multispring&lt;/groupId&gt;
      &lt;artifactId&gt;simple-weather&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.multispring&lt;/groupId&gt;
      &lt;artifactId&gt;simple-persist&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring&lt;/artifactId&gt;
      &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;
      &lt;artifactId&gt;velocity&lt;/artifactId&gt;
      &lt;version&gt;1.5&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;build&gt;
    &lt;finalName&gt;simple-webapp&lt;/finalName&gt;
    &lt;plugins&gt;
      &lt;plugin&gt; <co id="coDef-spring-web-2" linkends="coRef-spring-web-2" />
        &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;
        &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;
        &lt;dependencies&gt;<co id="coDef-spring-web-3"
          linkends="coRef-spring-web-3" />
          &lt;dependency&gt;
            &lt;groupId&gt;hsqldb&lt;/groupId&gt;
            &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
            &lt;version&gt;1.8.0.7&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;        
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; <co
          id="coDef-spring-web-4" linkends="coRef-spring-web-4" />
        &lt;artifactId&gt;hibernate3-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.0&lt;/version&gt;
        &lt;configuration&gt;
          &lt;components&gt;
            &lt;component&gt;
              &lt;name&gt;hbm2ddl&lt;/name&gt;
              &lt;implementation&gt;annotationconfiguration&lt;/implementation&gt; <co
          id="coDef-spring-web-5" linkends="coRef-spring-web-5" />
            &lt;/component&gt;
          &lt;/components&gt;
        &lt;/configuration&gt;
        &lt;dependencies&gt;
          &lt;dependency&gt;
            &lt;groupId&gt;hsqldb&lt;/groupId&gt;
            &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
            &lt;version&gt;1.8.0.7&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;        
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>Au fur et à mesure que nous avançons dans ce livre, les exemples deviennent de plus en
    plus substantiels. Vous avez d'ailleurs probablement noté que le fichier
    <filename>pom.xml</filename> commence à devenir volumineux.
    Dans ce POM, nous configurons quatre dépendances et deux plugins.
    Regardons ce POM en détail et étendons-nous sur certains des points de configuration importants :</para>

    <calloutlist>
      <callout arearefs="co-springweb-1" id="coref-springweb-1">
        <para>Ce projet <varname>simple-webapp</varname> définit quatre dépendances :
        les spécifications Servlet 2.4, la bibliothèque de services simple-weather, 
        la bibliothèque de persistance simple-persist et l'intégralité du Spring Framework 2.0.7.</para>
      </callout>

      <callout arearefs="coDef-spring-web-2" id="coRef-spring-web-2">
        <para>Le plugin Maven Jetty est utilisé de la manière la plus simple qui soit dans<indexterm>
            <primary>plugin Maven Jetty</primary>
          </indexterm><indexterm>
            <primary>Jetty plugin</primary>
          </indexterm> ce projet.  
          Nous ajoutons simplement la balise <literal>plugin</literal> qui fait référence aux bons <literal>groupId</literal> et <literal>artifactId</literal>.
         Le fait que ce plugin soit facile à configurer signifie que les développeurs du plugin ont fait du bon travail
        en fournissant les valeurs par défaut adéquates pour la plupart des cas. 
        Si vous avez besoin de surcharger cette configuration, vous pouvez le faire en ajoutant une balise <literal>configuration</literal>.</para>  
      </callout>

      <callout arearefs="coDef-spring-web-3" id="coRef-spring-web-3">
        <para>Dans notre configuration de build, nous allons configurer le plugin Maven Hibernate3 pour qu'il utilise une instance de la base de données embarquée HSQLDB.
        Pour que le plugin Maven Hibernate3 arrive à se connecter à la base, il doit référencer le driver JDBC d'HSQLDB dans son classpath.
        Pour rendre cette dépendance disponible au plugin, nous ajoutons sa déclaration directement dans la déclaration du <sgmltag>plugin</sgmltag>.  
        Ici, nous référençons hsqldb:hsqldb:1.8.0.7. 
        Le plugin Hibernate a également besoin des drivers JDBC pour créer cette base de données, nous avons donc ajouté cette dépendance dans sa configuration.</para>
      </callout>

      <callout arearefs="coDef-spring-web-4" id="coRef-spring-web-4">
        <para>C'est à partir de l'utilisation du plugin Maven Hibernate3 que ce POM devient le plus<indexterm>
            <primary>plugin Hibernate Maven</primary>
          </indexterm><indexterm>
            <primary>plugin Hibernate</primary>
          </indexterm> intéressant. 
        Dans la section suivante, nous allons exécuter le goal <literal>hbm2ddl</literal> pour générer une base de données HSQLDB.
        Nous avons inclus dans ce <filename>pom.xml</filename> une référence vers la version 2.0 du <literal>hibernate3-maven-plugin</literal> récupérable à partir du dépôt Codehaus Mojo.</para>
      </callout>

      <callout arearefs="coDef-spring-web-5" id="coRef-spring-web-5">
        <para>Le plugin Maven Hibernate3 dispose de plusieurs moyens pour récupérer le mapping Hibernate en fonction du cas d'utilisation.
        Si vous utilisez des fichiers XML pour le Mapping Hibernate (<filename>.hbm.xml</filename>), 
        et que vous voulez générer les classes de votre modèle par l'intermédiaire du goal <literal>hbm2java</literal>,
        vous devez indiquer votre implémentation à la configuration.
        Si vous utilisez le plugin Hibernate3 en reverse engineering pour générer les fichiers <filename>.hbm.xml</filename> 
        et les objets du modèle à partir d'une base de données existante, vous voudrez utiliser l'implémentation <literal>jdbcconfiguration</literal>.   
        Dans notre exemple, nous utilisons simplement les objets annotés du modèle pour générer la base de données.        
        En d'autres termes, nous avons notre mapping Hibernate, mais nous n'avons pas encore de base de données.
        Pour ce scénario, <literal>annotationconfiguration</literal> est l'implémentation la plus appropriée.
        Le plugin Maven Hibernate3 sera plus largement détaillé dans la <xref linkend="multimodule-web-spring-sect-spring-running-web" />.</para>
      </callout>
    </calloutlist>

    <note>
      <para>Une erreur classique consiste à utiliser la balise <sgmltag>extensions</sgmltag> de la configuration pour ajouter des dépendances nécessaires à un plugin.
      Il est fortement découragé de procéder de la sorte car les extensions peuvent polluer le classpath de votre projet, et provoquer des effets de bord désagréables.
      De plus, le comportement des extensions a été modifié depuis la version 2.1 de Maven.
      Le seul usage correct de la balise <sgmltag>extensions</sgmltag> est l'ajout d'implémentations complémentaires.</para>
    </note>

    <para>Regardons maintenant les deux contrôleurs Spring MVC, chacun d'entre eux référence des beans déclarés dans les <varname>simple-weather</varname> et <varname>simple-persist</varname>.</para>

    <example>
      <title>WeatherController du module simple-webapp</title>

      <programlisting language="java">package org.sonatype.mavenbook.web;

import org.sonatype.mavenbook.weather.model.Weather;
import org.sonatype.mavenbook.weather.persist.WeatherDAO;
import org.sonatype.mavenbook.weather.WeatherService;
import javax.servlet.http.*;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

public class WeatherController implements Controller {

  private WeatherService weatherService;
  private WeatherDAO weatherDAO;

  public ModelAndView handleRequest(HttpServletRequest request,
      HttpServletResponse response) throws Exception {

    String zip = request.getParameter("zip");
    Weather weather = weatherService.retrieveForecast(zip);
    weatherDAO.save(weather);
    return new ModelAndView("weather", "weather", weather);
  }

  public WeatherService getWeatherService() {
    return weatherService;
  }

  public void setWeatherService(WeatherService weatherService) {
    this.weatherService = weatherService;
  }

  public WeatherDAO getWeatherDAO() {
    return weatherDAO;
  }

  public void setWeatherDAO(WeatherDAO weatherDAO) {
    this.weatherDAO = weatherDAO;
  }
}</programlisting>
    </example>

    <para><varname>WeatherController</varname> implémente l'interface <classname>Controller</classname> qui assure la présence d'une méthode
    <methodname>handleRequest()</methodname> dont la signature est montrée dans cet exemple.
    Si vous regardez le corps de cette méthode, vous constaterez que celle-ci invoque la méthode <methodname>retrieveForecast()</methodname> du service <varname>weatherService</varname>. 
    Contrairement au chapitre précédent, dans lequel une servlet instancie la classe <classname>WeatherService</classname>, 
    le <classname>WeatherController</classname> est un bean contenant une propriété <varname>weatherService</varname>.  
    Le conteneur Spring IoC a la responsabilité de charger le service <varname>weatherService</varname> dans le contrôleur.
    Notez également que nous n'utilisons pas le <classname role="keep-together">WeatherFormatter</classname> dans ce contrôleur.
    Au lieu de cela, nous passons l'objet <classname>Weather</classname> retourné par la méthode <methodname>retrieveForecast()</methodname> au constructeur de la classe <classname>ModelAndView</classname>.
    Cette classe <classname>ModelAndView</classname> est utilisée pour effectuer le rendu du<indexterm>
        <primary>template Velocity</primary>
      </indexterm> template Velocity. Ce template disposera d'une référence sur la variable <varname>\${weather}</varname> contenant ce même objet. 
    Le template  <filename>weather.vm</filename> se trouve dans le répertoire <filename>src/main/webapp/WEB-INF/vm</filename>, celui-ci est affiché dans l'<xref linkend="ex-weather-vm" />.</para>

    <para>Dans ce <classname>WeatherController</classname>, avant d'effectuer le rendu des prévisions météo, nous passons l'objet <classname>Weather</classname>
    retourné par le service <classname>WeatherService</classname> à la méthode <methodname>save()</methodname> de la classe <classname>WeatherDAO</classname>.
    Cet objet est sauvegardé par Hibernate en base de données.
    Plus tard, dans le contrôleur <classname>HistoryController</classname>, nous verrons comment récupérer l'historique de ces prévisions météorologiques.</para>

    <example id="ex-weather-vm">
      <title>Modèle weather.vm interprété par le WeatherController</title>

      <programlisting language="xml">&lt;b&gt;Current Weather Conditions for:
  \${weather.location.city}, \${weather.location.region}, 
  \${weather.location.country}&lt;/b&gt;&lt;br/&gt;
  
&lt;ul&gt;
  &lt;li&gt;Temperature: \${weather.condition.temp}&lt;/li&gt;
  &lt;li&gt;Condition: \${weather.condition.text}&lt;/li&gt;
  &lt;li&gt;Humidity: \${weather.atmosphere.humidity}&lt;/li&gt;
  &lt;li&gt;Wind Chill: \${weather.wind.chill}&lt;/li&gt;
  &lt;li&gt;Date: \${weather.date}&lt;/li&gt;
&lt;/ul&gt;
</programlisting>
    </example>

    <para>La syntaxe de ce modèle Velocity est rapide à expliquer, les variables sont référencées 
    par l'intermédiaire de la notation <code>\${}</code>. L'expression entre les accolades fait
    référence à une propriété, ou à une propriété d'une propriété de la
    variable <varname>weather</varname> passée à ce modèle par
    le <classname>WeatherController</classname>.</para>

    <para>Le contrôleur <classname>HistoryController</classname> est utilisé pour récupérer la liste 
    des prévisions météorologiques les plus récentes parmi celles demandées par le <classname>WeatherController</classname>.
    Chaque fois que nous récupérons une prévision dans le <classname>WeatherController</classname>, celui-ci enregistre l'objet <classname>Weather</classname> récupéré dans la base de données via le <classname>WeatherDAO</classname>.      
    Ce DAO utilise ensuite Hibernate pour transformer l'objet <classname>Weather</classname> en une série de lignes dans un ensemble de tables de la base de données.
    Le contrôleur <classname>HistoryController</classname> est affiché dans l'<xref linkend="ex-spring-history" />.</para>

    <example id="ex-spring-history">
      <title>HistoryController du module simple-web</title>

      <programlisting language="java">package org.sonatype.mavenbook.web;

import java.util.*;
import javax.servlet.http.*;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;
import org.sonatype.mavenbook.weather.model.*;
import org.sonatype.mavenbook.weather.persist.*;

public class HistoryController implements Controller {

  private LocationDAO locationDAO;
  private WeatherDAO weatherDAO;

  public ModelAndView handleRequest(HttpServletRequest request,
      HttpServletResponse response) throws Exception {
    String zip = request.getParameter("zip");
    Location location = locationDAO.findByZip(zip);
    List&lt;Weather&gt; weathers = weatherDAO.recentForLocation( location );

    Map&lt;String,Object&gt; model = new HashMap&lt;String,Object&gt;();
    model.put( "location", location );
    model.put( "weathers", weathers );

    return new ModelAndView("history", model);
  }

  public WeatherDAO getWeatherDAO() {
    return weatherDAO;
  }

  public void setWeatherDAO(WeatherDAO weatherDAO) {
    this.weatherDAO = weatherDAO;
  }

  public LocationDAO getLocationDAO() {
    return locationDAO;
  }

  public void setLocationDAO(LocationDAO locationDAO) {
    this.locationDAO = locationDAO;
  }
}</programlisting>
    </example>

    <para>Le contrôleur <classname>HistoryController</classname> est chargé avec les deux <acronym>DAO</acronym>s 
    du module <varname>simple-persist</varname>.
    Les instances de ces deux <acronym>DAO</acronym>s sont portées par les propriétés <classname>WeatherDAO</classname> et <classname>LocationDAO</classname>.     
    Le but de l'<classname>HistoryController</classname> est de récupérer une <classname>List</classname> d'objets <classname>Weather</classname> en fonction du paramètre <varname>zip</varname>. 
    Quand le <classname>WeatherDAO</classname> enregistre un objet <classname>Weather</classname> dans la base de données,  
    il ne se contente pas de stocker le code postal, il enregistre un objet <classname>Location</classname> qui est lié à l'objet <classname>Weather</classname> du module <varname>simple-model</varname>.   
    Pour récupérer la <classname>List</classname> des objets <classname>Weather</classname>, l'<classname>HistoryController</classname> commence par récupérer
    l'objet <classname>Location</classname> qui correspond au paramètre <varname>zip</varname> représentant le code postal.
    Pour cela, on invoque la méthode <methodname>findByZip()</methodname> du DAO <classname>LocationDAO</classname>.</para>       

    <para>Une fois cet objet <classname>Location</classname> récupéré, l'<classname>HistoryController</classname> essayera de récupérer les objets <classname>Weather</classname> les plus récents associés à cette <classname>Location</classname>.  
    Une fois la <classname>List&lt;Weather&gt;</classname> récupérée, une <classname>HashMap</classname> est créée contenant les deux variables
    du modèle Velocity <filename>history.vm</filename> de l'<xref linkend="ex-spring-history-velocity" />.</para>

    <example id="ex-spring-history-velocity">
      <title>Modèle history.vm utilisé par l'HistoryController</title>

      <programlisting language="java">&lt;b&gt;
Weather History for: \${location.city}, \${location.region}, \${location.country}
&lt;/b&gt;
&lt;br/&gt;
  
#foreach( $weather in $weathers )
  &lt;ul&gt;
    &lt;li&gt;Temperature: $weather.condition.temp&lt;/li&gt;
    &lt;li&gt;Condition: $weather.condition.text&lt;/li&gt;
    &lt;li&gt;Humidity: $weather.atmosphere.humidity&lt;/li&gt;
    &lt;li&gt;Wind Chill: $weather.wind.chill&lt;/li&gt;
    &lt;li&gt;Date: $weather.date&lt;/li&gt;
  &lt;/ul&gt;
#end
</programlisting>
    </example>

    <para>Le modèle <filename>history.vm</filename> du dossier <filename>src/main/webapp/WEB-INF/vm</filename> référence la
    variable <varname>location</varname> pour afficher les prévisions météo provenant du <classname>WeatherDAO</classname>.
    Ce template utilise une structure de contrôle Velocity, <code>#foreach</code>, pour itérer sur chaque élément de la variable <varname>weathers</varname>.
    Chaque élément de la liste <varname>weathers</varname> est assigné à une variable nommée <varname>weather</varname>. 
    Le cœur de la boucle, entre <code>#foreach</code> et <code>#end</code>, permet d'afficher les informations de chaque prévision.</para> 

    <para>Nous venons de voir les implémentations de nos deux <classname>Controller</classname>. 
    Nous venons également de voir comment ils référencent les beans des modules <varname>simple-weather</varname> et <varname>simple-persist</varname>.
    Ces <classname>Controller</classname> répondent aux requêtes <acronym>HTTP</acronym> par l'intermédiaire de mystérieux systèmes qui savent comment effectuer le rendu de templates Velocity.
    Toute la magie est configurée dans l'<classname>ApplicationContext</classname> Spring du fichier <filename>src/main/webapp/WEB-INF/weather-servlet.xml</filename>.
    Ce <acronym>XML</acronym> configure les contrôleurs et référence d'autres beans managés par Spring.
    Il est chargé par un <classname>ServletContextListener</classname> qui est configuré pour charger également les fichiers <filename>applicationContext-weather.xml</filename> et <filename>applicationContext-persist.xml</filename> à partir du classpath.
    Regardons de plus près le fichier <filename>weather-servlet.xml</filename> de l'<xref linkend="ex-spring-weather-servlet" />.</para>

    <example id="ex-spring-weather-servlet">
      <title>Configuration des contrôleurs Spring du fichier weather-servlet.xml</title>

      <programlisting>&lt;beans&gt;  
     &lt;bean id="weatherController" <co id="coDef-weather-servlet-1"
          linkends="coRef-weather-servlet-1" />
           class="org.sonatype.mavenbook.web.WeatherController"&gt;
       &lt;property name="weatherService" ref="weatherService"/&gt;
       &lt;property name="weatherDAO" ref="weatherDAO"/&gt;
     &lt;/bean&gt;

     &lt;bean id="historyController" 
           class="org.sonatype.mavenbook.web.HistoryController"&gt;
       &lt;property name="weatherDAO" ref="weatherDAO"/&gt;
       &lt;property name="locationDAO" ref="locationDAO"/&gt;
     &lt;/bean&gt;

     &lt;!-- you can have more than one handler defined --&gt;
     &lt;bean id="urlMapping" 
     class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
          &lt;property name="urlMap"&gt;
               &lt;map&gt;
                    &lt;entry key="/weather.x"&gt; <co
          id="coDef-weather-servlet-2" linkends="coRef-weather-servlet-2" />
                         &lt;ref bean="weatherController" /&gt;
                    &lt;/entry&gt;
                    &lt;entry key="/history.x"&gt;
                         &lt;ref bean="historyController" /&gt;
                    &lt;/entry&gt;
               &lt;/map&gt;
          &lt;/property&gt;
     &lt;/bean&gt;


     &lt;bean id="velocityConfig" <co id="coDef-weather-servlet-3"
          linkends="coRef-weather-servlet-3" />
   class="org.springframework.web.servlet.view.velocity.VelocityConfigurer"&gt;
       &lt;property name="resourceLoaderPath" value="/WEB-INF/vm/"/&gt;
     &lt;/bean&gt;

     &lt;bean id="viewResolver" <co id="coDef-weather-servlet-4"
          linkends="coRef-weather-servlet-4" />
   class="org.springframework.web.servlet.view.velocity.VelocityViewResolver"&gt;
       &lt;property name="cache" value="true"/&gt;
       &lt;property name="prefix" value=""/&gt;
       &lt;property name="suffix" value=".vm"/&gt;
       &lt;property name="exposeSpringMacroHelpers" value="true"/&gt;
     &lt;/bean&gt;
&lt;/beans&gt;
</programlisting>
    </example>

    <calloutlist>
      <callout arearefs="coDef-weather-servlet-1" id="coRef-weather-servlet-1">
        <para>Le fichier <filename>weather-servlet.xml</filename> définit deux contrôleurs Spring.
        <varname>weatherController</varname> a deux propriétés qui référencent <varname>weatherService</varname> et <varname>weatherDAO</varname>. 
        <varname>historyController</varname> référence les beans <varname>weatherDAO</varname> et <varname>locationDAO</varname>. 
        Quand l'<classname>ApplicationContext</classname> est créé, il est créé dans un environnement qui donne accès aux 
        <classname>ApplicationContext</classname>s définit dans les fichiers <varname>simple-persist</varname> et <varname>simple-weather</varname>. 
        Dans l'<xref linkend="ex-spring-web-xml" /> vous pouvez voir comment Spring est configuré pour fusionner plusieurs composants contenant des fichiers de configuration Spring différents.</para>
      </callout>

      <callout arearefs="coDef-weather-servlet-2" id="coRef-weather-servlet-2">
        <para>Le bean <varname>urlMapping</varname> définit les formats des <acronym>URL</acronym> pouvant invoquer les contrôleurs <classname>WeatherController</classname> et <classname>HistoryController</classname>.
        Dans cet exemple, nous utilisons le <classname>SimpleUrlHandlerMapping</classname> et 
        associons <filename>/weather.x</filename> au <classname>WeatherController</classname> et
        <filename>/history.x</filename> à l'<classname>HistoryController</classname>.</para>
      </callout>

      <callout arearefs="coDef-weather-servlet-3" id="coRef-weather-servlet-3">
        <para>Comme nous utilisons le moteur de template Velocity, nous avons besoin de fournir
        quelques options de configuration spécifiques. Dans le bean <varname>velocityConfig</varname>,
        nous demandons à Velocity de rechercher toutes les modèles présents dans le
        répertoire <filename>/WEB-INF/vm</filename>.</para>
      </callout>

      <callout arearefs="coDef-weather-servlet-4" id="coRef-weather-servlet-4">
        <para>Enfin, le <varname>viewResolver</varname> est configuré avec la classe 
        <classname>VelocityViewResolver</classname>. Il existe un bon nombre d'implémentations
        du <classname>ViewResolver</classname> dans Spring, du standard ViewResolver pour afficher
        une <acronym>JSP</acronym> ou <acronym>JSTL</acronym> au ViewResolver capable d'effectuer
        le rendu de modèles Freemarker. Dans cet exemple, nous configurons le moteur de template
        Velocity et modifions les préfixes et suffixes par défaut pour modifier automatiquement les
        noms des modèles passés aux objets <classname>ModelAndView</classname>.</para>
      </callout>
    </calloutlist>

    <para>Pour finir, le projet <varname>simple-webapp</varname> possède un fichier <filename>web.xml</filename> qui fournit la configuration de base à l'application web. 
    Le fichier <filename>web.xml</filename> est affiché dans l'<xref linkend="ex-spring-web-xml" />.</para>

    <example id="ex-spring-web-xml">
      <title>web.xml du module simple-webapp</title>

      <programlisting id="ex-spring-webxml">&lt;web-app id="simple-webapp" version="2.4" 
     xmlns="http://java.sun.com/xml/ns/j2ee" 
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
     xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee 
                         http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;
  &lt;display-name&gt;Simple Web Application&lt;/display-name&gt;
  
  &lt;context-param&gt; <co id="coDef-spring-webx-1"
          linkends="coRef-spring-webx-1" />
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;
      classpath:applicationContext-weather.xml
      classpath:applicationContext-persist.xml
    &lt;/param-value&gt;
  &lt;/context-param&gt;
  
  &lt;context-param&gt; <co id="coDef-spring-webx-2"
          linkends="coRef-spring-webx-2" />
    &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/log4j.properties&lt;/param-value&gt;
  &lt;/context-param&gt;
  
  &lt;listener&gt; <co id="coDef-spring-webx-3" linkends="coRef-spring-webx-3" />
    &lt;listener-class&gt;
      org.springframework.web.util.Log4jConfigListener
    &lt;/listener-class&gt;
  &lt;/listener&gt;
  
  &lt;listener&gt;
    &lt;listener-class&gt; <co id="coDef-spring-webx-4"
          linkends="coRef-spring-webx-4" />
     org.springframework.web.context.ContextLoaderListener
    &lt;/listener-class&gt;
  &lt;/listener&gt;
  
  &lt;servlet&gt; <co id="coDef-spring-webx-5" linkends="coRef-spring-webx-5" />
    &lt;servlet-name&gt;weather&lt;/servlet-name&gt;
    &lt;servlet-class&gt;
      org.springframework.web.servlet.DispatcherServlet
    &lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  
  &lt;servlet-mapping&gt; <co id="coDef-spring-webx-6"
          linkends="coRef-spring-webx-6" />
    &lt;servlet-name&gt;weather&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.x&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</programlisting>
    </example>

    <calloutlist>
      <callout arearefs="coDef-spring-webx-1" id="coRef-spring-webx-1">
        <para>Voici un peu de magie qui nous permet la réutilisation des fichiers <filename>applicationContext-weather.xml</filename> et <filename>applicationContext-persist.xml</filename> dans ce projet.
        Le <varname>contextConfigLocation</varname> est utilisé par <classname>ContextLoaderListener</classname> pour créer un <classname>ApplicationContext</classname>. 
        Quand la servlet <varname>weather</varname> est créée, le fichier <filename>weather-servlet.xml</filename> de l'<xref linkend="ex-spring-weather-servlet" /> évalue l'<classname>ApplicationContext</classname> créé à partir du  <varname>contextConfigLocation</varname>. 
        Par ce moyen, vous pouvez définir un ensemble de beans dans un autre projet et les référencer par l'intermédiaire du classpath.
        Comme les <acronym>JAR</acronym>s des modules <varname>simple-persist</varname> et <varname>simple-weather</varname> seront placés dans 
        <filename>WEB-INF/lib</filename>, tout ce que nous avons à faire est d'utiliser le préfixe <literal>classpath:</literal> pour référencer ces fichiers.
        (Une autre option consisterait à copier ces fichiers dans <filename>/WEB-INF</filename> et de les référencer avec quelque chose ressemblant à <filename>/WEB-INF/applicationContext-persist.xml</filename>).</para>
      </callout>

      <callout arearefs="coDef-spring-webx-2" id="coRef-spring-webx-2">
        <para>Le paramètre <varname>log4jConfigLocation</varname> est utilisé par le <classname>Log4JConfigListener</classname> pour savoir où chercher le fichier de configuration de logging Log4J.  
        Dans cet exemple, nous demandons à Log4J de regarder dans le fichier <filename>/WEB-INF/log4j.properties</filename>.</para>
      </callout>

      <callout arearefs="coDef-spring-webx-3" id="coRef-spring-webx-3">
        <para>Cela assure que le système Log4J est configuré lors du démarrage de l'application.
        Il est important de mettre ce <classname>Log4JConfigListener</classname> avant le <classname>ContextLoaderListener</classname>.
        Dans le cas contraire, vous pourriez manquer d'importants messages indiquant un éventuel problème survenu lors du démarrage d'application.
        Si vous avez un ensemble particulièrement grand de beans gérés par Spring et que l'un d'entre eux n'arrive pas à s'initialiser au démarrage de l'application, votre application ne se lancera pas.
        Si vous avez initialisé votre système de log avant le démarrage de Spring, vous aurez la chance de récupérer une alerte ou un message d'erreur.
        Au contraire, si vous n'avez pas initialisé le système de log avant le démarrage de Spring, préparez vous à naviguer dans le noir pour comprendre pourquoi votre application refuse de démarrer.</para>
      </callout>

      <callout arearefs="coDef-spring-webx-4" id="coRef-spring-webx-4">
        <para>Le <classname>ContextLoaderListener</classname> est essentiel pour le conteneur Spring.
        Quand l'application démarre, ce listener construit un <classname>ApplicationContext</classname> grâce au paramètre <varname>contextConfigLocation</varname>.</para>
      </callout>

      <callout arearefs="coDef-spring-webx-5" id="coRef-spring-webx-5">
        <para>Nous définissons un <classname>DispatcherServlet</classname> de Spring <acronym>MVC</acronym> nommé <varname>weather</varname>.
        Cela forcera Spring à regarder dans le fichier <filename>/WEB-INF/weather-servlet.xml</filename>. 
        Vous pouvez avoir autant de <classname>DispatcherServlet</classname> que vous le désirez,
        une <classname>DispatcherServlet</classname> peut contenir un ou plusieurs <classname>Controller</classname> Spring <acronym>MVC</acronym>.</para>
      </callout>

      <callout arearefs="coDef-spring-webx-6" id="coRef-spring-webx-6">
        <para>Toutes les requêtes terminant par <filename>.x</filename> seront routées vers la servlet <varname>weather</varname>. 
        Notez que l'extension <filename>.x</filename> n'a pas de signification particulière, c'est un choix arbitraire, il vous est possible de choisir n'importe quel format pour vos <acronym>URL</acronym>s.</para>
      </callout>
    </calloutlist>
  </section>

  <section id="multimodule-web-spring-sect-spring-running-web">
    <title>Exécution de l'application web</title>

    <para>Pour exécuter l'application web, vous devez tout d'abord construire votre projet multimodule 
    dans son intégralité et ensuite construire la base de données<indexterm class="startofrange" id="enterprise7a">
        <primary>projet multimodule (exemple)</primary>
        <secondary>projet d'entreprise multimodule</secondary>
        <tertiary>Exécution de l'Application Web</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise7b">
        <primary>Applications Web</primary>
        <secondary>exemple de projet d'entreprise multimodule</secondary>
        <tertiary>Exécution de l'Application Web</tertiary>
      </indexterm><indexterm class="startofrange" id="enterprise7c">
        <primary>projet d'entreprise, multimodule (exemple)</primary>
        <secondary>Exécution de l'Application Web</secondary>
      </indexterm><indexterm>
        <primary>plugin Maven Hibernate3</primary>
        <secondary>construire une base de données en utilisant</secondary>
      </indexterm><indexterm>
        <primary>plugin Hibernate3</primary>
        <secondary>construire une base de données en utilisant</secondary>
      </indexterm> en utilisant le plugin Hibernate3. 
    D'abord, exécutez la commande <command>mvn clean install</command> à partir du répertoire du projet de plus haut niveau <filename>simple-parent</filename> :</para>

    <screen>$ <command>mvn clean install</command></screen>

    <para>L'exécution de la commande <command>mvn clean install</command> dans le répertoire de plus haut niveau de votre projet installera tous ces modules dans votre dépôt local.
    Vous devez faire ceci avant de construire la base de données du projet <varname>simple-webapp</varname>.
    Pour construire la base de données à partir du projet <varname>simple-webapp</varname>, exécutez la commande suivante à partir du répertoire du projet <varname>simple-webapp</varname> : </para>  

    <screen>$ <command>mvn hibernate3:hbm2ddl</command>
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'hibernate3'.
[INFO] org.codehaus.mojo: checking for updates from central
[INFO] ------------------------------------------------------------------------
[INFO] Building Multi-Spring Chapter Simple Web Application
[INFO]    task-segment: [hibernate3:hbm2ddl]
[INFO] ------------------------------------------------------------------------
[INFO] Preparing hibernate3:hbm2ddl
...
10:24:56,151  INFO org.hibernate.tool.hbm2ddl.SchemaExport - export complete
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
</screen>

    <para>Une fois cela fait, vous devriez avoir un répertoire <filename>\${basedir}/data</filename> qui contient la base de données HSQLDB. 
     Vous pouvez démarrer l'application web avec la commande suivante :</para>

    <screen>$ <command>mvn jetty:run</command>
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'jetty'.
[INFO] ------------------------------------------------------------------------
[INFO] Building Multi-Spring Chapter Simple Web Application
[INFO]    task-segment: [jetty:run]
[INFO] ------------------------------------------------------------------------
[INFO] Preparing jetty:run
...
[INFO] [jetty:run]
[INFO] Configuring Jetty for project: 
Multi-Spring Chapter Simple Web Application
...
[INFO] Context path = /simple-webapp
[INFO] Tmp directory =  determined at runtime
[INFO] Web defaults = org/mortbay/jetty/webapp/webdefault.xml
[INFO] Web overrides =  none
[INFO] Starting jetty 6.1.7 ...
2008-03-25 10:28:03.639::INFO:  jetty-6.1.7
...
2147 INFO  DispatcherServlet  - FrameworkServlet 'weather': \
           initialization completed in 1654 ms
2008-03-25 10:28:06.341::INFO:  Started SelectChannelConnector@0.0.0.0:8080
[INFO] Started Jetty Server
</screen>

    <para>Une fois que Jetty est démarré, vous pouvez lancer votre navigateur et ouvrir la page  
    <ulink url="http://localhost:8080/simple-webapp/weather.x?zip=60202">http://localhost:8080/simple-webapp/weather.x?zip=60202</ulink>.
    Vous devriez y voir les prévisions météorologiques d'Evanston (Illinois).
    Modifiez le code postal pour obtenir votre propre rapport de prévisions.</para>

    <screen>Current Weather Conditions for: Evanston, IL, US

    * Temperature: 42
    * Condition: Partly Cloudy
    * Humidity: 55
    * Wind Chill: 34
    * Date: Tue Mar 25 10:29:45 CDT 2008
</screen>
  </section>

  <section id="multimodule-web-spring-sect-simple-command">
    <title>Le module de ligne de commande</title>

    <para>Le projet <varname>simple-command</varname> est la version ligne de commande du
    projet <varname>simple-webapp</varname>. Cet utilitaire possède donc les mêmes
    dépendances : <varname>simple-persist</varname> et <varname>simple-weather</varname>. Au lieu
    d'interagir avec l'application par l'intermédiaire d'un navigateur web, vous pourrez exécuter
    cet utilitaire à partir de la ligne de commande.</para>

    <figure id="fig-multi-spring-command">
      <title>L'application en ligne de commande référence simple-weather et simple-persist</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata fileref="figs/web/multimodule-web-command-spring.png" />
        </imageobject>

        <imageobject role="print">
          <imagedata fileref="figs/print/multimodule-web-command-spring.pdf" format="PDF"  align="center" scalefit="0" width="100%" />
        </imageobject>
      </mediaobject>
    </figure>

    <example>
      <title>POM du module simple-command</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.multispring&lt;/groupId&gt;
    &lt;artifactId&gt;simple-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
  &lt;/parent&gt;

  &lt;artifactId&gt;simple-command&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;name&gt;Simple Command Line Tool&lt;/name&gt;

  &lt;build&gt;
    &lt;finalName&gt;\${project.artifactId}&lt;/finalName&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;source&gt;1.5&lt;/source&gt;
          &lt;target&gt;1.5&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
       &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;descriptorRefs&gt;
            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
          &lt;/descriptorRefs&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
        &lt;artifactId&gt;hibernate3-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.1&lt;/version&gt;
        &lt;configuration&gt;
          &lt;components&gt;
            &lt;component&gt;
              &lt;name&gt;hbm2ddl&lt;/name&gt;
              &lt;implementation&gt;annotationconfiguration&lt;/implementation&gt;
            &lt;/component&gt;
          &lt;/components&gt;
        &lt;/configuration&gt;
        &lt;dependencies&gt;
          &lt;dependency&gt;
            &lt;groupId&gt;hsqldb&lt;/groupId&gt;
            &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
            &lt;version&gt;1.8.0.7&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;           
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.multispring&lt;/groupId&gt;
      &lt;artifactId&gt;simple-weather&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.multispring&lt;/groupId&gt;
      &lt;artifactId&gt;simple-persist&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring&lt;/artifactId&gt;
      &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;hsqldb&lt;/groupId&gt;
      &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
      &lt;version&gt;1.8.0.7&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>Ce <acronym>POM</acronym> crée un fichier <acronym>JAR</acronym> qui contient la classe
    <classname>org.sonatype.mavenbook.weather.Main</classname> présentée dans l'<xref linkend="ex-spring-command-main-class" />.
    Dans ce <acronym>POM</acronym> nous configurons le plugin Maven Assembly pour utiliser le descripteur d'assemblage intégré appelé <varname>jar-with-dependencies</varname>
    qui créé un <acronym>JAR</acronym> contenant tout le bytecode nécessaire au projet pour s'exécuter : le bytecode du projet et celui de ses dépendances.</para>

    <example id="ex-spring-command-main-class">
      <title>La classe Main du module simple-command</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.util.List;

import org.apache.log4j.PropertyConfigurator;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import org.sonatype.mavenbook.weather.model.Location;
import org.sonatype.mavenbook.weather.model.Weather;
import org.sonatype.mavenbook.weather.persist.LocationDAO;
import org.sonatype.mavenbook.weather.persist.WeatherDAO;

public class Main {

  private WeatherService weatherService;
  private WeatherDAO weatherDAO;
  private LocationDAO locationDAO;

  public static void main(String[] args) throws Exception {
    // Configuration de Log4J
    PropertyConfigurator.configure(Main.class.getClassLoader().getResource(
        "log4j.properties"));

    // Lecture du code postal à partir de la ligne de commande 
    String zipcode = "60202";
    try {
      zipcode = args[0];
    } catch (Exception e) {
    }

    // Lecture de l'opération à partir de la ligne de commande
    String operation = "weather";
    try {
      operation = args[1];
    } catch (Exception e) {
    }

    // Démarrage du programme
    Main main = new Main(zipcode);

    ApplicationContext context = 
      new ClassPathXmlApplicationContext(
        new String[] { "classpath:applicationContext-weather.xml",
                       "classpath:applicationContext-persist.xml" });
    main.weatherService = (WeatherService) context.getBean("weatherService");
    main.locationDAO = (LocationDAO) context.getBean("locationDAO");
    main.weatherDAO = (WeatherDAO) context.getBean("weatherDAO");
    if( operation.equals("weather")) {
      main.getWeather();
    } else {
      main.getHistory();
    }
  }

  private String zip;

  public Main(String zip) {
    this.zip = zip;
  }

  public void getWeather() throws Exception {
    Weather weather = weatherService.retrieveForecast(zip);
    weatherDAO.save( weather );
    System.out.print(new WeatherFormatter().formatWeather(weather));
  }

  public void getHistory() throws Exception {
    Location location = locationDAO.findByZip(zip);
    List&lt;Weather&gt; weathers = weatherDAO.recentForLocation(location);
    System.out.print(new WeatherFormatter().formatHistory(location, weathers));
  }
}
</programlisting>
    </example>

    <para>La classe <classname>Main</classname> possède des références vers <classname>WeatherDAO</classname>, 
    <classname>LocationDAO</classname> et <classname>WeatherService</classname>. 
    La méthode statique <methodname>main()</methodname> de cette classe :</para>

    <itemizedlist>
      <listitem>
        <para>Lit le code postal passé en premier argument de la ligne de commande</para>
      </listitem>

      <listitem>
        <para>Lit l'opération à effectuer. Il s'agit du second argument à passer à la ligne de commande. 
        Si l'opération est "weather", la dernière prévision sera récupérée à partir du service web.
        Si l'opération est "history", le programme récupérera l'historique des prévisions à partir de la base de données.</para>
      </listitem>

      <listitem>
        <para>Charge l'<classname>ApplicationContext</classname> Spring en utilisant deux fichiers XML provenant des modules 
        <varname>simple-persist</varname> et
        <varname>simple-weather</varname></para>
      </listitem>

      <listitem>
        <para>Crée une instance de la classe <classname>Main</classname></para>
      </listitem>

      <listitem>
        <para>Récupère les propriétés <varname>weatherService</varname>, <varname>weatherDAO</varname>, et <varname>locationDAO</varname> 
        à partir des beans Spring de l'<classname>ApplicationContext</classname></para>
      </listitem>

      <listitem>
        <para>Appelle la méthode appropriée <methodname>getWeather()</methodname> ou
        <methodname>getHistory()</methodname> en fonction de l'opération demandée.</para>
      </listitem>
    </itemizedlist>

    <para>Dans l'application web, nous utilisions le <classname>VelocityViewResolver</classname> proposé par Spring pour effectuer le rendu d'un template Velocity.
    Dans l'implémentation en ligne de commande, nous avons besoin d'écrire manuellement une classe qui permet d'afficher les données météorologiques à partir d'un template Velocity.
    L'<xref linkend="ex-spring-weather-formatter" /> affiche la classe <classname>WeatherFormatter</classname>.
    Cette classe possède donc deux méthodes qui permettent d'afficher respectivement les prévisions météorologiques et leur historique.</para>

    <example id="ex-spring-weather-formatter">
      <title>WeatherFormatter affiche les prévisions météo en utilisant un template Velocity</title>

      <programlisting language="java">package org.sonatype.mavenbook.weather;

import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringWriter;
import java.util.List;

import org.apache.log4j.Logger;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.Velocity;

import org.sonatype.mavenbook.weather.model.Location;
import org.sonatype.mavenbook.weather.model.Weather;

public class WeatherFormatter {

  private static Logger log = Logger.getLogger(WeatherFormatter.class);

  public String formatWeather( Weather weather ) throws Exception {
    log.info( "Formatting Weather Data" );
    Reader reader = 
      new InputStreamReader( getClass().getClassLoader().
                                 getResourceAsStream("weather.vm"));
    VelocityContext context = new VelocityContext();
    context.put("weather", weather );
    StringWriter writer = new StringWriter();
    Velocity.evaluate(context, writer, "", reader);
    return writer.toString();
  }

  public String formatHistory( Location location, List&lt;Weather&gt; weathers )  
        throws Exception {
    log.info( "Formatting History Data" );
    Reader reader = 
      new InputStreamReader( getClass().getClassLoader().
                                 getResourceAsStream("history.vm"));
    VelocityContext context = new VelocityContext();
    context.put("location", location );
    context.put("weathers", weathers );
    StringWriter writer = new StringWriter();
    Velocity.evaluate(context, writer, "", reader);
    return writer.toString();
  }
}
</programlisting>
    </example>

    <para>Le template <filename>weather.vm</filename> affiche le code postal, la ville, le pays et les prévisions de température.
    Le template <filename>history.vm</filename> affiche le lieu et itère sur la liste des prévisions stockées dans la base de données.  
    Ces deux templates se trouvent dans le dossier <filename>\${basedir}/src/main/resources</filename>.</para>

    <example>
      <title>Le template Velocity weather.vm</title>

      <programlisting language="java">****************************************
Current Weather Conditions for:
  \${weather.location.city},
  \${weather.location.region},
  \${weather.location.country}
****************************************

 * Temperature: \${weather.condition.temp}
 * Condition: \${weather.condition.text}
 * Humidity: \${weather.atmosphere.humidity}
 * Wind Chill: \${weather.wind.chill}
 * Date: \${weather.date}
</programlisting>
    </example>

    <example>
      <title>Le template Velocity history.vm</title>

      <para><programlisting>Weather History for:
\${location.city},
\${location.region},
\${location.country}


#foreach( $weather in $weathers )
****************************************
 * Temperature: $weather.condition.temp
 * Condition: $weather.condition.text
 * Humidity: $weather.atmosphere.humidity
 * Wind Chill: $weather.wind.chill
 * Date: $weather.date
#end</programlisting></para>
    </example>
  </section>

  <section id="multimodule-web-spring-sect-running-simple-command">
    <title>Exécution de l'application en ligne de commande</title>

    <para>Le projet <varname>simple-command</varname> est configuré pour créer un unique <acronym>JAR</acronym> 
    contenant le bytecode du projet et celui de toutes ses dépendances. Pour créer cet assemblage,
    il nous faut exécuter le goal <varname>assembly</varname> du plugin Maven Assembly à partir
    du répertoire du projet <varname>simple-command</varname> :</para>

    <screen>$ <command>mvn assembly:assembly</command>
[INFO] ------------------------------------------------------------------------
[INFO] Building Multi-spring Chapter Simple Command Line Tool
[INFO]    task-segment: [assembly:assembly] (aggregator-style)
[INFO] ------------------------------------------------------------------------
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Nothing to compile - all classes are up to date
[INFO] [resources:testResources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:testCompile]
[INFO] Nothing to compile - all classes are up to date
[INFO] [surefire:test]
...
[INFO] [jar:jar]
[INFO] Building jar: .../simple-parent/simple-command/target/simple-command.jar
[INFO] [assembly:assembly]
[INFO] Processing DependencySet (output=)
[INFO] Building jar: .../simple-parent/simple-command/target
                                      /simple-command-jar-with-dependencies.jar
</screen>

    <para>Le build suit le cycle de vie suivant : compilation, exécution des tests unitaires et construction du <acronym>JAR</acronym>.
    Le goal <varname>assembly:assembly</varname> crée un <acronym>JAR</acronym> contenant les dépendances. 
    Pour cela, toutes les dépendances sont dézippées dans un répertoire temporaire, ensuite tout le 
    bytecode est regroupé dans un unique <acronym>JAR</acronym> créé dans le répertoire
    <filename>target/</filename> et nommé <filename>simple-command-jar-with-dependencies.jar</filename>.
    Ce "super" <acronym>JAR</acronym> pèse 15 MO.</para>

    <para>Avant d'exécuter notre utilitaire à partir de la ligne de commande, nous devons appeler le goal
    <varname>hbm2ddl</varname> du plugin Hibernate3 pour créer la base de données HSQLDB.
    Pour cela, exécutez la commande suivante à partir du répertoire du projet <varname>simple-command</varname> :</para>

    <para><screen>$ <command>mvn hibernate3:hbm2ddl</command>
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'hibernate3'.
[INFO] org.codehaus.mojo: checking for updates from central
[INFO] ------------------------------------------------------------------------
[INFO] Building Multi-spring Chapter Simple Command Line Tool
[INFO]    task-segment: [hibernate3:hbm2ddl]
[INFO] ------------------------------------------------------------------------
[INFO] Preparing hibernate3:hbm2ddl
...
10:24:56,151  INFO org.hibernate.tool.hbm2ddl.SchemaExport - export complete
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
</screen>Une fois cette commande exécutée, vous devriez voir apparaître un répertoire <filename>data/</filename> dans le dossier <varname>simple-command</varname>.
  Ce répertoire <filename>data/</filename> contient la base de données HSQLDB. 
  Pour exécuter l'outil de prévisions en ligne de commande, lancez la commande suivante à partir du répertoire du projet <filename>simple-command</filename> :</para>

    <screen>$ <command>java -cp target/simple-command-jar-with-dependencies.jar \
           org.sonatype.mavenbook.weather.Main 60202</command>
2321 INFO  YahooRetriever  - Retrieving Weather Data
2489 INFO  YahooParser  - Creating XML Reader
2581 INFO  YahooParser  - Parsing XML Response
2875 INFO  WeatherFormatter  - Formatting Weather Data
****************************************
Current Weather Conditions for:
  Evanston, 
  IL, 
  US
****************************************
  
 * Temperature: 75
 * Condition: Partly Cloudy
 * Humidity: 64
 * Wind Chill: 75
 * Date: Wed Aug 06 09:35:30 CDT 2008
</screen>

    <para>Pour afficher l'historique des prévisions, exécutez la commande suivante :</para>

    <screen>$ <command>java -cp target/simple-command-jar-with-dependencies.jar \
           org.sonatype.mavenbook.weather.Main 60202 history</command>
2470 INFO  WeatherFormatter  - Formatting History Data
Weather History for: 
Evanston, IL, US
  
****************************************
 * Temperature: 39
 * Condition: Heavy Rain
 * Humidity: 93
 * Wind Chill: 36
 * Date: 2007-12-02 13:45:27.187
****************************************
 * Temperature: 75
 * Condition: Partly Cloudy
 * Humidity: 64
 * Wind Chill: 75
 * Date: 2008-08-06 09:24:11.725
****************************************
 * Temperature: 75
 * Condition: Partly Cloudy
 * Humidity: 64
 * Wind Chill: 75
 * Date: 2008-08-06 09:27:28.475 </screen>
  </section>

  <section id="multimodule-web-spring-sect-conclusion">
    <title>Conclusion</title>
 
    <para>Nous avons passé beaucoup de temps sur des sujets ne se rapportant pas directement à Maven
    pour parcourir tout ce chemin. Nous l'avons fait pour présenter un projet exemple aussi complet
    et significatif que possible pour que vous puissiez l'utiliser pour réaliser de véritables systèmes.
    Pour arriver à ce résultat, nous n'avons pas eu besoin de prendre de raccourcis, ni de vous
    émerveiller avec des tours de magie à la Ruby on Rails, ni de vous laisser croire qu'on peut
    créer une application Java d'entreprise en "10 minutes ! ". Trop de monde essayent de vous vendre
    le framework révolutionnaire qui vous demanderait zéro temps d'apprentissage. Ce que nous avons 
    essayé de faire dans ce chapitre est de présenter le tableau dans son intégralité, l'écosystème
    complet d'un build multimodule. Nous vous avons présenté Maven dans le contexte d'une application
    qui ressemble à ce que vous pourriez voir dans la vraie vie, et non 10 minutes de vidéo roulant
    Apache Ant dans la boue et essayant de vous donner envie d'adopter Apache Maven.</para>

    <para>Si vous terminez ce chapitre en vous demandant en quoi il traite de Maven, notre mission 
    est réussie. Nous avons présenté un ensemble complexe de projets en utilisant des frameworks
    populaires que nous avons assemblés par des build déclaratifs. Le fait que plus de 60% de ce
    chapitre ait été consacré au fonctionnement de Spring et Hibernate doit montrer que Maven, pour
    sa plus grosse partie, n'est pas l'étape la plus compliquée d'un projet. Il nous a permis de nous
    concentrer sur l'application elle-même, et non sur le processus de build. Au lieu de passer du
    temps à discuter du fonctionnement de Maven et le travail que vous devriez faire pour construire
    un projet qui intègre Spring et Hibernate, nous avons parlé presque exclusivement des technologies
    utilisées. Si vous commencez à utiliser Maven et que vous prenez du temps pour l'apprendre,
    vous commencez vraiment à profiter du fait que vous ne devez pas passer votre temps à écrire vos
    scripts de build. Vous ne devez pas perdre votre temps à vous inquiéter des aspects classiques de
    votre build.</para>

    <para>Vous pouvez utiliser le squelette du projet de ce chapitre comme fondation pour votre propre projet. Fondation à laquelle vous ajouterez des modules au fur et à mesure de vos besoins. 
    Par exemple, le véritable projet dont ce chapitre est tiré comporte deux projets modèles, deux modules de persistance qui permettent de stocker des objets dans différents type de base de données, plusieurs applications web et une application Java mobile.
    Au total, le système du monde réel duquel j'ai tiré cet exemple contient au moins 15 modules interdépendants.
    Vous avez vu l'exemple de projet multimodule le plus complet que nous allons présenter dans ce livre, 
    notez cependant que cet exemple se contente d'aborder qu'une infime partie de ce qu'il est possible de faire avec Maven.</para> 
    
    <section id="multimodule-web-spring-sect-interface-projects">
      <title>Programmation avec des projets API</title>

      <para>Ce chapitre a exploré un projet multimodule qui était plus complexe que l'exemple présenté dans le <xref linkend="multimodule" />,
      pourtant il s'agit encore d'une simplification par rapport à un vrai projet.
      Dans un plus grand projet, vous pourriez construire un système ressemblant à la <xref linkend="fig-multimodule-web-spring-projects-complex" />.</para>  

      <figure id="fig-multimodule-web-spring-projects-complex">
        <title>Programmation avec des projets API</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/multimodule-web-spring_projects-complex.png" />
          </imageobject>

          <imageobject role="print">
            <imagedata fileref="figs/print/multimodule-web-spring_projects-complex.pdf"  align="center" scalefit="0" width="100%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Quand nous utilisons le terme projet API, nous faisons allusion à un projet Maven qui 
      contient uniquement des interfaces et des constantes. Sur la <xref
      linkend="fig-multimodule-web-spring-projects-complex" />, deux des projets sont des projets
      API : <varname>persist-api</varname> et <varname>parse-api</varname>. Si les projets
      <varname>big-command</varname> et <varname>big-webapp</varname> utilisent les interfaces
      définies dans <varname>persist-api</varname>, il sera facile de changer d'implémentations et
      de framework de persistance. Ce diagramme en particulier montre deux implémentations du
      projet <varname>persist-api</varname> : une qui stocke ses données dans une base de données
      <acronym>XML</acronym> et l'autre qui stocke ses données dans une base de données relationnelle.
      Si vous décidez de mettre en place certains des concepts de ce chapitre, vous pourriez 
      réfléchir à comment passer un signal au programme pour permettre de changer
      d'<classname>ApplicationContext</classname> Spring et changer ainsi de base de données à la volée.
      Comme pour la conception OO de l'application elle-même, il est souvent prudent de séparer les 
      interfaces d'une <acronym>API</acronym> de leurs implémentations en utilisant des projets
      Maven séparés.</para>
      
    </section>
  </section>
</chapter>
