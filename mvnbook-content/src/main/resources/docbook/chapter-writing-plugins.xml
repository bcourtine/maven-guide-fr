<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="writing-plugins">
  <title>Création de Plugins</title>

  <section id="writing-plugins-sect-intro">
    <title>Introduction</title>

    <para>Bien que ce chapitre aborde une utilisation avancée de Maven, l'écriture de plugin d'un plugin Maven ne doit pas vous intimider.
    Malgré la compléxité de cet outil, les concepts fondamentaux sont faciles à comprendre et l'écriture de plugins reste relativement simple. 
    Après la lecture de ce chapitre, vous aurez une bonne idée de ce qu'implique la création d'un plugin Maven.</para>
  </section>

  <section id="writing-plugins-sect-programming-maven">
    <title>Programmation Maven</title>

    <para>La plus grande partie de cet ouvrage a été dédié à l'utilisation de Maven, de ce fait, 
    vous n'avez pas vu beaucoup d'exemples de code portant sur la personnalisation de Maven.
    En fait, vous n'avez pas vu du tout. 
    Maven a été pensé pour que 99% de ses utilisateurs n'aient jamais besoin d'écrire de plugin pour personnaliser Maven.
    En effet, il existe bon nombre de plugins et ceux-ci peuvent être configurés pour répondre à la majorité des exigences, 
    vous n'aurez donc probablement pas besoin d'écrire de plugins.  
    Cela dit, si votre projet comporte des exigences vous obligeant à personnaliser le comportement de Maven, 
    vous pouvez alors vous lancer dans la création d'un plugin.
    Modifier le code du coeur de Maven est est aussi peu connu des développeurs que de modifier la stack TCP/IP d'un système d'exploitation,
    c'est du moins ce que pensent la majorité des utilisateurs.</para>    

    <para>Avant de commencer à écrire votre plugin, vous devez en apprendre un peu plus sur les entrailles de Maven :  
    Comment gère t-il des composants logiciels ? Qu'est-ce qu'un Plugin ? Comment puis-je personnaliser le cycle de vie ?
    Cette section répond à certaines de ces questions et introduit les concepts de conception du coeur de Maven.  
    Apprendre à écrire un plugin personnalisé Maven est le moyen le plus simple à la personnalisation de Maven lui-même.
    Si vous vous demandiez par où démarrer pour comprendre le code de Maven, vous avez trouvé la bonne ligne de départ.</para>

    <section id="writing-plugins-ioc">
      <title>Qu'est ce que l'inversion de contrôle ?</title>

      <para>Un conteneur d'inversion de contrôle (<acronym>IoC</acronym>) nommé Plexus se trouve au coeur de Maven. 
      Que fait-il ? Il s'agit d'un système de gestion et de relations entre composants. 
      Bien qu'il existe un ouvrage complet écrit par Martin Fowler sur l'<acronym>IoC</acronym>, 
      le concept et le terme ont été si lourdement surchargés au cours des dernières années 
      qu'il est difficile de trouver une bonne définition de la notion sans que ça soit une auto-référence.
      Au lieu de recourir à une citation Wikipédia, nous allons résumer l'inversion de contrôle et l'ingestion de dépendances par l'intermédiaire d'une analogie.</para>

      <para>Supposons que vous devez connecter une série de composants ensemble. 
      Quand vous pensez à des composants, pensez à des composants stéréo, pas les composants logiciels. 
      Imaginez plusieurs composants stéréo branchés à une Playstation 3 et un TiVo qui doivent s'interfacer à la fois avec un boîtier Apple TV et d'une télévision LCD 50 pouces..
      Vous ramenez tout cela d'un magasin d'électronique à la maison et vous achetez les câbles à utiliser pour connecter tout cela.
      Vous déballez donc l'ensemble de ces éléments, vous les placez au bon endroit, 
      puis vous commencez à accrocher les cinquante mille câbles coaxiaux et prises stéréo à cinquante mille entrées numériques.       
      Éloignez-vous de votre Home cinéma et allumez la télé, vous venez de réaliser de l'injection de dépendances, et vous étiez vous-même un conteneur d'inversion de contrôle.</para>       

      <para>Quel est le rapport avec tout ça ? Transposons cette analogie en Java.
      Votre Playstation 3 et votre bean Java fournissent tous les deux une interface.
      La Playsrtation 3 à deux entrées : l'alimentation et la fiche réseau, et une sortie vers la TV.
      Votre bean Java possède trois propriétés : <varname>power</varname>, <varname>network</varname> et <varname>tvOutput</varname>.
      Quand vous ouvrez la boîte de votre Playstation 3, le manuel ne vous décrit pas en détail comment la connecter à tous les différents types de téléviseurs. 
      Quand vous regardez votre bean Java, it fournit une liste de propriétés sans pour autant expliquer une recette explicite pour créer et gérer un système complet de composants.         
      Dans un conteur d'<acronym>IoC</acronym> comme Plexus, il vous incombe de déclarer les relations entre les composants en se contentent de fournir une interface d'entrée et de sortie.
      Vous n'instanciez pas d'objets, Plexus s'en charge. Le code de votre application n'est pas resposable de la gestion des états des composants, contrairement à Plexus. 
      Lorsque vous démarrez Maven, Plexus est démarré pour gérer un système d'éléments connexes, comme votre système stéréo.</para>

      <para>Quels sont les avantages apportés par l'utilisation d'un conteneur <acronym>IoC</acronym> ?
      Quel est l'avantage d'acheter des composants stéréo discrets ?
      Si l'un des composants se casse, vous pouvez le remplacer sans avoir à dépenser les 15 000 € nécessaires pour remplacer l'ensemble du système.
      Si votre téléviseur vous lâche, vous pouvez la remplacer sans que cela n'affecte le lecteur CD.
      Et le plus important pour vous, vos composants de votre chaîne hi-fi coûtent moins chers et sont plus fiables 
      car les fabricants peuvent se contenter de construire des composants en s'appuyant un ensemble d'entrées et sorties connues. 
      Les conteneurs d'inversion de contrôle et d'injection de dépendances encouragent la catégorisation et l'émergence de standards.
      L'industrie du logiciel aime s'imaginer comme source de toutes les nouvelles idées, 
      mais l'injection de dépendances et de l'inversion de contrôle ne sont réellement que des nouveaux mots pour définir des concepts bien connus : la catégorisation et le remplacement de machines.      
      Si vous voulez en savoir plus sur l'<acronym>IoC</acronym> et l'injection de dépendances, vous pouvez vous renseigner sur le modèle T, le gin de coton ou l'émergence d'un standard pour le chemin de fer au 19ème siècle.</para>
    </section>

    <section id="writing-plugins-intro-plexus">
      <title>Introduction à Plexus</title>

      <para>La fonctionnalité la plus importante d'un conteneur d'<acronym>IoC</acronym> Java est son mécanisme d'injection de dépendances.
      Le principe de base d'un conteneur <acronym>IoC</acronym> est de contrôler la création et la gestion des objets. 
      Ce ne sont plus les objets qui sont responsables d'instancier leurs dépendances mais une tierce personne : le conteneur <acronym>IoC</acronym>.  
      En utilisant l'injection de dépendances dans une application utilisant la programmation par interface, 
      vous pouvez créer des composants qui n'ont aucune liaison particulière avec les différentes implémentations de vos services. 
      Bien que votre code utilise des interfaces, 
      vous pouvez capturer les dépendances entre les classes et les composants dans un fichier <acronym>XML</acronym> qui définit les composants, 
      les classes d'implémentation et les relations entre vos composants.
      En d'autres termes, vous pouvez écrire des composants isolés et déléguer la définition de leurs liaisons en utilisant un fichier <acronym>XML</acronym>. 
      Dans Plexus, les différents composants d'un système sont définis par un document <acronym>XML</acronym> qui se trouve dans
      <filename>META-INF/plexus/components.xml</filename>.</para>
      
      <para>Dans un conteneur Java <acronym>IoC</acronym>, il existe plusieurs moyens d'injecter des dépendances dans un objet : injection par constructeur, setter ou propriétés. 
      Bien que Plexus soit capable d'utiliser ces trois techniques d'injection de dépendances, Maven en utilise seulement deux :
      l'injection par propriété et par setter.</para>

      <variablelist>
        <varlistentry>
          <term>Injection par constructeur</term>

          <listitem>
            <para>L'injection par constructeur permet de populer des objets à la création de l'objet.
            Par exemple, si vous avec un objet du type <classname>Person</classname> 
            qui possède un constructeur <methodname>Person(String name, Job job)</methodname>, 
            vous pouvez y passer deux valeurs, soit deux dépendances.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Injection par setter</term>

          <listitem>
            <para>Ce type d'injection utilise les setters des propriétés des beans Java pour populer ses dépendances. 
            Par exemple, si vous avec un objet du type <classname>Person</classname> 
            qui possède deux propriétés <varname>name</varname> et <varname>job</varname>,
            un conteneur <acronym>IoC</acronym> utilisant l'injection par setter créera une instance de la classe <classname>Person</classname>
            en utilisant le constructeur par défaut et appellera ensuite les méthodes 
            <methodname>setName()</methodname> et <methodname>setJob()</methodname>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Injection par propriété</term>

          <listitem>
            <para>Les deux types d'injection précédents se basent sur l'appel de méthodes et constructeur publics.
            En utilisant l'injection par propriétés, un conteneur <acronym>IoC</acronym> peut populer les dépendances de composants
            en utilisant directement les propriétés.
            Par exemple, si vous avec un objet du type <classname>Person</classname> qui contient deux propriétés <varname>name</varname> et <varname>job</varname>, 
            votre conteneur <acronym>IoC</acronym> utilisera ces champs directement pour populer les dépendances 
            (i.e. <code>person.name = "Thomas"; person.job = job;</code>)</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section id="writing-plugins-why-plexus">
      <title>Pourquoi Plexus ?</title>

      <para>Spring est le conteneur <acronym>IoC</acronym> le plus populaire du moment.
      Il a un bon argument à faire valoir, il a affecté "l'écosystème Java" en forçant les entreprises comme Sun Microsystems
      à donner plus contrôle à la communauté open source.
      Mais Spring n'est pas le seul conteneur <acronym>IoC</acronym> open source, il en existe de plusieurs 
      (comme <ulink url="http://www.picocontainer.org/">PicoContainer</ulink>).</para>

      <para>Il y a des années, quand Maven a été créé, Spring n'était pas si mature.
      L'équipe initiale des commiters Maven étaient plus familier avec un autre conteneur <acronym>IoC</acronym> : Plexus, qu'ils avaient d'ailleurs inventé.
      Ils sont donc partis sur ce choix.
      S'il n'est pas aussi populaire que Spring, il en est pas pour autant moins efficace.
      Comme Plexus a été créé par les commiters initaux de Maven, il répond parfaitement à ses besoins.
      Après la lecture de ce chapitre, vous en connaîtrez plus sur le fonctionnement de Plexus. 
      Si vous avez déjà utilisé un conteneur <acronym>IoC</acronym>, vous pourrez noter les similarités et les différences de ce conteneur.</para>

      <note>
        <para>Si Maven est basé sur Plexus, cela ne veut pas dire que la communauté Maven est "anti-Spring"
        (nous avons d'ailleurs consacré un chapitre complet à Spring dans cet ouvrage).
        La question "pourquoi vous n'avez pas utilisé Spring ?" revient assez souvent pour que nous effectuons cet aparté.</para>
      </note>
    </section>

    <section id="writing-plugins-what-is-plugin">
      <title>Qu'est ce qu'un Plugin ?</title>

      <para>Un plugin Maven est un artefact Maven qui contient un descripteur de plugin et un ou plusieurs Mojos. 
      Un Mojo peut se comparer à un goal Maven, d'ailleurs derrière chaque goal se cache un Mojo.
      Au goal <varname>compiler:compile</varname> correspond la classe <classname>CompilerMojo</classname> du plugin Maven Compiler, 
      le goal <varname>jar:jar</varname> correspond à la classe <classname>JarMojo</classname> du plugin Maven Jar...
      Losque vous écrivez votre propre plugin, vous regroupez un ensemble de Mojos (ou goals) dans un unique artefact.</para>

      <note>
        <para>Mojo ? Qu'est-ce qu'un Mojo ? Le mot mojo définit dans le dictionnaire comme un "charme magique ou un sort", 
        une "amulette, souvent dans un sac en flanelle de faible capacité contenant un ou plusieurs objets magiques" et du "magnétisme personnel; charme".
        Maven utilise le terme Mojo comme jeu de mots autour du terme Pojo (Plain-old Java Object), un Pojo Maven est donc appelé Mojo.</para> 
      </note>

      <para>Un Mojo est bien plus qu'un goal Maven, c'est un composant géré par Plexus qui peut inclure des références à d'autres composants Plexus.</para>
    </section>
  </section>

  <section id="writing-plugins-sect-plugin-descriptor">
    <title>Descripteur de Plugin</title>

    <para>Un plugin Maven contient une carte qui permet Maven s'y retrouver dans les Mojos et la configuration de celui-ci. 
    Ce descripteur de plugin se trouve dans le fichier <acronym>JAR</acronym> du plugin à l'emplacement <filename>META-INF/maven/plugin.xml</filename>. 
    Quand Maven charge un plugin, il commence par lire ce fichier <acronym>XML</acronym> puis instancie et configure les objets du plugin pour rendre les Mojos disponibles.</para>

    <para>Lorsque vous écrivez des plugins Maven, nous n'avez quasiment jamais besoin de vous soucier du descripteur de site.
    Dans le <xref linkend="lifecycle" />,
    les goals du lifecycle rattachés au type de packaging <varname>maven-plugin</varname>
    montrent que le goal <varname>plugin:descriptor</varname> est rattaché à la phase <varname>generate-resources</varname>. 
    Ce goal génère un descripteur de plugin à partir de annotations présentes dans le code source du plugin.     
    Dans la suite du chapitre, nous verrons comment les Mojos sont annotés ainsi que les impacts (de ces annotations) sur le fichier <filename>META-INF/maven/plugin.xml</filename>.</para>    

    <para>L'<xref linkend="ex-plugin-desc" /> montre le descripteur de plugin du plugin Maven Zip. 
    Comme son nom l'indique, ce plugin permet d'effectuer des Zips à partir du répertoire de sortie.
    Normalement, vous ne devriez jamais à avoir écrire votre propre plugin pour effectuer des archives avec Maven.
    Utilisez simplement le plugin Maven Assembly, il est capable de produire des archives dans de multiples formats. 
    Regardez le descripteur de site suivant, cela vous donnera une idée de ce genre de fichier.</para>

    <!--TODO: Reference Assembly Plugin Chapter-->

    <example id="ex-plugin-desc">
      <title>Plugin Descriptor</title>

      <programlisting language="xml">&lt;plugin&gt;
  &lt;description&gt;&lt;/description&gt;
  &lt;groupId&gt;com.training.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-zip-plugin&lt;/artifactId&gt;
  &lt;version&gt;1-SNAPSHOT&lt;/version&gt;
  &lt;goalPrefix&gt;zip&lt;/goalPrefix&gt;
  &lt;isolatedRealm&gt;false&lt;/isolatedRealm&gt;
  &lt;inheritedByDefault&gt;true&lt;/inheritedByDefault&gt;
  &lt;mojos&gt;
    &lt;mojo&gt;
      &lt;goal&gt;zip&lt;/goal&gt;
      &lt;description&gt;Zips up the output directory.&lt;/description&gt;
      &lt;requiresDirectInvocation&gt;false&lt;/requiresDirectInvocation&gt;
      &lt;requiresProject&gt;true&lt;/requiresProject&gt;
      &lt;requiresReports&gt;false&lt;/requiresReports&gt;
      &lt;aggregator&gt;false&lt;/aggregator&gt;
      &lt;requiresOnline&gt;false&lt;/requiresOnline&gt;
      &lt;inheritedByDefault&gt;true&lt;/inheritedByDefault&gt;
      &lt;phase&gt;package&lt;/phase&gt;
      &lt;implementation&gt;com.training.plugins.ZipMojo&lt;/implementation&gt;
      &lt;language&gt;java&lt;/language&gt;
      &lt;instantiationStrategy&gt;per-lookup&lt;/instantiationStrategy&gt;
      &lt;executionStrategy&gt;once-per-session&lt;/executionStrategy&gt;
      &lt;parameters&gt;
        &lt;parameter&gt;
          &lt;name&gt;baseDirectory&lt;/name&gt;
          &lt;type&gt;java.io.File&lt;/type&gt;
          &lt;required&gt;false&lt;/required&gt;
          &lt;editable&gt;true&lt;/editable&gt;
          &lt;description&gt;Base directory of the project.&lt;/description&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
          &lt;name&gt;buildDirectory&lt;/name&gt;
          &lt;type&gt;java.io.File&lt;/type&gt;
          &lt;required&gt;false&lt;/required&gt;
          &lt;editable&gt;true&lt;/editable&gt;
          &lt;description&gt;Directory containing the build files.&lt;/description&gt;
        &lt;/parameter&gt;
      &lt;/parameters&gt;
      &lt;configuration&gt;
        &lt;buildDirectory implementation="java.io.File"&gt;
          \${project.build.directory}&lt;/buildDirectory&gt;
        &lt;baseDirectory implementation="java.io.File"&gt;
          \${basedir}&lt;/baseDirectory&gt;
      &lt;/configuration&gt;
      &lt;requirements&gt;
        &lt;requirement&gt;
          &lt;role&gt;org.codehaus.plexus.archiver.Archiver&lt;/role&gt;
          &lt;role-hint&gt;zip&lt;/role-hint&gt;
          &lt;field-name&gt;zipArchiver&lt;/field-name&gt;
        &lt;/requirement&gt;
      &lt;/requirements&gt;
    &lt;/mojo&gt;
  &lt;/mojos&gt;
  &lt;dependencies&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
  &lt;/dependencies&gt;
&lt;/plugin&gt;
</programlisting>
    </example>

    <para>Un descripteur de site contient trois parties : la configuration haut-niveau qui contient les éléments du type  
    <sgmltag>groupId</sgmltag> et <sgmltag>artifactId</sgmltag>, la déclaration des mojos et les dépendances. 
    Regardons chacune de ces sections dans le détail.</para>

    <section id="writing-plugins-top-level-elements">
      <title>Éléments haut-niveau du descripteur de plugin</title>

      <para>Les valeurs de configuration haut-niveau du plugin sont :</para>

      <variablelist>
        <varlistentry>
          <term>description</term>

          <listitem>
            <para>Cet élément contient une courte description du plugin. Dans le plugin Zip, cette description est laissée vide.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>groupId, artifactId, version</term>

          <listitem>
            <para>Comme tout artefact dans Maven, les plugins doivent posséder des coordonnées uniques.
            Le groupId, l'artifactId et la version sont utilisés pour identifier le plugin dans le dépôt Maven.</para> 
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>goalPrefix</term>

          <listitem>
            <para>Cet élément contrôle le préfixe utilisé pour référencer les différents goals d'un plugin.
            Si vous regardez au descripteur du plugin Compiler, vous verrez que la valeur du <varname>goalPrefix</varname> est <varname>compiler</varname>.
            De la même manière, si vous regardez le descripteur du plugin Jar, il possédera un <varname>goalPrefix</varname> à <varname>jar</varname>.
            Il est important de choisir un préfixe qui n'existe pas pour votre nouveau plugin.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>isolatedRealm (deprecated)</term>

          <listitem>
            <para>C'est une propriété legacy qui n'est plus utilisée par Maven.
            Elle reste présente dans le système pour assurer la compatibilité avec les plugins les plus anciens.
            Les anciennes versions du Maven utilisaient un mécanisme de chargement des dépendances des plugins dans un <classname>ClassLoader</classname> isolé.
            Maven utilise de manière intensive le projet <ulink url="http://classworlds.codehaus.org/">ClassWorlds</ulink> provenant de la communauté the <ulink url="http://www.codehaus.org">Codehaus</ulink>
            pour créer une hiérarchie de <classname>ClassLoader</classname> qui est modélisée par un objet <classname>ClassRealm</classname>.               
            N'hésitez pas à ignorer cette propriété et à laisser sa valeur à <varname>false</varname>.</para>              
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>inheritedByDefault</term>

          <listitem>
            <para>Si cette propriété est affectée à <varname>true</varname>, il vous est possible de configurer vos mojo à partir des projets parents du plugin. 
            Si vous configurez un mojo pour être exécuté durant une phase spécifique dans un projet parent et que cette propriété est settée à <varname>true</varname>,
            l'exécution prendra bien en compte celui-ci. À l'inverse, l'exécution n'en tiendra pas compte.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section id="writing-plugins-sect-mojo-config">
      <title>Configuration du Mojo</title>

      <para>Vient ensuite la déclaration de chaque Mojo.
      La balise <varname>plugin</varname> contient un sous balise <varname>mojos</varname> qui contient un élément par mojo présent dans le plugin. 
      Chaque balise <varname>mojo</varname> contient les éléments suivants :</para>

      <variablelist>
        <varlistentry>
          <term>goal</term>

          <listitem>
            <para>Il s'agit du nom du goal. Si nous prenons l'exemple du goal <varname>compiler:compile</varname>,
            <varname>compiler</varname> est le <varname>goalPrefix</varname> et
            <varname>compile</varname> désigne le nom du goal.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>description</term>

          <listitem>
            <para>Cette balise contient la description du goal. Celle-ci est utilisée par le plugin Help pour générer la documentation du plugin.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requiresDirectInvocation</term>

          <listitem>
            <para>Si vous affectez cette propriété à <varname>true</varname>, 
            le goal pourra seulement s'exécuter s'il est appelé directement par la ligne de commande par un utilisateur.
            Si quelqu'un essaye de rattacher ce goal à une phase du cycle de cie dans un <acronym>POM</acronym>, Maven affichera un message d'erreur.             
            La valeur par défaut pour est propriété est <varname>false</varname>.</para>

            <!--TODO: Might want some justification.-->
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requiresProject</term>

          <listitem>
            <para>Spécifie si le goal peut être exécuté en dehors d'un projet.
            Si cette propriété est affectée à <varname>true</varname> (la valeur par défaut), le goal nécessitera un <acronym>POM</acronym>.</para>   
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requiresReports</term>

          <listitem>
            <para>Si vous créez un plugin qui nécessite la présence de rapports,
            par exemple, si vous écrivez un plugin qui agrège les informations à partir de plusieurs rapports,
            vous pouvez setter la propriété <varname>requiresReports</varname> à <varname>true</varname>.
            La valeur par défaut de cette propriété est <varname>false</varname>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>aggregator</term>

          <listitem>
            <para>Un descripteur de Mojo dont la valeur de la balise <varname>aggregator</varname> est affectée à <varname>true</varname> 
            est censé s'exécuter qu'une seule fois durant l'exécution de Maven,
            ce flag a été créé pour donner la possibilité aux développeurs de plugins d'agréger la sortie d'une série de builds.
            Par exemple, on peut utiliser celui-ci pour créer un plugin qui agrège un rapport sur tous les projets d'un build.
            Un goal qui possède ce flag <varname>aggregator</varname> positionné à <varname>true</varname> doit être lancé uniquement à partir d'un projet haut-niveau d'un build Maven.
            La valeur par défaut de cette propriété est <varname>false</varname>.
            Elle est marquée comme <varname>depracated</varname> pour les prochaines releases.</para>    
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requiresOnline</term>

          <listitem>
            <para>Spécifie si un goal donné peut s'exécuter en mode offline (option <varname>-o</varname> de la ligne de commande).
            Si un goal nécessite l'utilisation de ressources réseau et que ce flag est activé, Maven affichera une erreur si le goal est exécuté en mode offline.
            La valeur par défaut pour cette propriété est <varname>false</varname>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>inheritedByDefault</term>

          <listitem>
            <para>Si cette propriété est positionnée à <varname>true</varname>,
            un mojo configuré dans un pom parent reprendra cette configuration pour le projet enfant.  
            Si vous configurez un mojo pour s'exécuter dans une phase spécifique d'un projet parent et que ce flag est activé,
            cette exécution sera héritée pour le projet enfant. 
            Cette propriété est positionnée par défaut à <varname>false</varname>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>phase</term>

          <listitem>
            <para>Si vous ne rattachez pas ce goal à une phase spécifique, cet élément défini la phase par défaut du mojo.
            Si vous ne précisez pas cet élément, Maven demandera à l'utilisateur de spécifier explicitement la phase dans le <acronym>POM</acronym>.</para> 
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>implementation</term>

          <listitem>
            <para>Il s'agit de la classe du Mojo à instancier par Maven.
            Cette propriété est une propriété de composant Plexus (définie dans le <classname>ComponentDescriptor</classname> de Plexus).</para> 
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>language</term>

          <listitem>
            <para>Java est le langage par défaut d'un Mojo Maven.
            Cette propriété contrôle le <classname>ComponentFactory</classname> utilisé par Plexus pour créer et instancier le Mojo. 
            Ce chapitre se concentre sur l'écriture de plugin Java, cependant notez qu'il est possible d'utiliser d'autres langages : Groovy, Beanshell, Ruby...             
            Dans le cas où vous utiliseriez un de ces langages alternatifs, vous auriez utilisé cet élément.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>instantiationStrategy</term>

          <listitem>
            <para>Cette propriété est une propriété de configuration de composants Plexus,
            elle permet de contrôler la stratégie utilisée par Plexus pour gérer ses instances de composants.
            Dans Maven, tous les mojos sont configurés par l'intermédiaire d'un  <varname>instantiationStrategy</varname> du <varname>per-lookup</varname>.   
            Une nouvelle instance du composant (mojo) est crée à chaque récupération de celui-ci à partir de Plexus.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>executionStrategy</term>

          <listitem>
            <para>Il s'agit du choix de la stratégie utilisée par Maven pour exécuter un Mojo.
            Les différentes valeurs utilisables dans cet élément sont <varname>once-per-session</varname> et <varname>always</varname>.   
            Note : cette propriété est dorénavant <varname>depracated</varname> et n'est plus utilisée par Maven, elle sera supprimée dans les prochaines releases.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>parameters</term>

          <listitem>
            <para>Cette balise décrit tous les paramètres du Mojo.
            Quel est son nom ? Quel est son type ? Est-il obligatoire ?
            Chaque paramètre possède les éléments suivants :</para>

            <variablelist>
              <varlistentry>
                <term>name</term>

                <listitem>
                  <para>Il s'agit du nom du paramètre (exemple <varname>baseDirectory</varname>)</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>type</term>

                <listitem>
                  <para>Il s'agit du type Java du paramètre (exemple <classname>java.io.File</classname>)</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>required</term>

                <listitem>
                  <para>Indique si le paramètre est obligatoire. 
                  Affecté à <varname>true</varname>, le paramètre de doit être passé au goal exécuté avec une valeur non null.</para>  
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>editable</term>

                <listitem>
                  <para>Si un paramètre n'est pas éditable (si cette propriété est positionnée à <varname>false</varname>),
                  alors la valeur de ce paramètre ne pourra pas être modifier dans un <acronym>POM</acronym>.
                  Par exemple, si le descripteur de plugin défini la valeur de la propriété <varname>buildDirectory</varname> à <varname>\${basedir}</varname>,
                  aucun <acronym>POM</acronym> ne pourra pas surcharger cette valeur.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>description</term>

                <listitem>
                  <para>Courte description utilisée lors de la génération de la documentation du plugin (utilisé par le plugin Help)</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>configuration</term>

          <listitem>
            <para>Cet élément fournit les valeurs par défaut de tous les paramètres du Mojo utilisant la notation Maven.
            Cet exemple fournit la valeur par défaut des paramètres Mojo <varname>baseDir</varname> et <varname>buildDirectory</varname>. 
            Dans cet élément, l'implémentation spécifie le type (<classname>java.io.File</classname>), la valeur du paramètre peut contenir soit une valeur par défaut harcodée soit  une référence à une propriété Maven.</para> 
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requirements</term>

          <listitem>
            <para>Voila de quoi rendre intéressant le descripteur de plugin.
            Un Mojo est un composant géré par Plexus. 
            Grâce à cela, il est possible de référencer n'importe quel autre composant géré par Plexus. 
            Cet propriété permet de définir les dépendances vers d'autres composants Plexus.</para>

            <!--TODO: Insert an XREF to an example?-->
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Même s'il est intéressant de savoir comment lire un descripteur de plugin, vous ne devriez pratiquement jamais avoir à en écrire un.
      Les fichiers du plugin descripteur sont générés automatiquement à partir d'annotations présentes dans le code source du mojo.</para>
    </section>

    <section id="writing-plugins-sect-plugin-depend">
      <title>Dépendances d'un Plugin</title>

      <para>Pour finir, le descripteur de plugin déclare une liste de dépendance de la même manière qu'un projet Maven le ferait.
      Quand Maven utilise un plugin, toutes ses dépendances sont téléchargées avant d'exécuter un de ses goals.
      Dans cet exemple, le plugin dépend de Jakarta Commons IO version 1.3.2.</para>
    </section>
  </section>

  <section id="writing-plugins-sect-custom-plugin">
    <title>Écrire un plugin personnalisé</title>

    <para>Pour écrire un plugin, vous devez créer un ou plusieurs Mojo (goal).
    Chaque Mojo est représentée par une classe Java qui contient des annotations pour indiquer à Maven générer le descripteur de plugin.
    Avant de commencer à écrire vos classes Mojo, vous devez commencer par créer un projet Maven avec le type de packaging approprié.</para>   

    <section id="writing-plugins-sect-creating-plugin-project">
      <title>Création d'un projet Plugin</title>

      <para>Pour créer un projet Plugin, vous pouvez utiliser le plugin Maven Archetype.
      La ligne de commande suivante se chargera de générer un projet possédant <varname>org.sonatype.mavenbook.plugins</varname> comme <varname>groupId</varname>,
      et <varname>first-maven-plugin</varname> comme <varname>artifactId</varname> :</para> 

      <screen>$ <command>mvn archetype:create \
  -DgroupId=org.sonatype.mavenbook.plugins \
  -DartifactId=first-maven-plugin \
  -DarchetypeGroupId=org.apache.maven.archetypes \
  -DarchetypeArtifactId=maven-archetype-mojo</command></screen>

      <para>Le plugin Archetype va créer ainsi le répertoire nommé <varname>my-first-plugin</varname> qui conteindra le POM suivant.</para>

      <example>
        <title>Le POM d'un projet Plugin</title>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;first-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;maven-plugin&lt;/packaging&gt;
  &lt;name&gt;first-maven-plugin Maven Mojo&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;
      &lt;artifactId&gt;maven-plugin-api&lt;/artifactId&gt;
      &lt;version&gt;2.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>L'élément le plus important d'un POM de projet Plugin est la balise <varname>packaging</varname>, celle-ci doit contenir la valeur  
      <varname>maven-plugin</varname>.
      Ce type de packaging personnalise le cycle de vie Maven pour inclure les goals nécessaires à la création du descripteur de plugin.
      Le cycle de vie Plugin a été présenté dans le <xref linkend="lifecycle-sect-plugin-lifecycle" />,
      il ressemble fortement au cycle de vie Jar malgré ces trois exceptions :
      le goal <varname>plugin:descriptor</varname> est rattaché à la phase <varname>generate-resources</varname>, 
      le goal <varname>plugin:addPluginArtifactMetadata</varname> est rattaché à la phase <varname>package</varname>,
      et le goal <varname>plugin:updateRegistry</varname> est rattaché à la phase <varname>install</varname>.</para>

      <para>L'autre partie importante d'un POM de projet Plugin est la dépendance sur Maven Plugin API.
      Ici, le projet dépend de la version 2.0 du <varname>maven-plugin-api</varname> et possède une autre également une dépendance JUnit pour les tests.</para> 
    </section>

    <section id="writing-plugins-simple-java-mojo">
      <title>Un simple Mojo Java</title>

      <para>Dans ce chapitre, nous allons vous présenter comment écrire des Mojos en Java.
      Chaque Mojo de votre projet doit implémenter l'interface <classname>org.apache.maven.plugin.Mojo</classname>,
      l'exemple suivant présente la classe <classname>Mojo</classname> qui implémente cette interface <classname>Mojo</classname> par l'intermédiaire de la classe <classname>org.apache.maven.plugin.AbstractMojo</classname>.   
      Avant de rentrer dans le code de ce Mojo, commençons par regarder les méthodes de l'interface <classname>Mojo</classname> :</para>

      <variablelist>
        <varlistentry>
          <term><methodname>void setLog( org.apache.maven.monitor.logging.Log
          log )</methodname></term>

          <listitem>
            <para>Chaque implémentation de <classname>Mojo</classname> doit fournir un moyen de communiquer son avancement.
            L'exécution du goal a t-elle réussi ? Ou, au contraire, une erreur est-elle survenue durant l'exécution du goal ?
            Lorsque Maven charge et exécute un Mojo, il appelle la méthode <methodname>setLog()</methodname> et fournit ainsi une instance de logger à utiliser dans le plugin.</para>    
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>protected Log getLog()</methodname></term>

          <listitem>
            <para>Comme nous venons de voir, Maven appelle la méthode <methodname>setLog()</methodname> avant d'exécuter votre <classname>Mojo</classname>,  
            votre <classname>Mojo</classname> peut donc récupérer le logger injecté par l'intermédiaire de la méthode <methodname>getLog()</methodname>.
            Au lieu d'afficher l'avancement sur la sortie standard ou dans la console, il est préférable d'utiliser les méthodes de l'objet <classname>Log</classname>.</para>  
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>void execute() throws
          org.apache.maven.plugin.MojoExecutionException</methodname></term>

          <listitem>
            <para>Cette méthode est appelée par Maven lors de l'exécution du goal.</para> 
          </listitem>
        </varlistentry>
      </variablelist>

      <para>L'interface <classname>Mojo</classname> est responsable de deux choses : 
      afficher le résultat de l'exécution d'un goal et l'exécuter.
      Lorsque vous écrivez un plugin, vous pouvez faire hériter vos Mojos de la classe <classname>AbstractMojo</classname>. 
      <classname>AbstractMojo</classname> implémente les méthodes <varname>setLog()</varname> et <varname>getLog()</varname>.
      Reste à implémenter la méthode <methodname>execute()</methodname>qui est déclarée comme abstraite dans cette classe mère.  
      L'<xref linkend="ex-simple-echomojo" /> présente une implémentation simple d'un <classname>Mojo</classname> qui se contente d'afficher un message dans la console.</para> 

      <example id="ex-simple-echomojo">
        <title>Un simple EchoMojo</title>

        <programlisting language="java">package org.sonatype.mavenbook.plugins;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;

/**
 * Echos an object string to the output screen.
 * @goal echo
 * @requiresProject false
 */
public class EchoMojo extends AbstractMojo
{
    /**
     * Any Object to print out.
     * @parameter expression="\${echo.message}" default-value="Hello World..."
     */
    private Object message;

    public void execute()
        throws MojoExecutionException, MojoFailureException
    {
        getLog().info( message.toString() );
    }
}
</programlisting>
      </example>

      <para>Si vous créez ce Mojo dans un <varname>\${basedir}</varname> sous <filename>src/main/java</filename> à l'emplacement 
      <filename>org/sonatype/mavenbook/mojo/EchoMojo.java</filename> dans le projet créé précédemment et que vous exécuter la commande <command>mvn install</command>,  
      vous devriez être capable d'appeler votre goal directement à partir de la ligne de commande :</para>

      <screen>$ <command>mvn org.sonatype.mavenbook.plugins:first-maven-plugin:1.0-SNAPSHOT:echo</command></screen>

      <para>Cette (large) ligne de commande est un simple appel à <command>mvn</command> suivi d'un argument : <varname>groupId:artifactId:version:goal</varname>. 
      Lorsque vous exécutez cette ligne de commande, vous devriez voir apparaître le message "Hello Maven World..." dans votre console.
      Pour personnaliser ce message, vous pouvez passer le paramètre suivant à cette même ligne de commande :</para>

      <screen>$ <command>mvn org.sonatype.mavenbook.plugins:first-maven-plugin:1.0-SNAPSHOT:echo \
             -Decho.message="The Eagle has Landed"</command></screen>

      <para>Cette ligne de commande exécute le goal  <classname>EchoMojo</classname> et affiche le message "The Eagle has Landed".</para>

    </section>

    <section id="writing-plugins-sect-plugin-prefix">
      <title>Configuration d'un préfixe de Plugin</title>

      <para>Spécifier le <varname>groupId</varname>, l'<varname>artifactId</varname>, la <varname>version</varname> et <varname>goal</varname> est un peu lourd (c'est le moindre que l'on puisse dire). 
      Pour éviter cela, vous avez la possibilité d'utiliser un préfixe de plugin. Par exemple, au lieu de taper :</para>

      <screen>$ mvn org.apache.maven.plugins:maven-jar-plugin:2.2:jar</screen>

      <para>Vous pouvez utiliser le préfixe <varname>jar</varname>. Ainsi, la ligne de commande devient beaucoup plus digeste : <command>mvn jar:jar</command>.
      Comment Maven sait transformer <varname>jar:jar</varname> en <varname>org.apache.mven.plugins:maven-jar:2.3</varname> ?
      Maven regarde dans un fichier du repository pour obtenir la liste des plugins pour un <varname>groupId</varname> spécifique.
      Par défaut, Maven est configuré pour rechercher les plugins dans deux groupes : 
      <varname>org.apache.maven.plugins</varname> et <varname>org.codehaus.mojo</varname>.
      Lorsque vous spécifiez un nouveau préfixe comme <command>mvn hibernate3:hbm2ddl</command>,
      Maven scanne les métadonnées du répository à la recherche du plugin approprié.
      Maven commence par scanner les groupes  <varname>org.apache.maven.plugins</varname> à la recherche du préfixe <varname>hibernate3</varname>.
      S'il n'y trouve pas de préfixe <varname>hibernate3</varname>, il continuera par scanner les métadonnées du groupe <varname>org.codehaus.mojo</varname>.</para>  

      <para>Lorsque Maven scanne les métadonnées d'un <varname>groupId</varname>,
      il récupére le fichier <acronym>XML</acronym> à partir du répository dans lequel sont contenus les métadonnées des artefacts contenu dans un group.
      Ce fichier <acronym>XML</acronym> est spécifique à chaque repository référencé.
      Si vous n'avez pas configuré de dépôt, Maven se contentera de chercher dans les métadonnées du groupe <varname>org.apache.maven.plugins</varname>
      dans votre dépot local (<filename>~/.m2/repository</filename>) dans le fichier
      <filename>org/apache/maven/plugins/maven-metadata-central.xml</filename>.
      L'<xref linkend="ex-maven-metadata" /> présente une partie du fichier <acronym>XML</acronym> <filename>maven-metadata-central.xml</filename> du groupe 
      <varname>org.apache.maven.plugin</varname>.</para>

      <example id="ex-maven-metadata">
        <title>Métadonnées Maven du groupe Maven Plugin</title>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;metadata&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;name&gt;Maven Clean Plugin&lt;/name&gt;
      &lt;prefix&gt;clean&lt;/prefix&gt;
      &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
    &lt;plugin&gt;
      &lt;name&gt;Maven Compiler Plugin&lt;/name&gt;
      &lt;prefix&gt;compiler&lt;/prefix&gt;
      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
    &lt;plugin&gt;
      &lt;name&gt;Maven Surefire Plugin&lt;/name&gt;
      &lt;prefix&gt;surefire&lt;/prefix&gt;
      &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
    ...
  &lt;/plugins&gt;
&lt;/metadata&gt;</programlisting>
      </example>

      <para>Comme vous pouvez le voire dans l'<xref linkend="ex-maven-metadata" />,
      c'est ce fichier <filename>maven-metadata-central.xml</filename> qui rend possible l'exécution de la commande <command>mvn surefire:test</command>.   
      Maven scanne <varname>org.apache.maven.plugins</varname> et <varname>org.codehaus.mojo</varname> :
      les plugins du groupe <varname>org.apache.maven.plugins</varname> sont considérés comme des plugins core Maven,
      alors que les plugins du groupe <varname>org.apache.maven.plugins</varname> sont considérés comme des plugins moins importants.
      Le projet Apache Maven gère le groupe <varname>org.apache.maven.plugins</varname>, et un autre projet open source qui se charge du projet Codehaus Mojo. 
      Pour publier vos plugins dans votre propre <varname>groupId</varname>,
      vous désirez que Maven scanne automatiquement votre propre préfixe de plugin pour votre nouveau <varname>groupId</varname>. 
      Pour cela, vous pouvez personnaliser les groupes scannés par Maven à partir de vos Settings Maven.</para>

      <para>Pour exécuter votre goal echo <varname>first-maven-plugin</varname> en utilisant la commande <varname>first:echo</varname>,
      ajoutez le groupId <varname>org.sonatype.mavenbook.plugins</varname> dans votre fichier <filename>~/.m2/settings.xml</filename> comme montré dans l'<xref linkend="ex-plugin-groups" />.
      Ainsi, un nouveau groupe sera ajouté en début de liste des groupes scannés par Maven.</para>
       
      <example id="ex-plugin-groups">
        <title>Personnaliser les groupes de Plugin dans les Settings Maven</title>

        <programlisting language="xml">&lt;settings&gt;
  ...
  &lt;pluginGroups&gt;
    &lt;pluginGroup&gt;org.sonatype.mavenbook.plugins&lt;/pluginGroup&gt;
  &lt;/pluginGroups&gt;
&lt;/settings&gt;</programlisting>
      </example>

      <para>Ceci fait, vous pouvez maintenant exécuter votre goal par l'intermédiaire de la commande <command>mvn first:echo</command>
      à partir de n'importe quel répertoire. Vous constaterez que Maven saura interpréter correctement votre préfixe.   
      Cela fonctionne car le projet respecte certaines conventions de nommage.
      Si votre projet plugin a un <varname>artifactId</varname> qui suit les patterns <varname>maven-first-plugin</varname> ou
      <varname>first-maven-plugin</varname>, Maven affectera automatiquement le préfixe <varname>first</varname> à votre plugin. 
      En d'autres mots, lorsque le plugin Maven Plugin généré le descripteur de plugin de votre plugin et que vous n'avez pas spéficifié de <varname>goalPrefix</varname> dans votre projet,        
      le goal <varname>plugin:descriptor</varname> récupérera le préfixe de votre plugin à partir de son <varname>artifactId</varname> lorsqu'il suit l'un des patterns suivants :</para>

      <itemizedlist>
        <listitem>
          <para><varname>\${prefix}-maven-plugin</varname>, OR</para>
        </listitem>

        <listitem>
          <para><varname>maven-\${prefix}-plugin</varname></para>
        </listitem>
      </itemizedlist>

      <para>Si vous désirez mettre explicitement un préfixe de plugin, you avez besoin de configurer le plugin Maven Plugin.
      Le plugin Maven Plugin est responsable de la construction du descripteur de plugin et doit également effectuer certaines tâches durant les phases de packaging et de chargement. 
      Le plugin Maven Plugin est configurable comme n'importe quel autre plugin via la balise <varname>build</varname>.
      Pour configurer le préfixe de votre plugin, ajoutez le code XML dans la balise <varname>build</varname> du projet <varname>first-maven-plugin</varname>.</para>  

      <example id="ex-plugin-prefix">
        <title>Configuration d'un préfixe de Plugin</title>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;first-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;maven-plugin&lt;/packaging&gt;
  &lt;name&gt;first-maven-plugin Maven Mojo&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-plugin-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.3&lt;/version&gt;
        &lt;configuration&gt;
          &lt;goalPrefix&gt;blah&lt;/goalPrefix&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;
      &lt;artifactId&gt;maven-plugin-api&lt;/artifactId&gt;
      &lt;version&gt;2.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>L'<xref linkend="ex-plugin-prefix" /> configure le préfixe du plugin à <varname>blah</varname>. 
      Si vous avez ajouté le groupe <varname>org.sonatype.mavenbook.plugins</varname> à la liste des groupes 
      <sgmltag>pluginGroups</sgmltag> de votre fichier <filename>~/.m2/settings.xml</filename>, 
      vous devriez pouvoir exécuter le <classname>EchoMojo</classname> en lançant la commande suivante <command>mvn echo:blah</command>.</para>
    </section>

    <section id="writing-plugins-sect-logging">
      <title>Log à partir d'un Plugin</title>

      <para>Maven s'occupe de connecter votre mojo à un logger en appelant la méthode <methodname>setLog()</methodname>  avant l'exécution de votre Mojo.
      Il fournit une implémentation de la classe <classname>org.apache.maven.monitor.logging.Log</classname>.
      Cette classe expose des méthodes qui vous pouvez utiliser pour afficher des informations à vos utilisateurs.
      La classe <classname>Log</classname> fournit plusieurs niveaux de log, elle propose donc un mécanisme similaire à l'<acronym>API</acronym> fournie par <ulink
      url="http://logging.apache.org/">Log4J</ulink>. 
      Ces différents niveaux sont utilisables par l'intermédiaire de plus méthodes dédiées : debug, info, error et warn.
      Afin de sauver les arbres, nous ne listerons ici que les méthodes du niveau degug.</para>

      <variablelist>
        <varlistentry>
          <term><methodname>void debug( CharSequence message )</methodname></term>

          <listitem>
            <para>Affiche un message en utilisant le niveau debug.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>void debug( CharSequence message, Throwable t )</methodname></term>

          <listitem>
            <para>Affiche un message en utilisant le niveau debug et inclu une stack trace à partir d'un <classname>Throwable</classname>
            <classname>Exception</classname> ou <classname>Error</classname>)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>void debug( Throwable t )</methodname></term>

          <listitem>
            <para>Affiche la stack trace du <classname>Throwable</classname> (<classname>Exception</classname> ou <classname>Error</classname>)</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Chacun de ces quatre niveaux expose ces trois méthodes.
      Ces quatre niveaux répondent à quatre buts différents.
      Le niveau debug est dédié aux personnes qui désirent voir une vue très détaillée de ce qui se passe lors de l'exécution d'un Mojo.  
      Vous ne devez donc jamais présumer que vos utilisateurs utilisent ce niveau.
      Pour cela, il est préférable d'utiliser le niveau info qui est destiné à afficher des messages d'informations généralistes devant s'afficher lors d'une utilisation normale du mojo.
      Par exemple, si vous construisez un plugin qui compile du code, utilisez ce niveau info pour afficher la sortie du compilateur à l'écran.</para>

      <para>Le niveau de logging warn est utilisé pour afficher des événements et messages d'erreurs que votre Mojo pourrait rencontrer.
      Par exemple, si vous essayez d'exécuter un plugin qui compile du code source Ruby mais que votre code n'est pas disponible, un warning sera affiché. 
      Contrairement aux erreurs (qui disposent d'un niveau dédié : error), les warnings ne sont pas destinés à afficher des erreurs bloquantes.          
      Utilisez par exemple le niveau error lorsque votre Mojo qui doit compiler du code, ne trouve pas de compilateur.
      Dans ce cas, vous voudrez probablement afficher un message d'erreur et lever une exception.
      Vous pouvez présumer que vos utilisateurs verront les messages en info et tous les messages d'erreurs.</para>

    </section>

    <section id="writing-plugins-sect-class-annotations">
      <title>Annotations des Mojo</title>

      <para>Dans le plugin <varname>first-maven-plugin</varname>, vous n'avez pas écrit de descripteur de plugin, Maven s'est chargé d'en générer un pour vous.
      Pour cela, Maven utilise les informations du <acronym>POM</acronym> du projet et une liste d'annotations présentes dans votre classe <classname>EchoMojo</classname>.
      La classe <classname>EchoMojo</classname> contient une seule annotation : <classname>@goal</classname>.
      Voici la liste complète des annotations utilisables dans un <classname>Mojo</classname>.</para>          

      <para><variablelist>
          <varlistentry>
            <term>@goal &lt;goalName&gt;</term>

            <listitem>
              <para>C'est la seule annotation obligatoire, elle fournit un nom unique au goal que vous êtes en train d'écrire.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresDependencyResolution &lt;requireScope&gt;</term>

            <listitem>
              <para>Marque le mojo comme un mojo qui nécessite des dépendances dans un certain scope : compile, runtime ou test. 
              Par exemple, si la valeur de cette annotation est passée à <varname>test</varname>,                
              on empêche alors Maven d'exécuter ce Mojo si sa dépendance n'est pas résolue dans le scope test.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresProject (true|false)</term>

            <listitem>
              <para>Marque ce goal comme goal devant être exécuté à l'intérieur d'un projet.
              La valeur par défaut est <literal>true</literal>.
              À l'opposé, certains plugins comment archetype ne le sont pas.</para>  
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresReports (true|false)</term>

            <listitem>
              <para>Si vous voulez créer un plugin qui repose sur la présence de rapports,
              affectez cette annotation à <varname>true</varname>.
              La valeur par défaut de ce flag est <varname>false</varname>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@aggregator (true|false)</term>

            <listitem>
              <para>Un goal possédant cette propriété affectée à <varname>true</varname> est supposé ne s'exécuter qu'une seule fois lors de l'exécution d'un plan Maven.
              Cette propriété a été créée pour donner la possibilité aux développeurs d'agréger la sortie d'une série de build.
              Par exemple, si vous voulez créer un plugin qui effectue un rapport consolidant la sortie de projets. 
              Un goal avec <varname>aggregator</varname> affecté à <varname>true</varname> ne sevrait s'exécuter qu'à partir du projet de plus haut-niveau d'un build Maven.
              Sa valeur par défaut est <varname>false</varname>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresOnline (true|false)</term>

            <listitem>
              <para>Spécifie si un goal donné peut s'exécuter en mode offline.
              Si un goal nécessite l'utilisation de ressources réseau et que ce flag est activé, Maven affichera une erreur si le goal est exécuté en mode offline.
              La valeur par défaut pour cette propriété est <varname>false</varname>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresDirectInvocation</term>

            <listitem>
              <para>Si vous affectez cette propriété à <varname>true</varname>, 
            le goal pourra seulement s'exécuter s'il est appelé directement par la ligne de commande par un utilisateur.
            Si quelqu'un essaye de rattacher ce goal à une phase du cycle de cie dans un <acronym>POM</acronym>, Maven affichera un message d'erreur.             
            La valeur par défaut pour est propriété est <varname>false</varname>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@phase &lt;phaseName&gt;</term>

            <listitem>
              <para>Cette annotation spécifie la phase par défaut d'un goal.
              Si vous n'avez pas spécifié de phase pour exécuter ce goal, Maven rattachera celui-ci à la phase spécifiée par cette annotation.</para> 
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@execute [goal=goalName|phase=phaseName
            [lifecycle=lifecycleId]]</term>

            <listitem>
              <para>This annotation can be used in a number of ways. If a
              phase is supplied, Maven will execute a parallel lifecycle
              ending in the specified phase. The results of this separate
              execution will be made available in the Maven property
              <varname>\${executedProperty}</varname>.</para>

              <para>The second way of using this annotation is to specify an
              explicit goal using the <varname>prefix:goal</varname> notation.
              When you specify just a goal, Maven will execute this goal in a
              parallel environment that will not affect the current Maven
              build.</para>

              <para>The third way of using this annotation would be to specify
              a phase in an alternate lifecycle using the identifier of a
              lifecycle.</para>

              <programlisting language="java">@execute phase="package" lifecycle="zip"
@execute phase="compile"
@execute goal="zip:zip"</programlisting>
            </listitem>
          </varlistentry>
        </variablelist></para>

      <para>If you look at the source for <classname>EchoMojo</classname>,
      you'll notice that Maven is not using the standard annotations available
      in Java 5. Instead, it is using <ulink
      url="http://commons.apache.org/attributes/">Commons Attributes</ulink>.
      Commons Attributes provided a way for Java programmers to use
      annotations before annotations were a part of the Java language
      specification. Why doesn't Maven use Java 5 annotations? Maven doesn't
      use Java 5 annotations because it is designed to target pre-Java 5
      <acronym>JVM</acronym>s. Because Maven has to support older versions of
      Java, it cannot use any of the newer features available in Java
      5.</para>
    </section>

    <section id="writing-plugins-sect-failure">
      <title>When a Mojo Fails</title>

      <para>The <methodname>execute()</methodname> method in Mojo throws two
      exceptions <classname>MojoExecutionException</classname> and
      <classname>MojoFailureException</classname>. The difference between
      these two exception is both subtle and important, and it relates to what
      happens when a goal execution "fails". A
      <classname>MojoExecutionException</classname> is a fatal exception,
      something unrecoverable happened. You would throw a
      <classname>MojoExecutionException</classname> if something happens that
      warrants a complete stop in a build; you re trying to write to disk, but
      there is no space left, or you were trying to publish to a remote
      repository, but you can't connect to it. Throw a
      <classname>MojoExecutionException</classname> if there is no chance of a
      build continuing; something terrible has happened and you want the build
      to stop and the user to see a "BUILD ERROR" message.</para>

      <para>A <classname>MojoFailureException</classname> is something less
      catastrophic, a goal can fail, but it might not be the end of the world
      for your Maven build. A unit test can fail, or a <acronym>MD5</acronym>
      checksum can fail; both of these are potential problems, but you don't
      want to return an exception that is going to kill the entire build. In
      this situation you would throw a
      <classname>MojoFailureException</classname>. Maven provides for
      different "resiliency" settings when it comes to project failure. Which
      are described below.</para>

      <para>When you run a Maven build, it could involve a series of projects
      each of which can succeed or fail. You have the option of running Maven
      in three failure modes:</para>

      <variablelist>
        <varlistentry>
          <term>mvn -ff</term>

          <listitem>
            <para>Fail-fast mode: Maven will fail (stop) at the first build
            failure.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>mvn -fae</term>

          <listitem>
            <para>Fail-at-end: Maven will fail at the end of the build. If a
            project in the Maven reactor fails, Maven will continue to build
            the rest of the builds and report a failure at the end of the
            build.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>mvn -fn</term>

          <listitem>
            <para>Fail never: Maven won't stop for a failure and it won't
            report a failure.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>You might want to ignore failure if you are running a continuous
      integration build and you want to attempt a build regardless of the
      success of failure of an individual project build. As a plugin
      developer, you'll have to make a call as to whether a particular failure
      condition is a <classname>MojoExecutionException</classname> or a
      <classname>MojoFailureExeception</classname>.</para>
    </section>
  </section>

  <section id="writing-plugins-sect-mojo-params">
    <title>Mojo Parameters</title>

    <para>Just as important as the <methodname>execute()</methodname> method
    and the Mojo annotations, a Mojo is configured via parameters. This
    section deals with some configuration and topics surrounding Mojo
    parameters.</para>

    <section id="writing-plugins-sect-param-values">
      <title>Supplying Values for Mojo Parameters</title>

      <para>In EchoMojo we declared the message parameter with the following
      annotations:</para>

      <programlisting language="java">/**
 * Any Object to print out.
 * @parameter
 *       expression="\${echo.message}"
 *       default-value="Hello Maven World"
 */
private Object message;
</programlisting>

      <para>The default expression for this parameter is
      <varname>\${echo.message}</varname>, this means that Maven will try to
      use the value of the <varname>echo.message</varname> property to set the
      value for message. If the value of the <varname>echo.message</varname>
      property is null, the default-value attribute of the
      <classname>@parameter</classname> annotation will be used instead.
      Instead of using the <varname>echo.message</varname> property, we can
      configure a value for the message parameter of the EchoMojo directly in
      a project's <acronym>POM</acronym>.</para>

      <para>There are a few ways to populate the message parameter in the
      <classname>EchoMojo</classname>. First we can pass in a value from the
      command-line like this (assuming that you've added
      <varname>org.sonatype.mavenbook.plugins</varname> to your
      <sgmltag>pluginGroups</sgmltag>):</para>

      <screen>$ mvn first:echo -Decho.message="Hello Everybody"</screen>

      <para>We could also specify the value of this message parameter, by
      setting a property in our <acronym>POM</acronym> or in our
      <filename>settings.xml</filename>.</para>

      <programlisting language="xml">&lt;project&gt;
  ...
  &lt;properties&gt;
    &lt;echo.message&gt;Hello Everybody&lt;/echo.message&gt;
  &lt;/properties&gt;
&lt;/project&gt;
</programlisting>

      <para>This parameter could also be configured directly as a
      configuration value for the plugin. If we wanted to customize the
      message parameter directly, we could use the following build
      configuration. The following configuration bypasses the echo.message
      property and populates the Mojo parameter in plugin
      configuration.</para>

      <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;first-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;configuration&gt;
          &lt;message&gt;Hello Everybody!&lt;/message&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>

      <para>If we wanted to run the <classname>EchoMojo</classname> twice at
      difference phases in a lifecycle, and we wanted to customize the message
      parameter for each execution separately, we could configure the
      parameter value at the execution level in a <acronym>POM</acronym> like
      this:</para>

      <programlisting language="xml">&lt;build&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;first-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;first-execution&lt;/id&gt;
            &lt;phase&gt;generate-resources&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;echo&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;message&gt;The Eagle has Landed!&lt;/message&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
          &lt;execution&gt;
            &lt;id&gt;second-execution&lt;/id&gt;
            &lt;phase&gt;validate&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;echo&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;message&gt;\${project.version}&lt;/message&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/build&gt;</programlisting>

      <para>While this last configuration example seems very verbose, it
      illustrates the flexibility of Maven. In the previous configuration
      example, you've bound the <classname>EchoMojo</classname> to both the
      <varname>validate</varname> and <varname>generate-resources</varname>
      phases in the default Maven lifecycle. The first execution is bound to
      <varname>generate-resources</varname>, it supplies a string value to the
      message parameter of "The Eagle has Landed!". The second execution is
      bound to the <varname>validate</varname> phase, it supplies a property
      reference to <varname>\${project.version}</varname>. When you run
      <command>mvn install</command> for his project, you'll see that the
      <varname>first:echo</varname> goal executes twice and prints out two
      different messages.</para>
    </section>

    <section id="writing-plugins-sect-multival-params">
      <title>Multi-valued Mojo Parameters</title>

      <para>Plugins can have parameters which accept more than one value. Take
      a look at the <classname>ZipMojo</classname> shown in <xref
      linkend="ex-plugin-multivalue" />. Both the <varname>includes</varname>
      and <varname>excludes</varname> parameters are multivalued
      <classname>String</classname> arrays which specify the inclusion and
      exclusion patterns for a component that creates a <acronym>ZIP</acronym>
      file.</para>

      <example id="ex-plugin-multivalue">
        <title>A Plugin with Multi-valued Parameters</title>

        <programlisting language="java">package org.sonatype.mavenbook.plugins

/**
 * Zips up the output directory.
 * @goal zip
 * @phase package
 */
public class ZipMojo extends AbstractMojo
{
    /**
     * The Zip archiver.
     * @parameter \
         expression="\${component.org.codehaus.plexus.archiver.Archiver#zip}"
     */
    private ZipArchiver zipArchiver;

    /**
     * Directory containing the build files.
     * @parameter expression="\${project.build.directory}"
     */
    private File buildDirectory;

    /**
     * Base directory of the project.
     * @parameter expression="\${basedir}"
     */
    private File baseDirectory;

    /**
     * A set of file patterns to include in the zip.
     * @parameter alias="includes"
     */
    private String[] mIncludes;

    /**
     * A set of file patterns to exclude from the zip.
     * @parameter alias="excludes"
     */
    private String[] mExcludes;

    public void setExcludes( String[] excludes ) { mExcludes = excludes; }

    public void setIncludes( String[] includes ) { mIncludes = includes; }

    public void execute()
        throws MojoExecutionException
    {
        try {
            zipArchiver.addDirectory( buildDirectory, includes, excludes );
            zipArchiver.setDestFile( new File( baseDirectory, "output.zip" ) );
            zipArchiver.createArchive();
        } catch( Exception e ) {
            throw new MojoExecutionException( "Could not zip", e );
        }
    }
}
</programlisting>

        <para>To configure a multi-valued Mojo parameter, you use a series of
        elements for each value. If the name of the multi-valued parameter is
        <varname>includes</varname>, you would use an element
        <sgmltag>includes</sgmltag> with child elements
        <sgmltag>include</sgmltag>. If the multi-valued parameter is
        <varname>excludes</varname>, you would use an element
        <sgmltag>excludes</sgmltag> with child elements
        <sgmltag>exclude</sgmltag>. To configure the
        <classname>ZipMojo</classname> to ignore all files ending in
        <varname>.txt</varname> and all files ending in a tilde, you would use
        the following plugin configuration.</para>
      </example>

      <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;zip-maven-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;excludes&gt;
            &lt;exclude&gt;**/*.txt&lt;/exclude&gt;
            &lt;exclude&gt;**/*~&lt;/exclude&gt;
          &lt;/excludes&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</programlisting>
    </section>

    <section id="writing-plugins-sect-depend-plexus">
      <title>Depending on Plexus Components</title>

      <para>A Mojo is a component managed by an <acronym>IoC</acronym>
      container called Plexus. A Mojo can depend on other components managed
      by Plexus by declaring a Mojo parameter and using the
      <classname>@parameter</classname> or the
      <classname>@component</classname> annotation. <xref
      linkend="ex-plugin-multivalue" /> shows a <classname>ZipMojo</classname>
      which depends on a Plexus component using the
      <classname>@parameter</classname> annotation, this dependency could be
      declared using the <classname>@component</classname> annotation.</para>

      <example>
        <title>Depending on a Plexus Component</title>

        <programlisting language="java">/**
 * The Zip archiver.
 * @component role="org.codehaus.plexus.archiver.Archiver" roleHint="zip"
 */
private ZipArchiver zipArchiver;</programlisting>
      </example>

      <para>When Maven instantiates this Mojo, it will then attempt to
      retrieve the Plexus component with the specified role and role hint. In
      this example, the Mojo will be related to a ZipArchiver component which
      will allow the <classname>ZipMojo</classname> to create a
      <acronym>ZIP</acronym> file.</para>

      <!--TODO: OK, we need more here.  How do I get my hands on components?  How to a bundle components?-->
    </section>

    <section id="writing-plugins-sect-param-annot">
      <title>Mojo Parameter Annotations</title>

      <para>Unless you insist on writing your Plugin descriptors by hand,
      you'll never have to write that <acronym>XML</acronym>. Instead, the
      Maven Plugin Plugin has a <varname>plugin:descriptor</varname> goal
      bound to the generate-resources phase. This goal generates the plugin
      descriptor from annotations on your Mojo. To configure a Mojo parameter,
      you should use the following annotations on either the private member
      variables for each of your Mojo's parameters. You can also use these
      annotations on public setter methods, but the most common convention for
      Maven plugins is to annotate private member variables directly.</para>

      <variablelist>
        <varlistentry>
          <term>@parameter [alias="someAlias"]
          [expression="\${someExpression}"] [default-value="value"]</term>

          <listitem>
            <para>Marks a private field (or a setter method) as a parameter.
            The <varname>alias</varname> provides the name of the parameter.
            If <varname>alias</varname> is omitted, Maven will use the name of
            the variable as the parameter name. The
            <varname>expression</varname> is an expression that Maven will
            evaluate to obtain a value. Usually the expression is a property
            reference like <varname>\${echo.message}</varname>.
            <varname>default-value</varname> is the value that this Mojo will
            use if no value can be derived from the expression or if a value
            was not explicitly supplied via plugin configuration in a
            <acronym>POM</acronym>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@required</term>

          <listitem>
            <para>If this annotation is present, a valid value for this
            parameter is required prior to Mojo execution. If Maven tries to
            execute this Mojo and the parameter has a null value, Maven will
            throw and error when it tries to execute this goal.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@readonly</term>

          <listitem>
            <para>If this annotation is present, the user cannot directly
            configure this parameter in the <acronym>POM</acronym>. You would
            use this annotation with the expression attribute of the parameter
            annotation. For example, if you wanted to make sure that a
            particular parameter always had the value of the
            <varname>finalName</varname> <acronym>POM</acronym> property, you
            would list an expression of <varname>\${build.finalName}</varname>
            and then add the <classname>@readOnly</classname> annotation. If
            this were the case, the user could only change the value of this
            parameter by changing the value of <varname>finalName</varname> in
            the <acronym>POM</acronym>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@component</term>

          <listitem>
            <para>Tells Maven to populate a field with a Plexus Component. A
            valid value for the <classname>@component</classname> annotation
            would be:</para>

            <programlisting language="java">@component role="org.codehaus.plexus.archiver.Archiver" roleHint="zip"
</programlisting>

            <para>This would have the effect of retrieving the
            <classname>ZipArchiver</classname> from Plexus. The
            <classname>ZipArchiver</classname> is the Archiver which
            corresponds to the role hint <varname>zip</varname>. Instead of
            component, you could also use the @parameter annotation with an
            expression attribute of:</para>

            <programlisting language="java">@parameter expression="\${component.org.codehaus.plexus.archiver.Archiver#zip}"
</programlisting>

            <para>While the two annotations are effectively the same, the
            <classname>@component</classname> annotation is the preferred way
            to configure dependencies on Plexus components.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@deprecated</term>

          <listitem>
            <para>The parameter will be deprecated. Users can continue
            configuring this parameter, but a warning message will be
            displayed.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section id="writing-plugins-sect-plugins-lifecycle">
    <title>Plugins and the Maven Lifecycle</title>

    <para>In the <xref linkend="lifecycle" /> chapter, you learned that
    lifecycles can be customized by packaging types. A plugin can both
    introduce a new packaging type and customize the lifecycle. In this
    section, you are going to learn how you can customize the lifecycle from a
    custom Maven plugin. You are also some to see how you can tell a Mojo to
    execute a parallel lifecycle.</para>

    <section id="writing-plugins-sect-execute-parallel-lifecycle">
      <title>Executing a Parallel Lifecycle</title>

      <para>Let's assume you write some goal that depends on the output from a
      previous build. Maybe the <classname>ZipMojo</classname> goal can only
      run if there is output to include in an archive. You can specify
      something like a prerequisite goal by using the
      <classname>@execute</classname> annotation on a Mojo class. This
      annotation will cause Maven to spawn a parallel build and execute a goal
      or a lifecycle in a parallel instance of Maven that isn't going to
      affect the current build. Maybe you wrote some Mojo that you can to run
      once a day that runs <command>mvn install</command> and then packages up
      all of the output in some sort of customized distribution format. Your
      Mojo descriptor could tell Maven that before you execute your
      <classname>CustomMojo</classname>, you'd like it to execute the default
      lifecycle up to the install phase and then expose the results of that
      project to your Mojo as the property
      <varname>\${executedProject}</varname>. You could then reference
      properties in that project to before some sort of post
      processing.</para>

      <para>Another possibility is that you have a goal that does something
      completely unrelated to the default lifecycle. Let's consider something
      completely unexpected, maybe you have a goal that turns a
      <acronym>WAV</acronym> file into an <acronym>MP3</acronym> using
      something like <acronym>LAME</acronym>, but before you do that, you want
      to step through a lifecycle that turns a <acronym>MIDI</acronym> file to
      a <acronym>WAV</acronym>. (You can use Maven for anything; this isn't
      that "far out".) You've created a "midi-sound" lifecycle, and you want
      to include the output of the <varname>midi-sound</varname> lifecycle's
      <varname>install</varname> phase in your web application project which
      has a <varname>war</varname> packaging type. Since your project is
      running in the <varname>war</varname> packaging lifecycle, you'll need
      to have a goal that effectively forks off an isolated build and runs
      through the <varname>midi-source</varname> lifecycle. You would do this
      by annotating your mojo with <varname>@execute lifecycle="midi-source"
      phase="install"</varname>.</para>

      <variablelist>
        <varlistentry>
          <term>@execute goal="&lt;goal&gt;"</term>

          <listitem>
            <para>This will execute the given goal before execution of this
            one. The goal name is specified using the
            <varname>prefix:goal</varname> notation.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@execute phase="&lt;phase&gt;"</term>

          <listitem>
            <para>This will fork an alternate build lifecycle up to the
            specified phase before continuing to execute the current one. If
            no lifecycle is specified, Maven will use the lifecycle of the
            current build.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@execute lifecycle="&lt;lifecycle&gt;"
          phase="&lt;phase&gt;"</term>

          <listitem>
            <para>This will execute the given alternate lifecycle. A custom
            lifecycle can be defined in
            <filename>META-INF/maven/lifecycle.xml</filename>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section id="writing-plugins-sect-custom-lifecycle">
      <title>Creating a Custom Lifecycle</title>

      <para>A custom lifecycle must be packaged in the plugin under the
      <filename>META-INF/maven/lifecycle.xml</filename> file. You can include
      a lifecycle under <filename>src/main/resources</filename> in
      <filename>META-INF/maven/lifecycle.xml</filename>. The following
      <filename>lifecycle.xml</filename> declares a lifecycle named
      <varname>zipcycle</varname> that contains only the
      <varname>zip</varname> goal in a <varname>package</varname>
      phase.</para>

      <para><example>
          <title>Define a Custom Lifecycle in lifecycle.xml</title>

          <programlisting language="xml">&lt;lifecycles&gt;
  &lt;lifecycle&gt;
    &lt;id&gt;zipcycle&lt;/id&gt;
    &lt;phases&gt;
      &lt;phase&gt;
        &lt;id&gt;package&lt;/id&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;goals&gt;
              &lt;goal&gt;zip&lt;/goal&gt;
            &lt;/goals&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/phase&gt;
    &lt;/phases&gt;
  &lt;/lifecycle&gt;
&lt;/lifecycles&gt;
</programlisting>
        </example></para>

      <para>If you wanted to execute the <varname>zipcycle</varname> phase
      within another build, you could then create a
      <classname>ZipForkMojo</classname> which uses the
      <classname>@execute</classname> annotation to tell Maven to step through
      the <varname>zipcycle</varname> phase to package when the
      <classname>ZipForkMojo</classname> is executed.</para>

      <para><example>
          <title>Forking a Customer Lifecycle from a Mojo</title>

          <programlisting language="java">/**
 * Forks a zip lifecycle.
 * @goal zip-fork
 * @execute lifecycle="zipcycle" phase="package"
 */
public class ZipForkMojo extends AbstractMojo
{
  public void execute()
    throws MojoExecutionException
  {
    getLog().info( "doing nothing here" );
  }
}
</programlisting>
        </example></para>

      <para>Running the <classname>ZipForkMojo</classname> will fork the
      lifecycle. If you've configured your plugin to execute with the goal
      prefix <varname>zip</varname>, running <varname>zip-fork</varname>
      should produce something similar to the following output.</para>

      <screen>$ mvn zip:zip-fork
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'zip'.
[INFO] ----------------------------------------------------------------------
[INFO] Building Maven Zip Forked Lifecycle Test
[INFO]    task-segment: [zip:zip-fork]
[INFO] ----------------------------------------------------------------------
[INFO] Preparing zip:zip-fork
[INFO] [site:attach-descriptor]
[INFO] [zip:zip]
[INFO] Building zip: \
   ~/maven-zip-plugin/src/projects/zip-lifecycle-test/target/output.zip
[INFO] [zip:zip-fork]
[INFO] doing nothing here
[INFO] ---------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ---------------------------------------------------------------------
[INFO] Total time: 1 second
[INFO] Finished at: Sun Apr 29 16:10:06 CDT 2007
[INFO] Final Memory: 3M/7M
[INFO] ---------------------------------------------------------------------
</screen>

      <para>Calling <varname>zip-fork</varname> spawned another lifecycle,
      Maven executed the <varname>zipcycle</varname> lifecycle then it printed
      out the message from <classname>ZipFormMojo</classname>'s execute
      method.</para>
    </section>

    <section id="writing-plugins-sect-override-default-lifecycle">
      <title>Overriding the Default Lifecycle</title>

      <para>Once you've created your own lifecycle and spawned it from a Mojo.
      The next question you might have is how do you override the default
      lifecycle. How do you create custom lifecycles and attach them to
      projects? In <xref linkend="lifecycle" />, we saw that the packaging of
      a project defines the lifecycle of a project. There's something
      different about almost every packaging type; <varname>war</varname>
      attached different goals to package, custom lifecycles like
      <varname>swf</varname> from the Israfil Flex 3 plugin attach different
      goals to the compile phase. When you create a custom lifecycle, you can
      attach that lifecycle to a packaging type by supplying some Plexus
      configuration in your plugin's archive.</para>

      <para>To define a new lifecycle for a new packaging type, you'll need to
      configure a <classname>LifecycleMapping</classname> component in Plexus.
      In your plugin project, create a
      <filename>META-INF/plexus/components.xml</filename> under
      src/main/resources. In components.xml add the content from <xref
      linkend="ex-override-lifecycle" />. Set the name of the packaging type
      under <varname>role-hint</varname>, and the set of phases containing the
      coordinates of the goals to bind (omit the version). Multiple goals can
      be associated with a phase using a comma delimited list.</para>

      <para><example id="ex-override-lifecycle">
          <title>Overriding the Default Lifecycle</title>

          <programlisting language="xml">&lt;component-set&gt;
  &lt;components&gt;
    &lt;component&gt;
      &lt;role&gt;org.apache.maven.lifecycle.mapping.LifecycleMapping&lt;/role&gt;
      &lt;role-hint&gt;zip&lt;/role-hint&gt;
      &lt;implementation&gt;
        org.apache.maven.lifecycle.mapping.DefaultLifecycleMapping
      &lt;/implementation&gt;
      &lt;configuration&gt;
        &lt;phases&gt;
          &lt;process-resources&gt;
            org.apache.maven.plugins:maven-resources-plugin:resources
          &lt;/process-resources&gt;
          &lt;compile&gt;
            org.apache.maven.plugins:maven-compiler-plugin:compile
          &lt;/compile&gt;
          &lt;package&gt;org.sonatype.mavenbook.plugins:maven-zip-plugin:zip&lt;/package&gt;
        &lt;/phases&gt;
      &lt;/configuration&gt;
    &lt;/component&gt;
  &lt;/components&gt;
&lt;/component-set&gt;
</programlisting>
        </example></para>

      <para>If you create a plugin which defines a new packaging type and a
      customized lifecycle, Maven won't know anything about it until you add
      the plugin to your project's <acronym>POM</acronym> and set the
      extensions element to true. Once you do this, Maven will scan your
      plugin for more than just Mojos to execute, it will look for the
      <filename>components.xml</filename> under
      <filename>META-INF/plexus</filename>, and it will make the packaging
      type available to your project.</para>

      <para><example>
          <title>Configuring a Plugin as an Extension</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    ...
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;com.training.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-zip-plugin&lt;/artifactId&gt;
        &lt;extensions&gt;true&lt;/extensions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>Once you add the plugin with the extensions element set to true,
      you can use the custom packaging type and your project will be able to
      execute the custom lifecycle associated with that packaging type.</para>
    </section>
  </section>
</chapter>
