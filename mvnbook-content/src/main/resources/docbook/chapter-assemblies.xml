<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="assemblies">
  <title>Maven Assemblies</title>

  <section id="assemblies-sect-intro">
    <title>Introduction</title>

    <para>Maven fournit des plugins qui sont utilisés pour créer des
    archives dans les formats les plus courants, et qui seront pour la
    plupart utilisées comme dépendances d'autres projets. Par exemples
    nous avons les plugins <acronym>JAR</acronym>, <acronym>WAR</acronym>,
    <acronym>EJB</acronym> et <acronym>EAR</acronym>. Comme nous l'avons
    déjà vu dans le <xref linkend="lifecycle" /> ces plugins correspondent
    à différents formats de packaging de projet, chacun avec son processus
    de build légérement différent. Même si Maven supporte les différents
    formats standards de packagaing grâce à ses plugins et des cycles de vie
    personnalisés, il va arriver un moment où vous aurez besoin de créer une
    archive ou un répertoire avec une structure qui lui est propre. Ces archives
    personnalisées sont appelées Assemblies Maven.</para>

    <para>Il existe de nombreuses raisons pour lesquelles vous voulez construire
    ces archives personnalisées pour votre projet. La plus courante, peut-être,
    est la distribution du projet. Ce mot 'distribution' peut signifier plusieurs
    choses selon la personne qui l'emploie (ou selon le projet), tout cela dépendant
    de la manière dont le projet doit être utilisé. Essentiellement, il s'agit
    d'archives qui fournissent un moyen simple pour les utilisateurs d'installer
    ou d'utiliser le produit du projet. Dans certains cas, cela peut signifier
    fournir un serveur d'application comme Jety avec l'application Web. Dans d'autres,
    il s'agit de fournir un paquet contenant le code source, la documentation de l'API
    avec le binaire compilé comme par exemple un fichier jar. C'est souvent lorsque
    vous êtes en train de construire la version distribuable d'un produit que les assemblies
    vont pouvoir vous aider. Par exemple, les produits comme Nexus dont on parle plus
    en détail dans <ulink
    url="http://www.sonatype.com/books/nexus-book/reference/">Repository
    Management with Nexus</ulink>, sont le résultat de plusieurs énormes projets
    Maven multimodules, et c'est une assembly Maven qui a construit l'archive finale
    que vous téléchargez depuis Sonatype.</para>

    <para>Dans la plupart des cas, le plugin Assembly est idéallement taillé
    pour construire des packages distribuables de projets. Cependant, les assemblies
    ne sont pas forcéemnt des archives distribuables ; les assemblies doivent apporter
    aux utilisateurs de Maven la flexibilité dont ils ont besoin pour produire des
    achives personnalisées de tout type.
    Essentiellement, les assemblies doivent combler les trous entre les formats
    standards d'archive fournis par les types de packaging des projets. Bien sûr,
    vous pourriez écrire un plugin Maven complet pour produire votre propre
    format d'archive, avec une nouvelle association au cycle de vie et la
    configuration de gestion d'artefact pour indiquer à Maven comment le déployer.
    Mais le plugin Assembly rend tout cela superflu dans la plupart des cas en vous
    donnant les moyen de construire votre archive selon votre propre recette sans
    avoir à écrire une ligne de code Maven.</para>
  </section>

  <section id="assemblies-sect-basics">
    <title>Les bases du plugin Assembly</title>

    <para>Avant d'aller plus loin, prenons une minute pour parler des deux principaux
    goals du plugin Assembly : <varname>assembly:assembly</varname> et le mojo
    <varname>single</varname>. J'ai cité ces deux goals de manière différente pour
    indiquer qu'on ne les utilise pas de la même manière. Le goal
    <varname>assembly:assembly</varname> est conçu pour être invoqué directement
    depuis la ligne de commande et il ne doit jamais être lié à une hase du cycle 
    de vie. Au contraire, le mojo <varname>single</varname> est lui conçu pour
    faire partie de votre build de tous les jours et doit être rattaché à une phase
    du cycle de vie du build de votre projet.</para>

    <para>La raison de cette différence est que le le goal 
    <varname>assembly:assembly</varname> est ce que Maven appelle un mojo
    aggrégateur ; c'est à dire un mojo qui a été conçu pour pour être exécuté
    au plus une fois dans un build, quelque soit le nombre de projets qui sont
    construits. Il prend sa configuration du projet racine - habituellement
    le <acronym>POM</acronym> de plus haut niveau ou la ligne de commande.
    Quand il est rattaché à un cycle de vie, un mojo aggrégateur peut provoquer
    de désagréables effets secondaires. Il peut forcer l'exécution de la phase
    <varname>package</varname> du cycle de vie en avance de phase, ce qui fait que le build
    exécute cette phase <varname>package</varname> deux fois.</para>

    <para>Comme le goal <varname>assembly:assembly</varname> est un mojo aggrégateur,
    cela peut poser des problèmes avec les builds Maven multimodules et il doit donc
    être appelé seul en ligne de commande. Ne rattachez jamais l'exécution de
    <varname>assembly:assembly</varname> à une phase du cycle de vie.
    <varname>assembly:assembly</varname> était le goal originel du plugin Assembly
    et il n'a jamais été conçu pour faire partie du processus standard de build
    d'un projet. Quand il est devenu clair que les archives produites par assembly
    étaient une exigence légitime des projets le mojo <varname>single</varname> a été
    développé. Ce mojo suppose qu'il a été rattaché à la bonne partie du processus
    de build et que donc il aura accès aux fichiers et artefacts du projetdont il
    a besoin pour s'exécuter au sein d'un grand projet Maven multimodule. Dans un
    environnemet multimodule il s'exécutera autant de fois qu'il est lié aux
    <acronym>POM</acronym>s des différetes modules. Contrairement à
    <varname>assembly:assembly</varname>, <varname>single</varname> ne forcera
    jamais l'exécution d'une étape du cycle de vie en avance de phase.</para>

    <para>Le plugin Assembly propose plusieurs autres goals en plus de ces deux là.
    Cependant le détail de ces autres mojos dépasse le cadre de ce chapitre, parce
    qu'ils servent des cas d'utilisation obsoletes ou exotiques et parce qu'on a
    très rarement besoin d'eux. Autant que possible, pour produire vos packages
    utilisez <varname>assembly:assembly</varname> depuis la ligne de commande et
    <varname>single</varname> pour rattacher cette opération aux phases du cycle
    de vie.</para>

    <section id="assemblies-sect-predefined">
      <title>Les descripteurs Assembly prédéfinis</title>

      <para>Nombreux sont ceux qui choisissent de créer leurs propres recettes -
      appelées descripteurs assembly - cependant cela n'est pas forcément
      nécessaire. Le plugin Assembly fournit des descripteurs prêts à l'emploi
      pour plusieurs types communs d'archives. Vous pouvez donc les utiliser
      immédiatement sans écrire une ligne de configuration. Voici la liste
      des descripteurs assembly prédéfinis dans le plugin Maven Assembly :</para>

      <variablelist>
        <varlistentry>
          <term><varname>bin</varname></term>

          <listitem>
            <para>Le descripteur <varname>bin</varname> est utilisé pour packager
            les fichiers <filename>LICENSE</filename>, <filename>README</filename>
            et <filename>NOTICE</filename> du projet avec on artefact principal, pour
            peu que ce dernier soit un jar. Vous pouvez voir cela comme la plus petite
            distribution binaire pour un projet autoporté.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>jar-with-dependencies</varname></term>

          <listitem>
            <para>Le descripteur <varname>jar-with-dependencies</varname> construit
            une archive <acronym>JAR</acronym> avec le contenu du jar du projet principal
            et les contenus des dépendances d'exécution de ce projet. Associé avec la bonne
            définition de la <varname>Main-Class</varname> Manifest ( dont on parle dans
            “Plugin Configuration” ci-dessous), ce descripteur permet de produire un jar exécutable
            autoporté de votre projet, même si ce projet a des dépendances.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>project</varname></term>

          <listitem>
            <para>Le descripteur <varname>project</varname> construit une archive
            à partir de la structure du répertoire du projet telle qu'elle existe sur
            votre système de fichier, et probablement dans votre outil de gestion de 
            configuration. Bien sûr, le répertoire <filename>target</filename> n'est
            pas pris en compte ainsi que les fichiers de métadonnées comme les
            répertoires <filename>CVS</filename> et <filename>.svn</filename> que nous
            avons l'habitude de voir. En bref, le but de ce descripteur est de créer
            une archive du projet qui, une fois décompressée, permet de construire
            le projet avec Maven.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>src</varname></term>

          <listitem>
            <para>Le descripteur <varname>src</varname> produit une archive du code source
            de votre projet avec les fichiers <filename>pom.xml</filename>, ainsi que les
            évntuels fichiers <filename>LICENSE</filename>,
            <filename>README</filename> et <filename>NOTICE</filename> qui se trouvent
            dans le répertoire racine du projet. Ce descripteur produit une archive 
            qui peut être construite par Maven dans la plupart des cas. Cependant,
            comme il suppose que tout le code source et les ressources sont dans le 
            répertoire standard <filename>src</filename> et donc il peut oublier
            les fichiers et les répertoires non-standards même s'ils sont critiques
            pour le build.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section id="assemblies-sect-building">
      <title>Construire une Assembly</title>

      <para>Le plugin Assembly peut être exécuté de deux manières : vous pouvez
      l'invoquer directement depuis la ligne de commande ou le configurer comme
      un élément standard de votre processus de build en le rattachant à une
      phase du cycle de vie du build de votre projet. L'invocation directe a son
      utilité , particulièrement pour les assemblies qui ne font pas partie des
      principaux délivrables de votre projet. Dans la plupart des cas, vous
      voudrez produire les assemblies de votre projet au cours de son processus
      de build standard. Ainsi vos packagings personnalisés sont inclus lorsque
      votre projet est installé ou deployé dans les dépôts Maven et ils sont donc
      toujours disponibles pour vos utilisateurs.</para>

      <para>Comme exemple d'inocation directe du plugin Assembly, imaginez que vous
      voulez livrer une copie de votre projet que l'on puisse construire à partir des
      sources. Au lieu de le déployer le produit final du build vous voulez aussi
      inclure le code source. Ce n'est pas une opération que vous avez besoin de répeter
      souvent, donc ça n'a pas de sens que d'ajouter cette configuration à votre
      <sgmltag>POM</sgmltag>. AU lieu de cela, vous pouvez utiliser la commande
      suivante : </para>
      <screen>$ <command>mvn -DdescriptorId=project assembly:single</command> 
...
[INFO] [assembly:single] 
[INFO] Building tar : /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
                      target/direct-invocation-1.0-SNAPSHOT-project.tar.gz 
[INFO] Building tar : /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
                      target/direct-invocation-1.0-SNAPSHOT-project.tar.bz2
[INFO] Building zip: /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
                      target/direct-invocation-1.0-SNAPSHOT-project.zip
...</screen>

      <para>Imaginez que vous voulez produire un <acronym>JAR</acronym>
      exécutable à partir de votre projet. Si votre projet est autoporté
      et sans dépendacevous pouvez obtenir ce résultat à partir de votre
      artefact avec un peu de configuration du plugin <acronym>JAR</acronym>.
      Cependant, la plupart des projets ont des dépendances et celles-ci
      doivent être incorporées pour obtenir un <acronym>JAR</acronym> exécutable.
      Dans ce cas, vous voulez vous assurer qu'à chaque fois que vous installez ou
      déployez l'artefact <acronym>JAR</acronym> de votre projet, le <acronym>JAR</acronym>
      exécutable le soit aussi.</para>

      <para>Supposons que la classe princiaple de votre projet est
      <classname>org.sonatype.mavenbook.App</classname>, la configuration de
      <acronym>POM</acronym> suivante permet de crer un <acronym>JAR</acronym>
      exécutable :</para>

      <example>
        <title>Descripteur assembly pour un JAR exécutable</title>

        <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;

  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
  &lt;artifactId&gt;executable-jar&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;name&gt;Assemblies Executable Jar Example&lt;/name&gt;
  &lt;url&gt;http://sonatype.com/book&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;commons-lang&lt;/groupId&gt;
      &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;
      &lt;version&gt;2.4&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
 &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2-beta-2&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;create-executable-jar&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;descriptorRefs&gt;
                &lt;descriptorRef&gt;
                  jar-with-dependencies
                &lt;/descriptorRef&gt;
              &lt;/descriptorRefs&gt;
              &lt;archive&gt;
                &lt;manifest&gt;
                  &lt;mainClass&gt;org.sonatype.mavenbook.App&lt;/mainClass&gt;
                &lt;/manifest&gt;
              &lt;/archive&gt;
           &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>Il y a deux points auxquels ilfaut prêter attention dans la 
      configuration ci-dessus. Premièrement, nous utilisons l'élément 
      <sgmltag>descriptorRefs</sgmltag> dans configuration plutôt que
      le paramètre <sgmltag>descriptorId</sgmltag> que nous avions utilisé
      précédemment. cela nous permet de construire différents packages
      durant la même exécution du plugin Assembly tout en supportant
      notre cas d'utilisation avec très peu de configuration supplémentaire.
      Deuxièmement, la balise <sgmltag>archive</sgmltag> sous
      <sgmltag>configuration</sgmltag> spécifie l'attribut <varname>Main-Class</varname>
      du fichier manifest dans le <acronym>JAR</acronym> produit. Cette section est
      généralement disponible dans les plugins qui créent des fichiers 
      <acronym>JAR</acronym> comme le plugin <acronym>JAR</acronym> utilisé
      pour le packaging par défaut des projets.</para>

      <para>Maintenant, vous pouvez produire un <acronym>JAR</acronym> exécutable
      simplement en exécutant la commande <command>mvn package</command>. Après,
      nous listerons le contenu du répertoire<filename>target</filename> pour
      vérifier que le <acronym>JAR</acronym> exécutable a bien été généré. Enfin,
      pour prouver qu'il s'agit bien d'un <acronym>JAR</acronym> exécutable, nous
      essayerons de l'exécuter :</para>

      <screen>$ <command>mvn package</command>
... (output omitted) ...
[INFO] [jar:jar]
[INFO] Building jar: ~/mvn-examples-1.0/assemblies/executable-jar/target/\
                     executable-jar-1.0-SNAPSHOT.jar
[INFO] [assembly:single {execution: create-executable-jar}]
[INFO] Processing DependencySet (output=)
[INFO] Building jar: ~/mvn-examples-1.0/assemblies/executable-jar/target/\
                     executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar
... (output omitted) ...
$ <command>ls -1 target</command>
... (output omitted) ...
executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar
executable-jar-1.0-SNAPSHOT.jar
... (output omitted) ...
$ <command>java -jar \
        target/executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar </command>
Hello, World!</screen>

      <para>Des traces présentées ci-dessus vous pouvez voir 
      que maintenant le build normal du projet produit un nouvel
      artefact en plus du principal fichier <acronym>JAR</acronym>.
      Ce nouvel artefact à le classifer <varname>jar-with-dependencies</varname>.
      Enfin, nous avons vérifié que ce nouveau <acronym>JAR</acronym>
      est réellement exécutable et que son exécution produit le résutat
      attendu : l'affichage de “Hello, World!”</para>
    </section>

    <section id="assemblies-sect-as-depend">
      <title>Utilisation des assemblies comme dépendances</title>

      <para>Lorsque des assemblies sont produits durant le processus de
      build normal du projet les archives résultantes sont jointes à
      l'artefact principal du projet. Cela signifie qu'ils seront installés
      et déployés au côté de l'artefact et qu'ils seront donc accessibles
      comme ce dernier. Cahque artefact assembly aura les mêmes 
      coordonnées de base que le projet princiapl (à savoir le 
      <varname>groupId</varname>, l'<varname>artifactId</varname> et la
      <varname>version</varname>). Cependant ces artefacts sont des pièces 
      jointes ce qui signifie pour Maven quil s'agit de produits dérivés du
      build du projet princiapl. Par exemple, les assemblies <varname>source</varname>
      contiennent les données d'entrée brutes du build du projet et les
      assemblies <varname>jar-with-dependencies</varname> contiennent l'ensemble
      des classes du projet et de ses dépendances. Les artefacts ainsi rattachés
      peuvent ne pas respecter la règle Maven un projet un artefact de par cette
      nature de produits dérivés.</para>

      <para>Comme les assemblies sont (normalement) des artefacts rattachés, chaucun
      doit avoir son classifier en plus des coordonnées de l'artfact principal pour
      le distinguer de ce dernier. Par défauut ce classifier est l'identifiant du
      descripteur de l'assembly. Quand on utilise les descripteurs pré-définis
      l'identifiant du descripteur d'assembly est le même que l'identifiant utilisé 
      dans la balise <sgmltag>descriptorRef</sgmltag> pour ce type d'assembly.</para>

      <para>Maintenant que vous avez déployé l'assembly au côté de votre artefact
      principal, comment pouvez vous l'utiliser comme dépendance dans un autre
      projet ? La réponse est simple. Rappelez-vous la discussion dans la
      <xref linkend="simple-project-sect-maven-coordinates" /> et dans la <xref
      linkend="pom-relationships-sect-more-coordinates" /> à propos des dépendances
      entre projets avec Maven, les projets dépendent les uns des autres grâce à
      quatre éléments de base que l'on appelle coordonées d'un projet :
      <varname>groupId</varname>, <varname>artifactId</varname>,
      <varname>version</varname>et <varname>packaging</varname>. Dans la <xref
      linkend="profiles-sect-platform-classifier" />, il existe de nombreuses
      variantes de l'artefact du projet selon la plate-forme cible et le 
      projet spécifie un élément <varname>classifier</varname> qui prend la
      valeur <varname>win</varname> ou <varname>linux</varname> de manière à
      pouvoir choisir le bon artefact selon la plate-forme cible. Les artefacts
      assembly peuvent être utilisés comme dépendance grâce aux coordonnées de
      base du projet plus le calssifier avec lequel l'assembly a été installé 
      ou déployé. Si l'assembly n'est pas une archive <acronym>JAR</acronym>
      nous allons devoir déclarer aussi son type.</para>
    </section>

    <section id="assemblies-sect-assembling-via-depend">
      <title>Construction d'assemblies via des assemblies dépendances</title>

      <para>Assez perturbant ce titre n'est ce pas ? Essayons de mettre en place
      un scénario pour expliquer cette notion d'assemblage d'assembly. Imaginez que
      vous voulez construire une archive qui elle-même contient des assemblies d'un
      projet. Supposons que vous avez un build multimodule et que vous voulez
      déployer un assembly qui contient un ensemble d'assemblies de ce projet
      liés entre eux. Dans l'exemple de cette section nous créons un package
      qui rassemble des répertoires "constructibles" du projet pour des
      sous-projets qui sont utilisés ensembles. Pour essayer de rester simple nous
      utiliserons les descripteurs d'assembly dont nous venons de parler -
      <varname>project</varname> et <varname>jar-with-dependencies</varname>.
      Dans cet exemple particulier nous supposons que chaque projet construit
      son assembly en plus de l'artefact <acronym>JAR</acronym> principal.
      Nous supposerons aussi que cahque projet de ce build multimodule rattache
      le goal <varname>single</varname> à la phase <varname>package</varname> et
      qu'il utilise la balise <sgmltag>descriptorRef</sgmltag>. Tous les projets
      de ce build multimodule hérite de la configuration du fichier
      <filename>pom.xml</filename> de plus haut niveau et notamment de sa
      balise <sgmltag>pluginManagement</sgmltag> qui est décrite dans l'<xref
      linkend="ex-top-pom-assembly" />.</para>

      <example id="ex-top-pom-assembly">
        <title>Configuration de l'assembly du projet dans le POM de plus haut niveau</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;pluginManagement&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.2-beta-2&lt;/version&gt;
          &lt;executions&gt;
            &lt;execution&gt;
              &lt;id&gt;create-project-bundle&lt;/id&gt;
              &lt;phase&gt;package&lt;/phase&gt;
              &lt;goals&gt;
                &lt;goal&gt;single&lt;/goal&gt;
              &lt;/goals&gt;
              &lt;configuration&gt;
                &lt;descriptorRefs&gt;
                  &lt;descriptorRef&gt;project&lt;/descriptorRef&gt;
                &lt;/descriptorRefs&gt;
              &lt;/configuration&gt;
            &lt;/execution&gt;
          &lt;/executions&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
  &lt;/build&gt;
  ...
&lt;/project&gt;</programlisting>
      </example>

      <para>Le <acronym>POM</acronym> de chaque projet référence le plugin dont la
      configuration est décrite dans <xref linkend="ex-top-pom-assembly" /> par une
      déclaration minimale dans son build comme le montre l' <xref
      linkend="ex-activating-assembly" />.</para>

      <example id="ex-activating-assembly">
        <title>Activation de la configuration du plugin Assembly dans les projets fils</title>

        <programlisting language="xml">&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;
</programlisting>
      </example>

      <para>Pour produire l'ensemble des assemblies de projet, exécutez la commande
      <command>mvn install</command> depuis le répertoire racine. Vous devriez voir
      Maven installer les artefacts avec des classifiers dans votre dépôt.</para>

      <screen>$ <command>mvn install</command>
...
Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
           second-project/target/second-project-1.0-SNAPSHOT-project.tar.gz to 
  ~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\
           second-project-1.0-SNAPSHOT-project.tar.gz
...
Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
           second-project/target/second-project-1.0-SNAPSHOT-project.tar.bz2 to 
  ~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\
           second-project-1.0-SNAPSHOT-project.tar.bz2
...
Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
           second-project/target/second-project-1.0-SNAPSHOT-project.zip to 
  ~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\\
           second-project-1.0-SNAPSHOT-project.zip
...</screen>

      <para>Lorsque vous exécutez <varname>install</varname>, Maven va copier
      l'artefact principal de chaque projet ainsi que chaque assembly dans
      votre dépôt Maven local. Tous cesartefacts sont maintenant disponibles
      comme dépendance pour d'autres projets localement. Si votre but final
      est de créer un paquet qui inlut les assemblies de différents projets
      vous pouvez créer un autre projet qui référence comme dépendances les
      assemblies de ce projet. Ce projet chapeau prend la responsabilité
      de construire l'assembly englobant tous les autres. Le
      <acronym>POM</acronym> de ce projet chapeau d'empaquetage ressemblerait
      au document XML décrit dans l'<xref linkend="ex-bundling-pom" />.</para>

      <example id="ex-bundling-pom">
        <title>POM du projet assembly chapeau</title>

        <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
  &lt;artifactId&gt;project-bundle&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;name&gt;Assemblies-as-Dependencies Example Project Bundle&lt;/name&gt;
  &lt;url&gt;http://sonatype.com/book&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;artifactId&gt;first-project&lt;/artifactId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;classifier&gt;project&lt;/classifier&gt;
      &lt;type&gt;zip&lt;/type&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;artifactId&gt;second-project&lt;/artifactId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;classifier&gt;project&lt;/classifier&gt;
      &lt;type&gt;zip&lt;/type&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2-beta-2&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;bundle-project-sources&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;descriptorRefs&gt;
                &lt;descriptorRef&gt;
                  jar-with-dependencies
                &lt;/descriptorRef&gt;
              &lt;/descriptorRefs&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</programlisting>
      </example>

      <para>This bundling project's <acronym>POM</acronym> references the two
      assemblies from <varname>first-project</varname> and
      <varname>second-project</varname>. Instead of referencing the main
      artifact of each project, the bundling project's <acronym>POM</acronym>
      specifies a classifier of <varname>project</varname> and a type of
      <varname>zip</varname>. This tells Maven to resolve the
      <acronym>ZIP</acronym> archive which was created by the
      <varname>project</varname> assembly. Note that the bundling project
      generates a <varname>jar-with-dependencies</varname> assembly.
      <varname>jar-with-dependencies</varname> does not create a particularly
      elegant bundle, it simply creates a <acronym>JAR</acronym> file with the
      unpacked contents of all of the dependencies.
      <varname>jar-with-dependencies</varname> is really just telling Maven to
      take all of the dependencies, unpack them, and then create a single
      archive which includes the output of the current project. In this
      project, it has the effect of creating a single <acronym>JAR</acronym>
      file that puts the two project assemblies from
      <varname>first-project</varname> and <varname>second-project</varname>
      side-by-side.</para>

      <para>This example illustrates how the basic capabilities of the Maven
      Assembly plugin can be combined without the need for a custom assembly
      descriptor. It achieves the purpose of creating a single archive that
      contains the project directories for multiple projects side-by-side.
      This time, the <varname>jar-with-dependencies</varname> is just a
      storage format, so we don’t need to specify a
      <varname>Main-Class</varname> manifest attribute. To build the bundle,
      we just build the <varname>project-bundle</varname> project
      normally:</para>

      <screen>$ <command>mvn package</command>
...
[INFO] [assembly:single {execution: bundle-project-sources}]
[INFO] Processing DependencySet (output=)
[INFO] Building jar: ~/downloads/mvn-examples-1.0/assemblies/as-dependencies/\
  project-bundle/target/project-bundle-1.0-SNAPSHOT-jar-with-dependencies.jar
</screen>

      <para>To verify that the project-bundle assembly contains the unpacked
      contents of the assembly dependencies, run <command>jar
      tf</command>:</para>

      <screen>$ <command>jar tf \
  target/project-bundle-1.0-SNAPSHOT-jar-with-dependencies.jar</command>
...
first-project-1.0-SNAPSHOT/pom.xml
first-project-1.0-SNAPSHOT/src/main/java/org/sonatype/mavenbook/App.java
first-project-1.0-SNAPSHOT/src/test/java/org/sonatype/mavenbook/AppTest.java
...
second-project-1.0-SNAPSHOT/pom.xml
second-project-1.0-SNAPSHOT/src/main/java/org/sonatype/mavenbook/App.java
second-project-1.0-SNAPSHOT/src/test/java/org/sonatype/mavenbook/AppTest.java</screen>

      <para>After reading this section, the title should make more sense.
      You've assembled assemblies from two projects into an assembly using a
      bundling project which has a dependency on each of the
      assemblies.</para>
    </section>
  </section>

  <section id="assemblies-sect-overview-descriptor">
    <title>Overview of the Assembly Descriptor</title>

    <para>When the standard assembly descriptors introduced in <xref
    linkend="assemblies-sect-basics" /> are not adequate, you will need to
    define your own assembly descriptor. The assembly descriptor is an XML
    document which defines the structure and contents of an assembly. The
    assembly descriptor contains five main configuration sections, plus two
    additional sections: one for specifying standard assembly-descriptor
    fragments, called component descriptors, and another for specifying custom
    file processor classes to help manage the assembly-production
    process.</para>

    <variablelist>
      <varlistentry>
        <term>Base Configuration</term>

        <listitem>
          <para>This section contains the information required by all
          assemblies, plus some additional configuration options related to
          the format of the entire archive, such as the base path to use for
          all archive entries. For the assembly descriptor to be valid, you
          must at least specify the assembly id, at least one format, and at
          least one of the other sections shown above.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>File Information</term>

        <listitem>
          <para>The configurations in this segment of the assembly descriptor
          apply to specific files on the file system within the project’s
          directory structure. This segment contains two main sections:
          <sgmltag>files</sgmltag> and <sgmltag>fileSets</sgmltag>. You use
          <sgmltag>files</sgmltag> and <sgmltag>fileSets</sgmltag> to control
          the permissions of files in an assembly and to include or exclude
          files from an assembly.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Dependency Information</term>

        <listitem>
          <para>Almost all projects of any size depend on other projects. When
          creating distribution archives, project dependencies are usually
          included in the end-product of an assembly. This section manages the
          way dependencies are included in the resulting archive. This section
          allows you to specify whether dependencies are unpacked, added
          directly to the <filename>lib/</filename> directory, or mapped to
          new file names. This section also allows you to control the
          permissions of dependencies in the assembly, and which dependencies
          are included in an assembly.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Repository Information</term>

        <listitem>
          <para>At times, it’s useful to isolate the sum total of all
          artifacts necessary to build a project, whether they’re dependency
          artifacts, <acronym>POM</acronym>s of dependency artifacts, or even
          a project’s own POM ancestry (your parent <acronym>POM</acronym>,
          its parent, and so on). This section allows you to include one or
          more artifact-repository directory structures inside your assembly,
          with various configuration options. The Assembly plugin does not
          have the ability to include plugin artifacts in these repositories
          yet.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Module Information</term>

        <listitem>
          <para>This section of the assembly descriptor allows you to take
          advantage of these parent-child relationships when assembling your
          custom archive, to include source files, artifacts, and dependencies
          from your project’s modules. This is the most complex section of the
          assembly descriptor, because it allows you to work with modules and
          sub-modules in two ways: as a series of <sgmltag>fileSets</sgmltag>
          (via the <sgmltag>sources</sgmltag> section) or as a series of
          <sgmltag>dependencySets</sgmltag> (via the
          <sgmltag>binaries</sgmltag> section).</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>

  <section id="assemblies-sect-descriptor">
    <title>The Assembly Descriptor</title>

    <para>This section is a tour of the assembly descriptor which contains
    some guidelines for developing a custom assembly descriptor. The Assembly
    plugin is one of the largest plugins in the Maven ensemble, and one of the
    most flexible.</para>

    <section id="assemblies-sect-prop-refs">
      <title>Property References in Assembly Descriptors</title>

      <para>Any property discussed in <xref
      linkend="resource-filtering-sect-properties" /> can be referenced in an
      assembly descriptor. Before any assembly descriptor is used by Maven, it
      is interpolated using information from the <acronym>POM</acronym> and
      the current build environment. All properties supported for
      interpolation within the <acronym>POM</acronym> itself are valid for use
      in assembly descriptors, including <acronym>POM</acronym> properties,
      <acronym>POM</acronym> element values, system properties, user-defined
      properties, and operating-system environment variables.</para>

      <para>The only exceptions to this interpolation step are elements in
      various sections of the descriptor named
      <sgmltag>outputDirectory</sgmltag>,
      <sgmltag>outputDirectoryMapping</sgmltag>, or
      <sgmltag>outputFileNameMapping</sgmltag>. The reason these are held back
      in their raw form is to allow artifact- or module-specific information
      to be applied when resolving expressions in these values, on a per-item
      basis.</para>

      <!--This last paragraph is not clear.-->
    </section>

    <section id="assemblies-sect-required">
      <title>Required Assembly Information</title>

      <para>There are two essential pieces of information that are required
      for every assembly: the <sgmltag>id</sgmltag>, and the list of archive
      formats to produce. In practice, at least one other section of the
      descriptor is required - since most archive format components will choke
      if they don’t have at least one file to include - but without at least
      one <sgmltag>format</sgmltag> and an <sgmltag>id</sgmltag>, there is no
      archive to create. The <sgmltag>id</sgmltag> is used both in the
      archive’s file name, and as part of the archive’s artifact classifier in
      the Maven repository. The format string also controls the
      archiver-component instance that will create the final assembly archive.
      All assembly descriptors must contain an <sgmltag>id</sgmltag> and at
      least one <sgmltag>format</sgmltag>:</para>

      <example id="ex-required-assembly">
        <title>Required Assembly Descriptor Elements</title>

        <programlisting language="xml">&lt;assembly&gt;
  &lt;id&gt;bundle&lt;/id&gt; 
  &lt;formats&gt;
    &lt;format&gt;zip&lt;/format&gt;
  &lt;/formats&gt;
  ...
&lt;/assembly&gt;</programlisting>
      </example>

      <para>The assembly <sgmltag>id</sgmltag> can be any string that does not
      contain spaces. The standard practice is to use dashes when you must
      separate words within the assembly <sgmltag>id</sgmltag>. If you were
      creating an assembly to create an interesting unique package structure,
      you would give your an <varname>id</varname> of something like
      <varname>interesting-unique-package</varname>. It also supports multiple
      formats within a single assembly descriptor, allowing you to create the
      familiar <filename>.zip</filename>, <filename>.tar.gz</filename>, and
      <filename>.tar.bz2</filename> distribution archive set with ease. If you
      don't find the archive format you need, you can also create a custom
      format. Custom formats are discussed in <xref
      linkend="assemblies-sect-componentDescriptors" />. The Assembly plugin
      supports several archive formats natively, including:</para>

      <itemizedlist>
        <listitem>
          <para><varname>jar</varname></para>
        </listitem>

        <listitem>
          <para><varname>zip</varname></para>
        </listitem>

        <listitem>
          <para><varname>tar</varname></para>
        </listitem>

        <listitem>
          <para><varname>bzip2</varname></para>
        </listitem>

        <listitem>
          <para><varname>gzip</varname></para>
        </listitem>

        <listitem>
          <para><varname>tar.gz</varname></para>
        </listitem>

        <listitem>
          <para><varname>tar.bz2</varname></para>
        </listitem>

        <listitem>
          <para><varname>rar</varname></para>
        </listitem>

        <listitem>
          <para><varname>war</varname></para>
        </listitem>

        <listitem>
          <para><varname>ear</varname></para>
        </listitem>

        <listitem>
          <para><varname>sar</varname></para>
        </listitem>

        <listitem>
          <para><varname>dir</varname></para>
        </listitem>
      </itemizedlist>

      <para>The <varname>id</varname> and <varname>format</varname> are
      essential because they will become a part of the coordinates for the
      assembled archive. The example from <xref
      linkend="ex-required-assembly" /> will create an assembly artifact of
      type <varname>zip</varname> with a classifier of
      <varname>bundle</varname>.</para>
    </section>
  </section>

  <section id="assemblies-sect-controlling-contents">
    <title>Controlling the Contents of an Assembly</title>

    <para>In theory, <varname>id</varname> and <varname>format</varname> are
    the only absolute requirements for a valid assembly descriptor; however,
    many assembly archivers will fail if they do not have at least one file to
    include in the output archive. The task of defining the files to be
    included in the assembly is handled by the five main sections of the
    assembly descriptor: <sgmltag>files</sgmltag>,
    <sgmltag>fileSets</sgmltag>, <sgmltag>dependencySets</sgmltag>,
    <sgmltag>repositories</sgmltag>, and <sgmltag>moduleSets</sgmltag>. To
    explore these sections most effectively, we’ll start by discussing the
    most elemental section: <sgmltag>files</sgmltag>. Then, we’ll move on to
    the two most commonly used sections, <sgmltag>fileSets</sgmltag> and
    <sgmltag>dependencySets</sgmltag>. Once you understand the workings of
    <sgmltag>fileSets</sgmltag> and <sgmltag>dependencySets</sgmltag>, it’s
    easier to understand <sgmltag>repositories</sgmltag> and
    <sgmltag>moduleSets</sgmltag>.</para>

    <section id="assemblies-sect-files">
      <title><sgmltag>Files</sgmltag> Section</title>

      <para>The <sgmltag>files</sgmltag> section is the simplest part of the
      assembly descriptor, it is designed for files that have a definite
      location relative to your project’s directory. Using this section, you
      have absolute control over the exact set of files that are included in
      your assembly, exactly what they are named, and where they will reside
      in the archive.</para>

      <example id="ex-assembly-files">
        <title>Including a <acronym>JAR</acronym> file in an Assembly using
        <sgmltag>files</sgmltag></title>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;files&gt;
    &lt;file&gt;
      &lt;source&gt;target/my-app-1.0.jar&lt;/source&gt;
      &lt;outputDirectory&gt;lib&lt;/outputDirectory&gt;
      &lt;destName&gt;my-app.jar&lt;/destName&gt;
      &lt;fileMode&gt;0644&lt;/fileMode&gt;
    &lt;/file&gt;
  &lt;/files&gt;
  ...
&lt;/assembly&gt;</programlisting>
      </example>

      <para>Assuming you were building a project called
      <varname>my-app</varname> with a version of <varname>1.0</varname>,
      <xref linkend="ex-assembly-files" /> would include your project's
      <acronym>JAR</acronym> in the assembly’s <filename>lib/</filename>
      directory, trimming the version from the file name in the process so the
      final file name is simply <filename>my-app.jar</filename>. It would then
      make the <acronym>JAR</acronym> readable by everyone and writable by the
      user that owns it (this is what the mode 0644 means for files, using
      Unix four-digit Octal permission notation). For more information about
      the format of the value in <sgmltag>fileMode</sgmltag>, please see the
      Wikipedia's explanation of <ulink
      url="http://en.wikipedia.org/wiki/File_system_permissions#Octal_notation_and_additional_permissions">four-digit
      Octal notation</ulink>.</para>

      <para>You could build a very complex assembly using file entries, if you
      knew the full list of files to be included. Even if you didn’t know the
      full list before the build started, you could probably use a custom
      Maven plugin to discover that list and generate the assembly descriptor
      using references like the one above. While the files section gives you
      fine-grained control over the permission, location, and name of each
      file in the assembly archive, listing a <sgmltag>file</sgmltag> element
      for every file in a large archive would be a tedious exercise. For the
      most part, you will be operating on groups of files and dependencies
      using <sgmltag>fileSets</sgmltag>. The remaining four file-inclusion
      sections are designed to help you include entire sets of files that
      match a particular criteria.</para>
    </section>

    <section id="assemblies-sect-filesets">
      <title><sgmltag>FileSets</sgmltag> Section</title>

      <para>Similar to the <sgmltag>files</sgmltag> section,
      <sgmltag>fileSets</sgmltag> are intended for files that have a definite
      location relative to your project’s directory structure. However, unlike
      the <sgmltag>files</sgmltag> section, <sgmltag>fileSets</sgmltag>
      describe sets of files, defined by file and path patterns they match (or
      don’t match), and the general directory structure in which they are
      located. The simplest <sgmltag>fileSet</sgmltag> just specifies the
      directory where the files are located:</para>

      <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;fileSets&gt;
    &lt;fileSet&gt;
      &lt;directory&gt;src/main/java&lt;/directory&gt;
    &lt;/fileSet&gt;
  &lt;/fileSets&gt;
  ...
&lt;/assembly&gt;</programlisting>

      <para>This file set simply includes the contents of the
      <filename>src/main/java</filename> directory from our project. It takes
      advantage of many default settings in the section, so let’s discuss
      those briefly.</para>

      <para>First, you’ll notice that we haven’t told the file set where
      within the assembly matching files should be located. By default, the
      destination directory (specified with
      <sgmltag>outputDirectory</sgmltag>) is the same as the source directory
      (in our case, <filename>src/main/java</filename>). Additionally, we
      haven’t specified any inclusion or exclusion file patterns. When these
      are empty, the file set assumes that all files within the source
      directory are included, with some important exceptions. The exceptions
      to this rule pertain mainly to source-control metadata files and
      directories, and are controlled by the
      <sgmltag>useDefaultExcludes</sgmltag> flag, which is defaulted to
      <sgmltag>true</sgmltag>. When active,
      <sgmltag>useDefaultExcludes</sgmltag> will keep directories like
      <filename>.svn/</filename> and <filename>CVS/</filename> from being
      added to the assembly archive. <xref
      linkend="assemblies-sect-default-excludes" /> provides a detailed list
      of the default exclusion patterns.</para>

      <para>If we want more control over this file set, we can specify it more
      explicitly. <xref linkend="ex-explicit-fileSet" /> shows a
      <sgmltag>fileSet</sgmltag> element with all of the default elements
      specified.</para>

      <example id="ex-explicit-fileSet">
        <title>Including Files with <sgmltag>fileSet</sgmltag></title>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;fileSets&gt;
    &lt;fileSet&gt;
      &lt;directory&gt;src/main/java&lt;/directory&gt;
      &lt;outputDirectory&gt;src/main/java&lt;/outputDirectory&gt;
      &lt;includes&gt;
        &lt;include&gt;**&lt;/include&gt;
      &lt;/includes&gt;
      &lt;useDefaultExcludes&gt;true&lt;/useDefaultExcludes&gt;
      &lt;fileMode&gt;0644&lt;/fileMode&gt;
      &lt;directoryMode&gt;0755&lt;/directoryMode&gt;
    &lt;/fileSet&gt;
  &lt;/fileSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
      </example>

      <para>The <sgmltag>includes</sgmltag> section uses a list of
      <sgmltag>include</sgmltag> elements, which contain path patterns. These
      patterns may contain wildcards such as ‘**’ which matches one or more
      directories or ‘*’ which matches part of a file name, and ‘?’ which
      matches a single character in a file name. <xref
      linkend="ex-explicit-fileSet" /> uses a <sgmltag>fileMode</sgmltag>
      entry to specify that files in this set should be readable by all, but
      only writable by the owner. Since the <sgmltag>fileSet</sgmltag>
      includes directories, we also have the option of specifying a
      <sgmltag>directoryMode</sgmltag> that works in much the same way as the
      <sgmltag>fileMode</sgmltag>. Since a directories’ execute permission is
      what allows users to list their contents, we want to make sure
      directories are executable in addition to being readable. Like files,
      only the owner can write to directories in this set.</para>

      <para>The <sgmltag>fileSet</sgmltag> entry offers some other options as
      well. First, it allows for an <sgmltag>excludes</sgmltag> section with a
      form identical to the <sgmltag>includes</sgmltag> section. These
      exclusion patterns allow you to exclude specific file patterns from a
      <sgmltag>fileSet</sgmltag>. Include patterns take precedence over
      exclude patterns. Additionally, you can set the
      <sgmltag>filtering</sgmltag> flag to true if you want to substitute
      property values for expressions within the included files. Expressions
      can be delimited either by <varname>\${</varname> and
      <varname>}</varname> (standard Maven expressions like
      <varname>\${project.groupId}</varname>) or by <varname>@</varname> and
      <varname>@</varname> (standard Ant expressions like
      <varname>@project.groupId@</varname>). You can adjust the line ending of
      your files using the <sgmltag>lineEnding</sgmltag> element; valid values
      for <sgmltag>lineEnding</sgmltag> are:</para>

      <variablelist>
        <varlistentry>
          <term>keep</term>

          <listitem>
            <para>Preserve line endings from original files. (This is the
            default value.)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>unix</term>

          <listitem>
            <para>Unix-style line endings</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>lf</term>

          <listitem>
            <para>Only a Line Feed Character</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>dos</term>

          <listitem>
            <para>MS-DOS-style line endings</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>crlf</term>

          <listitem>
            <para>Carriage-return followed by a Line Feed</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Finally, if you want to ensure that all file-matching patterns are
      used, you can use the <sgmltag>useStrictFiltering</sgmltag> element with
      a value of <sgmltag>true</sgmltag> (the default is
      <sgmltag>false</sgmltag>). This can be especially useful if unused
      patterns may signal missing files in an intermediary output directory.
      When <sgmltag>useStrictFiltering</sgmltag> is set to
      <sgmltag>true</sgmltag>, the Assembly plugin will fail if an include
      pattern is not satisfied. In other words, if you have an include pattern
      which includes a file from a build, and that file is not present,
      setting <sgmltag>useStrictFiltering</sgmltag> to <sgmltag>true</sgmltag>
      will cause a failure if Maven cannot find the file to be
      included.</para>

      <!--TODO: JCasey, I had to take the statement about Ant Expressions out because I couldn't verify it.
I can add this back in later.  I didn't want to talk about it without an example.  - TIM-->
    </section>

    <section id="assemblies-sect-default-excludes">
      <title>Default Exclusion Patterns for
      <sgmltag>fileSets</sgmltag></title>

      <para>When you use the default exclusion patterns, the Maven Assembly
      plugin is going to be ignoring more than just <acronym>SVN</acronym> and
      <acronym>CVS</acronym> information. By default the exclusion patterns
      are defined by the <ulink
      url="http://svn.codehaus.org/plexus/plexus-utils/trunk/src/main/java/org/codehaus/plexus/util/DirectoryScanner.java">DirectoryScanner</ulink>
      class in the <ulink
      url="http://plexus.codehaus.org/plexus-utils/">plexus-utils</ulink>
      project hosted at Codehaus. The array of exclude patterns is defined as
      a static, final <classname>String</classname> array named
      <varname>DEFAULTEXCLUDES</varname> in
      <classname>DirectoryScanner</classname>. The contents of this variable
      are shown in <xref linkend="ex-default-excludes" />.</para>

      <example id="ex-default-excludes">
        <title>Definition of Default Exclusion Patterns from Plexus
        Utils</title>

        <programlisting language="java">   public static final String[] DEFAULTEXCLUDES = {
        // Miscellaneous typical temporary files
        "**/*~",
        "**/#*#",
        "**/.#*",
        "**/%*%",
        "**/._*",

        // CVS
        "**/CVS",
        "**/CVS/**",
        "**/.cvsignore",

        // SCCS
        "**/SCCS",
        "**/SCCS/**",

        // Visual SourceSafe
        "**/vssver.scc",

        // Subversion
        "**/.svn",
        "**/.svn/**",

        // Arch
        "**/.arch-ids",
        "**/.arch-ids/**",

        //Bazaar
        "**/.bzr",
        "**/.bzr/**",

        //SurroundSCM
        "**/.MySCMServerInfo",

        // Mac
        "**/.DS_Store"
    };</programlisting>
      </example>

      <para>This default array of patterns excludes temporary files from
      editors like <ulink url="http://www.gnu.org/software/emacs/">GNU
      Emacs</ulink>, and other common temporary files from Macs and a few
      common source control systems (although Visual SourceSafe is more of a
      curse than a source control system). If you need to override these
      default exclusion patterns you set <sgmltag>useDefaultExcludes</sgmltag>
      to false and then define a set of exclusion patterns in your own
      assembly descriptor.</para>
    </section>

    <section id="assemblies-sect-output-algorithm">
      <title><sgmltag>dependencySets</sgmltag> Section</title>

      <para>One of the most common requirements for assemblies is the
      inclusion of a project’s dependencies in an assembly archive. Where
      <sgmltag>files</sgmltag> and <sgmltag>fileSets</sgmltag> deal with files
      in your project, dependency files don't have a location in your project.
      The artifacts your project depends on have to be resolved by Maven
      during the build. Dependency artifacts are abstract, they lack a
      definite location, and are resolved using a symbolic set of Maven
      coordinates. Since <sgmltag>file</sgmltag> and
      <sgmltag>fileSet</sgmltag> specifications require a concrete source
      path, dependencies are included or excluded from an assembly using a
      combination of Maven coordinates and dependency scopes.</para>

      <para>The simplest <sgmltag>dependencySet</sgmltag> is an empty
      element:</para>

      <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet/&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>

      <para>The <sgmltag>dependencySet</sgmltag> above will match all runtime
      dependencies of your project (runtime scope includes the compile scope
      implicitly), and it will add these dependencies to the root directory of
      your assembly archive. It will also copy the current project’s main
      artifact into the root of the assembly archive, if it exists.</para>

      <note>
        <para>Wait? I thought <sgmltag>dependencySet</sgmltag> was about
        including my project's dependencies, not my project's main archive?
        This counterintuitive side-effect was a widely-used bug in the 2.1
        version of the Assembly plugin, and, because Maven puts an emphasis on
        backward compatibility, this counterintuitive and incorrect behavior
        needed to be preserved between a 2.1 and 2.2 release. You can control
        this behavior by changing the <sgmltag>useProjectArtifact</sgmltag>
        flag to <varname>false</varname>.</para>
      </note>

      <para>While the default dependency set can be quite useful with no
      configuration whatsoever, this section of the assembly descriptor also
      supports a wide array of configuration options, allowing your to tailor
      its behavior to your specific requirements. For example, the first thing
      you might do to the dependency set above is exclude the current project
      artifact, by setting the <sgmltag>useProjectArtifact</sgmltag> flag to
      <varname>false</varname> (again, its default value is
      <varname>true</varname> for legacy reasons). This will allow you to
      manage the current project’s build output separately from its dependency
      files. Alternatively, you might choose to unpack the dependency
      artifacts using by setting the <sgmltag>unpack</sgmltag> flag to
      <varname>true</varname> (this is <varname>false</varname> by default).
      When unpack is set to true, the Assembly plugin will combine the
      unpacked contents of all matching dependencies inside the archive’s root
      directory.</para>

      <para>From this point, there are several things you might choose to do
      with this dependency set. The next sections discuss how to define the
      output location for dependency sets and how include and exclude
      dependencies by scope. Finally, we’ll expand on the unpacking
      functionality of the dependency set by exploring some advanced options
      for unpacking dependencies.</para>

      <section id="assemblies-sect-output-location">
        <title>Customizing Dependency Output Location</title>

        <para>There are two configuration options that are used in concert to
        define the location for a dependency file within the assembly archive:
        <sgmltag>outputDirectory</sgmltag> and
        <sgmltag>outputFileNameMapping</sgmltag>. You may want to customize
        the location of dependencies in your assembly using properties of the
        dependency artifacts themselves. Let's say you want to put all the
        dependencies in directories that match the dependency artifact's
        <sgmltag>groupId</sgmltag>. In this case, you would use the
        <sgmltag>outputDirectory</sgmltag> element of the
        <sgmltag>dependencySet</sgmltag>, and you would supply something
        like:</para>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;outputDirectory&gt;\${artifact.groupId}&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>

        <para>This would have the effect of placing every single dependency in
        a subdirectory that matched the name of each dependency artifact's
        <sgmltag>groupId</sgmltag>.</para>

        <para>If you wanted to perform a further customization and remove the
        version numbers from all dependencies. You could customize the the
        output file name for each dependency using the
        <sgmltag>outputFileNameMapping</sgmltag> element as follows:</para>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;outputDirectory&gt;\${artifact.groupId}&lt;/outputDirectory&gt;
      &lt;outputFileNameMapping&gt;
        \${artifact.artifactId}.\${artifact.extension} 
      &lt;/outputFileNameMapping&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>

        <para>In the previous example, a dependency on
        <varname>commons:commons-codec</varname> version 1.3, would end up in
        the file <filename>commons/commons-codec.jar</filename>.</para>
      </section>

      <section id="assemblies-sect-interpolate">
        <title>Interpolation of Properties in Dependency Output
        Location</title>

        <para>As mentioned in the Assembly Interpolation section above,
        neither of these elements are interpolated with the rest of the
        assembly descriptor, because their raw values have to be interpreted
        using additional, artifact-specific expression resolvers.</para>

        <para>The artifact expressions available for these two elements vary
        only slightly. In both cases, all of the
        <varname>\${project.*}</varname>, <varname>\${pom.*}</varname>, and
        <varname>\${*}</varname> expressions that are available in the
        <acronym>POM</acronym> and the rest of the assembly descriptor are
        also available here. For the <sgmltag>outputFileNameMapping</sgmltag>
        element, the following process is applied to resolve
        expressions:</para>

        <orderedlist>
          <listitem>
            <para>If the expression matches the pattern
            <varname>\${artifact.*}</varname>:</para>

            <orderedlist numeration="loweralpha">
              <listitem>
                <para>Match against the dependency’s
                <classname>Artifact</classname> instance (resolves:
                <varname>groupId</varname>, <varname>artifactId</varname>,
                <varname>version</varname>, <varname>baseVersion</varname>,
                <varname>scope</varname>, <varname>classifier</varname>, and
                <varname>file.*</varname>)</para>
              </listitem>

              <listitem>
                <para>Match against the dependency’s
                <classname>ArtifactHandler</classname> instance (resolves:
                <varname>expression</varname>)</para>
              </listitem>

              <listitem>
                <para>Match against the project instance associated with the
                dependency’s Artifact (resolves: mainly POM properties)</para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>If the expression matches the patterns
            <varname>\${pom.*}</varname> or
            <varname>\${project.*}</varname>:</para>

            <orderedlist numeration="loweralpha">
              <listitem>
                <para>Match against the project instance
                (<classname>MavenProject</classname>) of the current
                build.</para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>If the expression matches the pattern
            <varname>\${dashClassifier?}</varname> and the Artifact instance
            contains a non-null classifier, resolve to the classifier preceded
            by a dash (-classifier). Otherwise, resolve to an empty
            string.</para>
          </listitem>

          <listitem>
            <para>Attempt to resolve the expression against the project
            instance of the current build.</para>
          </listitem>

          <listitem>
            <para>Attempt to resolve the expression against the POM properties
            of the current build.</para>
          </listitem>

          <listitem>
            <para>Attempt to resolve the expression against the available
            system properties.</para>
          </listitem>

          <listitem>
            <para>Attempt to resolve the expression against the available
            operating-system environment variables.</para>
          </listitem>
        </orderedlist>

        <para>The <sgmltag>outputDirectory</sgmltag> value is interpolated in
        much the same way, with the difference being that there is no
        available <varname>\${artifact.*}</varname> information, only the
        <varname>\${project.*}</varname> instance for the particular artifact.
        Therefore, the expressions listed above associated with those classes
        (1a, 1b, and 3 in the process listing above) are unavailable.</para>

        <para>How do you know when to use <sgmltag>outputDirectory</sgmltag>
        and <sgmltag>outputFileNameMapping</sgmltag>? When dependencies are
        unpacked only the <sgmltag>outputDirectory</sgmltag> is used to
        calculate the output location. When dependencies are managed as whole
        files (not unpacked), both <sgmltag>outputDirectory</sgmltag> and
        <sgmltag>outputFileNameMapping</sgmltag> can be used together. When
        used together, the result is the equivalent of:</para>

        <programlisting language="xml">&lt;archive-root-dir&gt;/&lt;outputDirectory&gt;/&lt;outputFileNameMapping&gt;</programlisting>

        <para>When <sgmltag>outputDirectory</sgmltag> is missing, it is not
        used. When <sgmltag>outputFileNameMapping</sgmltag> is missing, its
        default value is:
        <code>\${artifact.artifactId}-\${artifact.version}\${dashClassifier?}.\${artifact.extension}</code></para>
      </section>

      <section id="assemblies-sect-include-by-scope">
        <title>Including and Excluding Dependencies by Scope</title>

        <para>In <xref
        linkend="pom-relationships-sect-project-dependencies" />, it was noted
        that all project dependencies have one scope or another. Scope
        determines when in the build process that dependency normally would be
        used. For instance, test-scoped dependencies are not included in the
        classpath during compilation of the main project sources; but they are
        included in the classpath when compiling unit test sources. This is
        because your project’s main source code should not contain any code
        specific to testing, since testing is not a function of the project
        (it’s a function of the project’s build process). Similarly,
        provided-scoped dependencies are assumed to be present in the
        environment of any eventual deployment. However, if a project depends
        on a particular provided dependency, it is likely to require that
        dependency in order to compile. Therefore, provided-scoped
        dependencies are present in the compilation classpath, but not in the
        dependency set that should be bundled with the project’s artifact or
        assembly.</para>

        <para>Also from <xref
        linkend="pom-relationships-sect-project-dependencies" />, recall that
        some dependency scopes imply others. For instance, the
        <varname>runtime</varname> dependency scope implies the
        <varname>compile</varname> scope, since all compile-time dependencies
        (except for those in the <varname>provided</varname> scope) will be
        required for the code to execute. There are a number of complex
        relationships between the various dependency scopes which control how
        the scope of a direct dependency affects the scope of a transitive
        dependency. In a Maven Assembly descriptor, we can use scopes to apply
        different settings to different sets of dependencies
        accordingly.</para>

        <para>For instance, if we plan to bundle a web application with <ulink
        url="http://www.mortbay.org/jetty-6/">Jetty</ulink> to create a
        completely self-contained application, we’ll need to include all
        provided-scope dependencies somewhere in the jetty directory structure
        we’re including. This ensures those provided dependencies actually are
        present in the runtime environment. Non-provided, runtime dependencies
        will still land in the WEB-INF/lib directory, so these two dependency
        sets must be processed separately. These dependency sets might look
        similar to the following XML.</para>

        <example>
          <title>Defining Dependency Sets Using Scope</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
      &lt;outputDirectory&gt;lib/\${project.artifactId}&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/\${webContextName}/WEB-INF/lib
      &lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Provided-scoped dependencies are added to the
        <filename>lib/</filename> directory in the assembly root, which is
        assumed to be a libraries directory that will be included in the Jetty
        global runtime classpath. We’re using a subdirectory named for the
        project’s <varname>artifactId</varname> in order to make it easier to
        track the origin of a particular library. Runtime dependencies are
        included in the <filename>WEB-INF/lib</filename> path of the web
        application, which is located within a subdirectory of the standard
        Jetty <filename>webapps/</filename> directory that is named using a
        custom <acronym>POM</acronym> property called
        <varname>webContextName</varname>. What we've done in the previous
        example is separate application-specific dependencies from
        dependencies which will be present in a Servlet contains global
        classpath.</para>

        <para>However, simply separating according to scope may not be enough,
        particularly in the case of a web application. It’s conceivable that
        one or more runtime dependencies will actually be bundles of
        standardized, non-compiled resources for use in the web application.
        For example, consider a set of web application which reuse a common
        set of Javascript, CSS, SWF, and image resources. To make these
        resources easy to standardize, it’s a common practice to bundle them
        up in an archive and deploy them to the Maven repository. At that
        point, they can be referenced as standard Maven dependencies -
        possibly with a dependency type of <varname>zip</varname> - that are
        normally specified with a runtime scope. Remember, these are
        resources, not binary dependencies of the application code itself;
        therefore, it’s not appropriate to blindly include them in the
        <filename>WEB-INF/lib</filename> directory. Instead, these resource
        archives should be separated from binary runtime dependencies, and
        unpacked into the web application document root somewhere. In order to
        achieve this kind of separation, we’ll need to use inclusion and
        exclusion patterns that apply to the coordinates of a specific
        dependency.</para>

        <para>In other words, say you have three or four web application which
        reuse the same resources and you want to create an assembly that puts
        provided dependencies into <filename>lib/</filename>, runtime
        dependencies into
        <filename>webapps/&lt;contextName&gt;/WEB-INF/lib</filename>, and then
        unpacks a specific runtime dependency into your web application's
        document root. You can do this because the Assembly allows you to
        define multiple include and exclude patterns for a given
        <sgmltag>dependencySet</sgmltag> element. Read the next section for
        more development of this idea.</para>
      </section>

      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->

      <section id="assemblies-sect-fine-tune">
        <title>Configuration fine : inclusion et exclusion de dépendances</title>

        <para>Une dépendance de ressources peut être une simple liste de ressources (CSS, Javascript, images ...) dans un projet
        qui a une assembly qui crée une archive <acronym>ZIP</acronym>.
        En fonction des particularités de votre application web,
        vous voudrez distinguer les dépendances de ressources des dépendances de binaires en fonction de leur type.
        La plupart des applications web vont dépendre d'autres dépendances de type <varname>jar</varname>, 
        du coup, il est possible de dire avec certitude que toutes les dépendances de type <varname>zip</varname> sont des dépendances de ressources.
        Ou, nous pourrions avoir une situation où les ressources sont conservées sous un format <varname>jar</varname> mais 
        que nous pouvons distinguer les ressources par un tag <varname>resources</varname>.
        Dans tous les cas, nous pouvons spécifier un pattern d'inclusion pour cibler ces dépendances de ressources
        et appliquer une logique différente que celle utilisée pour les binaires. 
        Nous pouvons effectue cette distinction par l'intermédiaire de balises <sgmltag>includes</sgmltag> et <sgmltag>excludes</sgmltag> 
        dans le <sgmltag>dependencySet</sgmltag>.</para>

        <para>Les balises <sgmltag>includes</sgmltag> et <sgmltag>excludes</sgmltag> sont des listes, 
        cela veut dire qu'elles acceptent des sous éléments du type <sgmltag>include</sgmltag> et <sgmltag>exclude</sgmltag>.
        Chaque balise <sgmltag>include</sgmltag> ou <sgmltag>exclude</sgmltag> contient une valeur sous forme de chaîne de caractère, celles-ci pouvant contenir des wildcards.
        Chaque valeur peut matcher des dépendances selon différents moyens.         
        Généralement, trois formats de pattern sont supportés :</para>

        <variablelist>
          <varlistentry>
            <term><varname>groupId:artifactId</varname> - sans la version</term>

            <listitem>
              <para>Utilisez ce pattern pour trouver des dépendances par <varname>groupId</varname> et <varname>artifactId</varname></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><varname>groupId:artifactId:type[:classifier]</varname> - id de conflit</term>

            <listitem>
              <para>Ce pattern vous permet de fournir un ensemble plus large de coordonnées pour créer des patterns include/exclude plus spécifiques.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><varname>groupId:artifactId:type[:classifier]:version</varname> - identité complète de l'artefact</term>

            <listitem>
              <para>Si vous avez un récupérer un artefact bien spécifique, vous pouvez renseigner l'intégralité des coordonnées.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Tous ces formats de patterns supportent l'utilisation de widcard ‘*’, 
        ils permettent de matcher n'importe quelle sous-section de l'identité et n'est pas limitée à une seule sous-section (sections entre ':').         
        En outre, notez que la section classificateur ci-dessus est facultative,
        le pattern matching des dépendances qui n'ont pas de classificateur ne prennent pas en compte la section 'classificateur' de ce pattern.</para>

        <para>Dans l'exemple donné ci-dessus, là où la distinction essentielle est l'artefact de type sip et qu'aucune des dépendances n'a de classificateur,
        le pattern suivant matcherait toutes les ressources de type <varname>zip</varname> :</para> 

        <programlisting>*:zip</programlisting>

        <para>Le pattern ci-dessus utilise la seconde identité de la dépendance : l'id de conflit.
        Maintenant que nous avons un pattern qui distingue les dépendances ressources des binaires, 
        nous pouvons modifier notre liste de dépendances pour gérer les archives différemment :</para>  

        <example id="ex-complex-dependencySet">
          <title>Utilisation des l'inclusion et d'exclusion de dépendances dans le <sgmltag>dependencySets</sgmltag></title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
      &lt;outputDirectory&gt;lib/\${project.artifactId}&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/\${webContextName}/WEB-INF/lib
      &lt;/outputDirectory&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;*:zip&lt;/exclude&gt;
      &lt;/excludes&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/\${webContextName}/resources
      &lt;/outputDirectory&gt;
      &lt;includes&gt;
        &lt;include&gt;*:zip&lt;/include&gt;
      &lt;/includes&gt;
      &lt;unpack&gt;true&lt;/unpack&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Dans l'<xref linkend="ex-complex-dependencySet" />, 
        la liste de dépendances scopée <varname>runtime</varname> de notre dernier exemple à été mis à jour pour exclure les dépendances de type ressource.
        Seules les dépendances de type binaire (les dépendances qui ne sont pas de ZIP) sont ajoutées dans le répertoire <filename>WEB-INF/lib</filename> de l'application. 
        Les dépendances de type ressource sont rassemblées dans une même liste,        
        celle-ci est configurée pour copier ses dépendances dans le répertoire ressource de l'application.
        La balise <sgmltag>includes</sgmltag> du dernier <sgmltag>dependencySet</sgmltag> annule les exclusions du <sgmltag>dependencySet</sgmltag> précédent.
        Ainsi, les dépendances ressources sont incluses en utilisant un seul pattern d'identité : <varname>*:zip</varname>.
        La dernière balise <sgmltag>dependencySet</sgmltag> fait référence à des ressources partagées et est configurée pour deziper celles-ci à la racine de l'application web.</para>

        <para>L'<xref linkend="ex-complex-dependencySet" /> présume que le projet contenant les ressources partagées a un type différent des autres dépendances. 
        Que se passerait-il si celle-ci avait le même type que celui des autres dépendances ?
        Comment différencieriez-vous cette dépendance ?
        Dans ce cas, si une dépendance de ressources partagées a été packagée comme un JAR avec le classificateur de type <varname>resources</varname>,  
        vous pouvez changer le pattern d'identité pour qu'il match ces dépendances :</para> 

        <programlisting>*:jar:resources</programlisting>

        <para>Au lieu de matcher les artefacts de type <varname>zip</varname> sans classificateur,
        nous matchons ici les artefacts de type <varname>jar</varname> qui possède un classificateur <varname>resources</varname>.</para>   

        <para>Comme pour la section <sgmltag>fileSets</sgmltag>, <sgmltag>dependencySets</sgmltag> supporte l'utilisation du flag <sgmltag>useStrictFiltering</sgmltag>. 
        Lorsque celui-ci est activé, n'importe quel pattern qui ne match pas une ou plusieurs dépendances causera l'échec de l'assembly, et donc par conséquent, du build.  
        Très pratique pour utiliser comment soupape de sécurité, pour vous assurer que les dépendances de votre projet et votre descripteur d'assembly soient correctement synchronisés.  
        Par défaut, ce flag est désactivé pour des raisons de rétrocompatibilité.</para> 
      </section>

      <section id="assemblies-sect-transitive">
        <title>Dépendances transitives, pièces jointes et artefacts de projet</title>

        <para>La section <sgmltag>dependencySet</sgmltag> vous propose deux autres mécanismes pour vous aider dans le choix de vos artefacts :  
        options de sélection transitive et options pour travailler avec des artefacts du projet.
        Ces deux fonctionnalités proviennent de la nécessité de supporter des configurations existantes qui utilisent une définition un peu plus libérale du mot «dépendance». 
        Comme premier exemple, examinons l'artefact principal du projet.
        Typiquement, dans la majorité des cas, il ne doit pas être considéré comme une dépendance.
        Pourtant, les plus anciennes versions du plugin Assembly l'utilisaient dans le calcul des dépendances.
        Pour fournir une rétrocompatibilité avec cette “fonctionnalité”,
        la version 2.2 du plugin Assembly dispose d'un flag à mettre dans le <sgmltag>dependencySet</sgmltag>, celui-ci est appelé <sgmltag>useProjectArtifact</sgmltag>,
        La valeur par défaut de ce flag est <varname>true</varname>. 
        Par défaut, le set de dépendances essayera d'inclure l'artefact du projet dans le calcul de ses dépendances.  
        Si vous préférez gérer l'artefact du projet séparément, affectez ce flag à <varname>false</varname>.</para>

        <tip>
          <para>Les auteurs de ce livre vous recommandent de toujours laisser le flag
          <sgmltag>useProjectArtifact</sgmltag> à <varname>false</varname>.</para>
        </tip>

        <para>Comme extension naturelle à l'inclusion d'un artefact projet, 
        les artefacts rattachés à un projet peuvent également être gérés par un  <sgmltag>dependencySet</sgmltag> en utilisant
        le flag <sgmltag>useProjectAttachments</sgmltag> (celui-ci est désactivé par défaut). 
        Activer ce flag permet aux patterns qui précisent des classificateurs et des types d'artefacts de matcher les artefacts rattachés.
        Ils partagent la même identité <varname>groupId</varname>/<varname>artifactId</varname>/<varname>version</varname>,
        mais diffèrent de <varname>type</varname> et de <varname>classifier</varname>.
        Cette fonctionnalité peut s'avérer utilise pour inclure les JARs de Javadoc ou de Source dans une assembly.</para>

        <para>En plus de traiter avec des artefacts du projet,
        il est également possible de configurer un set de dépendances en utilisant deux flags permettant d'activer la résolution transitive.
        Le premier, appelé <sgmltag>useTransitiveDependencies</sgmltag> (et activé par défaut), permet d'activer l'inclusion des dépendances transitives lors du matching.
        Comme exemple pour savoir comment il peut être utilisé, considérer ce qui arrive lorsque votre <acronym>POM</acronym> à une dépendance sur une autre assembly.
        Cette assembly aura (probablement) un classificateur qui le sépare de l'artefact principal du projet, ce qui en fait une pièce jointe.    
        Cependant, une particularité du processus de résolution des dépendances Maven que les informations des dépendances transitives pour l'artefact principal
        sont toujours utilisées pour résoudre l'artefact de l'assembly.
        Si l'assembly package ses dépendances à l'intérieur de lui-même, 
        dans ce cas, utiliser la résolution des dépendances transitives dupliquerait effectivement ces dépendances.         
        Pour éviter cela, nous pouvons simplement affecter le flag <sgmltag>useTransitiveDependencies</sgmltag> à <varname>false</varname>.</para>

        <para>L'autre flag permettant de résoudre les dépedances dépendances est plus subtil.
        Il est appelé <sgmltag>useTransitiveFiltering</sgmltag> et sa valeur par défaut est <varname>false</varname>.
        Pour comprendre ce que fait ce flag, nous devons d'abord comprendre quelles informations sont disponibles pour un artefact donné lors du processus de résolution des dépendances. 
        Quand un artefact est une dépendance d'un autre (qui est, retiré au moins un niveau à partir de votre <acronym>POM</acronym>),
        elle a ce que Maven appelle un "chemin de dépendances", laquelle est maintenue comme une liste de chaînes de caractère et correspond à l'identité complète de l'artefact 
        (<varname>groupId:artifactId:type:[classifier:]version</varname>)
        de toutes les dépendances entre votre <acronym>POM</acronym> et l'artefact a qui appartient ce chemin.
        Si vous vous rappelez des trois types d'identités des artefacts disponibles pour pattern matching,
        vous remarquerez que les entrées dans ce chemin de dépendances - l'identité complète de l'artefact  - correspond au troisième type.
        Lorsque le flag <sgmltag>useTransitiveFiltering</sgmltag> est affecté à <varname>true</varname>, 
        toutes les entrées du chemin de dépendances d'un artefact peuvent agir sur l'inclusion ou l'exclusion de cet artefact.</para>

        <para>Si vous considérez l'utisation de ce filtrage transitif, prennez garde !
        Un artefact peut être inclus à partie de nombreux emplacement dans un graphe de dépendance, mais dans Maven 2.0.9,
        seul le premier chemin de dépendances est utilisé pour ce type de matching.
        Cela peut conduire à des problèmes subtils dans la collecte des dépendances de votre projet.</para>

        <warning>
          <para>La plupart des assembly ne nécessitent ce niveau de contrôle sur les sets de dépendances,
          reflechissez attentivement pour savoir si la vôtre en a vraiment besoin. Astuce : ce n'est probablement pas le cas.</para>
        </warning>
      </section>

      <section id="assemblies-sect-unpack">
        <title>Options avancées de dépaquetage</title>

        <para>Comme discuté précédemment, certaines dépendances de projet ont besoin d'être dézippées pour créer une assembly.
        Dans les exemples ci-dessus, la décision de dézipper ou non était simple.
        Il ne tient pas compte de ce qui doit être dépaqueté, ou plus important, de ce qui ne doit pas être dépaqueté. 
        Pour obtenir plus de contrôle sur le processus de dépaquetage,
        vous pouvez configurer la balise <sgmltag>unpackOptions</sgmltag> dans votre <sgmltag>dependencySet</sgmltag>.
        Ainsi, vous avez la possibilité de choisir quels fichiers vous voulez inclure dans votre assembly,
        et quels fichiers doivent être filtrés pour résoudre des expressions à partir des informations du <acronym>POM</acronym>.
        En fait, les options disponibles pour dépaqueter vos sets de dépendances sont similaires à celles disponibles pour l'inclusion ou l'exclusion de fichier.</para>

        <para>Pour continuer notre exemple d'application web,
        supposons que certaines dépendances de ressources aient été zippées avec un fichier qui décrit les détails de leur licence de distribution.
        Dans le cas de notre application web,
        ces licences se présenteront sous la forme d'un fichier <filename>NOTICES</filename> inclu dans notre paquetage.
        Pour exclure ce fichier, ajoutons-le simplement aux options de dépaquetage dans le set des dépendances qui gère les artefacts de ressources :</para> 

        <example>
          <title>Exclusion de fichiers dans le dépaquetage d'une dépendance</title>

          <programlisting language="xml">&lt;asembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/\${webContextName}/resources
      &lt;/outputDirectory&gt;
      &lt;includes&gt;
        &lt;include&gt;*:zip&lt;/include&gt;
      &lt;/includes&gt;
      &lt;unpack&gt;true&lt;/unpack&gt;
      &lt;unpackOptions&gt;
        &lt;excludes&gt;
          &lt;exclude&gt;**/LICENSE*&lt;/exclude&gt;
        &lt;/excludes&gt;
      &lt;/unpackOptions&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Notez que le tag <sgmltag>exclude</sgmltag> que nous utilisons ressemble beaucoup à celui de la déclaration du <sgmltag>fileSet</sgmltag>.  
        Ici, nous interdisons les fichiers qui commencent par le mot <filename>LICENSE</filename> dans les répertoires de nos artefacts de ressources.
        Vous pouvez comparer la section des options de dépaquetage à un petit <sgmltag>fileSet</sgmltag> appliqué à chaque dépendance qui match ce set.
        En d'autres mots, il s'agit d'un <sgmltag>fileSet</sgmltag> utilisé pour le dépaquetage des dépendances.
        Tout comme nous avons spécifié un modèle d'exclusion pour les dossiers dans les dépendances de ressources afin de bloquer certains fichiers,
        vous pouvez également choisir un ensemble restreint de fichiers à inclure en utilisant la section <varname>includes</varname>.
        Le même code que celui du processus d'inclusion et d'exclusion des <sgmltag>fileSets</sgmltag> peut-être réutilisé pour le traitement des <sgmltag>unpackOptions</sgmltag>.</para>

        <para>En plus de mécanisme d'inclusion et d'exclusion,
        les options de dépaquetages sur un set de dépendances peuvent également fournir un flag <sgmltag>filtering</sgmltag>,
        par défaut sa valeur est <varname>false</varname>.
        Encore une fois, cela ressemble beaucoup au mécanisme proposé par les sets de fichiers discuté ci-dessus.
        Les expressions peuvent utiliser soit la syntaxe Maven d'une <varname>\${property}</varname>, soit la syntaxe Ant d'une <varname>@property@</varname>.
        Le filtrage des ressources est particulièrement intéressant pour les sets de dépendances.        
        Car elle permet de créer des templates ressources normalisés et versionnés qui peuvent être personnalisés pour chaque assembly dans lequel ils sont inclus.
        Une fois que vous maîtrisez la fonctionnalité de filtrage, que vous avez dépaqueté les dépendances qui sont stockées dans des ressources partagées,
        vous serez en mesure de commencer à abstraire certaines ressources répétées.</para>
      </section>

      <section id="assemblies-sect-summarizing">
        <title>Résumer les sets de dépendances</title>

        <para>Au final, il est important de mentionner que les sets de dépendances supportent les mêmes options de configuration <sgmltag>fileMode</sgmltag> et <sgmltag>directoryMode</sgmltag> que celles des sets de fichiers.
        Cependant, vous devrez vous rappeler que le <sgmltag>directoryMode</sgmltag> ne sera utilisé que si les dépendances sont dépaquetées.</para>
      </section>
    </section>

    <section id="assemblies-sect-modulesets">
      <title>Balise <sgmltag>moduleSets</sgmltag></title>

      <para>Les builds multimodule sont généralement rassemblés ensemble en utilisant les balises <varname>parent</varname> et <varname>modules</varname> dans les <acronym>POM</acronym>s. 
      Typiquement, les <acronym>POM</acronym>s parents spécifient leurs fils dans une section <sgmltag>modules</sgmltag>,
      qui, en temps normal, aura pour effet de les inclure dans la procédure de build du projet parent.   
      La relation entre ses deux projets, et comment elle a été contruite, peut avoir des implications importantes dans manière dont le plugin Assembly participe à ce processus, mais nous en discuterons plus tard.
      Pour l'instant, contentons-nous de garder à l'esprit la relation parent-module telle que nous l'avions vu dans la section <sgmltag>moduleSets</sgmltag>.</para>  

      <!--TODO: I think we need a simple example of how/why this would be used.-->

      <para>Les projets sont construits sous la forme d'un projet multimodule parce qu'ils font partie d'un système plus vaste.
      Ces projets sont conçus pour être utilisés ensemble, un module unique dans un grand build n'a peu de valeur en lui-même.
      De cette façon, la structure du build du projet est liée à la façon dont nous espérons que ce projet (et ses modules) soit utilisé.
      Si vous considérez le projet du point de vue de l'utilisateur, 
      il semble logique que l'objectif final de ce build soit de construire et distribuer un seul fichier que les utilisateurs pourront directement déployer sans trop de tracas. 
      Comme les builds multimodule Maven s'appuient habituellement sur une structure top-down,
      où des informations de dépendances, des configurations de plugin et bien d'autres informations sont hérités du projet parent à l'enfant,
      il semble naturel que la tâche de transformation de ces modules dans un fichier unique distribuable doive incomber au projet le plus haut dans la hiérarchie.
      Voilà où la balise <sgmltag>moduleSet</sgmltag> intervient.</para>

      <para>Les sets de modules permettent l'inclusion de ressources dans l'assembly final, celles-ci dépendent de chaque module dans la structure du projet. 
      Tout comme vous pouvez choisir un groupe de fichiers à inclure dans un assembly en utilisant les balises <sgmltag>fileSet</sgmltag> et <sgmltag>dependencySet</sgmltag>,
      vous pouvez inclure un set de fichier et de ressources en utilisant un <sgmltag>moduleSet</sgmltag> pour se référer aux modules d'un build multimodule.
      Cela est rendu possible grâce aux deux types d'inclusion spécifique aux modules : l'un basé sur les fichiers, l'autre sur les artefacts. 
      Avant d'entrer dans les particularités ces deux types d'inclusion de modules ressources dans une assembly,
      parlons un peu de comment sélectionner les modules à traiter.</para>

      <section id="assemblies-sect-module-selection">
        <title>Sélection des modules</title>

        <para>Maintenant, vous devriez commencer à maîtriser les patterns <sgmltag>includes</sgmltag>/<sgmltag>excludes</sgmltag>, ils sont également utilisés dans les descripteurs d'essembly pour filter les fichiers et les dépendances. 
        Dans un descripteur d'un assembly, lorsque vous faites référence à des modules, vous pouvez également utiliser ces patterns <sgmltag>includes</sgmltag>/<sgmltag>excludes</sgmltag> 
        pour définir les règles qui s'appliquent sur différents sets de modules. 
        La particularité des partterns <sgmltag>includes</sgmltag> et <sgmltag>excludes</sgmltag> d'un <sgmltag>moduleSet</sgmltag> est qu'ils ne permettent pas d'utiliser de wildcards. 
        (du moins dans Maven 2.2-beta-2, cette fonctionnalité n'a pas été beaucoup demandée, elle n'a donc pas été implémentée.)
        À la place de cela, chaque balise <varname>include</varname> et <varname>exclude</varname> correspond simplement au <varname>groupId</varname> et à l'<varname>artifactId</varname> du module, séparé par un caractère ':', comme ceci :</para>   

        <programlisting>groupId:artifactId</programlisting>

        <para>En plus des balises <sgmltag>includes</sgmltag> et <sgmltag>excludes</sgmltag>,
        le <sgmltag>moduleSet</sgmltag> propose d'autres outils de sélection : 
        le flag <sgmltag>includeSubModules</sgmltag> (dont la valeur par défaut est <varname>true</varname>).
        La relation parent-enfant d'une structure multimodule n'est pas limitée à deux tiers d'un projet. 
        En fait, vous pouvez inclure n'importe quel nombre de tiers, ou de couche, dans votre build. 
        Chaque projet qui est un module du module du projet courant est considéré comme un sous-module.
        Dans certains cas, vous souhaitez construire chaque module séparément (y compris les sous-modules).
        Pour cela, affectez simplement la valeur du flag <sgmltag>useSubModules</sgmltag> à <varname>true</varname>.</para>

        <para>Lorsque vous essayez d'inclure des fichiers dans une structure de répertoires de chaque module, 
        vous souhaitez déclarer cette structure de répertoire une seule fois. 
        Si votre structure de répertoire du projet reflète celle des relations du module parent qui sont inclus dans les <acronym>POM</acronym>s, 
        cette approche permet aux patterns de fichiers comme <varname>**/src/main/java</varname> de s'appliquer non seulement aux répertoires directs de ce module, 
        mais également pour les répertoires de ses propres modules.
        Dans le cas ou ne voudriez pas traiter les sous-modules directement 
        (ils seront traités à la place comme des sous-répertoires dans les modules de votre projet),
        affectez la valeur du flag <sgmltag>useSubModules</sgmltag> à <varname>false</varname>.</para>

        <para>Une fois que nous avons déterminé comment la sélection module doit s'exécuter sur l'ensemble des modules, 
        nous sommes prêts à choisir ce qu'ils doivent contenir.
        Comme mentionné ci-dessus, il est possible d'inclure des fichiers ou des artefacts provenant du module du projet.</para>
        
      </section>

      <section id="assemblies-sect-sources-section">
        <title>Balise <varname>sources</varname></title>

        <para>Supposez que vous désirez inclure les sources de tous les modules dans votre assembly, mais que vous voulez exclure un module en particulier.
        Peut-être avec vous un projet appelé <varname>secret-sauce</varname> qui contient du code secret et sensible que vous ne voulez pas distribuer dans votre projet.
        Le moyen le plus simple d'effectuer cela est d'utiliser la balise <sgmltag>moduleSet</sgmltag> qui inclus chaque répertoire d'un projet 
        dans <varname>\${module.basedir.name}</varname> et qui exclu le module <varname>secret-sauce</varname> de l'assembly.</para>

        <example id="ex-include-exclude-moduleSet">
          <title>Inclusion et exclusion de modules dans un <sgmltag>moduleSet</sgmltag></title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;includeSubModules&gt;false&lt;/includeSubModules&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;
          com.mycompany.application:secret-sauce
        &lt;/exclude&gt;
      &lt;/excludes&gt;
      &lt;sources&gt;
        &lt;outputDirectoryMapping&gt;
          \${module.basedir.name}
        &lt;/outputDirectoryMapping&gt;
        &lt;excludeSubModuleDirectories&gt;
          false
        &lt;/excludeSubModuleDirectories&gt;
        &lt;fileSets&gt;
          &lt;fileSet&gt;
            &lt;directory&gt;/&lt;/directory&gt;
            &lt;excludes&gt;
              &lt;exclude&gt;**/target&lt;/exclude&gt;
            &lt;/excludes&gt;
          &lt;/fileSet&gt;
        &lt;/fileSets&gt;
      &lt;/sources&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Dans l'<xref linkend="ex-include-exclude-moduleSet" />,
        puisque nous devons gérer les sources de chaque module,
        il est plus simple de traiter seulement les modules directs du projet en cours,
        en manipulant les sous-modules avec le widlcard chemin/fichier. 
        Renseignez l'élément <sgmltag>includeSubModules</sgmltag> à <varname>false</varname>.
        Ainsi, nous n'avons donc pas à nous soucier de sous-modules qui apparaissent dans le répertoire racine de l'archive d'assemblage.
        La balise <sgmltag>exclude</sgmltag> s'occupera d'exclure votre module secret <varname>secret-sauce</varname>.</para>

        <para>Normalement, les sources du module sont incluses dans l'assembly dans un sous-répertoire qui est nommé âpres <varname>artifactId</varname> du module.  
        Toutefois, comme Maven permet aux modules qui ne sont pas dans des répertoires nommés d'après l'<varname>artifactId</varname> du module du projet,
        il est souvent préférable d'utiliser une expression <varname>\${module.basedir.name}</varname> pour préserver le nom du répertoire du module courant.
        (<varname>\${module.basedir.name}</varname> revient au même que d'appeler la méthode  <methodname>MavenProject.getBasedir().getName()</methodname>).
        Il est important de se rappeler que les modules qui ne sont pas nécessairement des sous-répertoires du projet qui les déclare.
        Si votre projet possède une structure particulièrement étrange, 
        vous pouvez avoir besoin de recourir à la déclaration de balises <sgmltag>moduleSet</sgmltag> spéciales 
        qui sauront comprendre et tenir compte des particularités de votre projet.</para>    

        <warning>
          <para>Pour essayer de minimiser les particularités votre projet, comme Maven est flexible,
          si vous vous prenez à faire trop de configuration,c'est qu'il y a probablement un moyen plus facile d'y arriver.</para>
        </warning>

        <para>Continuons à parcourir l'<xref linkend="ex-include-exclude-moduleSet" />, 
        since we’re not processing sub-modules explicitly in this module set, 
        we need to make sure sub-module directories are not excluded from the source directories we consider for each direct module. 
        By setting the <sgmltag>excludeSubModuleDirectories</sgmltag> flag to <varname>false</varname>, 
        this allows us to apply the same file pattern to directory structures within a sub-module of the one we’re processing. 
        Finally in <xref linkend="ex-include-exclude-moduleSet" />, 
        we’re not interested in any output of the build process for this module set. We exclude the target/ directory from all modules.</para>

        <para>Ca vaut également le coup de mentionner que la balise <sgmltag>sources</sgmltag> supporte les éléments du type <sgmltag>fileSet</sgmltag> directement dans celle-ci ou dans ses sous-balises imbriquées.    
        Ces balises de configuration sont utilisées pour fournir une rétrocompatibilité avec les anciennes versions du plugin Assembly (versions 2.1 et précédentes)
        qui ne prenaient pas en charge plusieurs sets fichiers pour un même module sans créer de <varname>modulesSet</varname> séparés.
        Elles sont dépréciées, vous ne devez pas les utiliser.</para>

      </section>

      <section id="assemblies-sect-interpolate-modulesets">
        <title>Interpolation de l'<sgmltag>outputDirectoryMapping</sgmltag> dans les <sgmltag>moduleSets</sgmltag></title>

        <para>Dans l'<xref linkend="assemblies-sect-output-location" />, 
        nous avons utilisé la balise <sgmltag>outputDirectoryMapping</sgmltag> pour changer le nom du répertoire sous lequel est inclue chaque source des modules. 
        Les expressions contenues dans cette balise sont résolues exactement de la même manière que celles de la balise <sgmltag>outputFileNameMapping</sgmltag>,
        qui utilisait des sets de dépendances (référez-vous à l'explication de cet algorithme dans la section <xref linkend="assemblies-sect-output-algorithm" />).</para>

        <para>Dans l'<xref linkend="ex-include-exclude-moduleSet" />, vous avons utilisé l'expression <varname>\${module.basedir.name}</varname>. 
        Vous avez peut-être remarqué que le début de cette expression, <varname>module</varname>,
        n'est pas listé dans l'algorithme de résolution des mappings de la section <xref linkend="assemblies-sect-output-algorithm" />.
        Cet objet root est spécifique à la configuration des <sgmltag>moduleSets</sgmltag>.
        Il fonctionne de la même manière que les réléférences à <varname>\${artifact.*}</varname> disponible dans la balise <sgmltag>outputFileNameMapping</sgmltag>,
        à l'exception qu'il s'applique aux instances <classname>MavenProject</classname>, <classname>Artifact</classname> et <classname>ArtifactHandler</classname> du module
        au lieu de celles d'un artefact de dépendance.</para>
      </section>

      <section id="assemblies-sect-binaries">
        <title>Balise <varname>binaries</varname></title>

        <para>Tout comme la balise <sgmltag>sources</sgmltag> se charge de l'inclusion des sources d'un module,
        la balise <sgmltag>binaries</sgmltag> se charge d'inclure les sorties du build d'un module, ou ses artefacts. 
        Bien que cette section fonctionne essentiellement comme un moyen de spécifier un <sgmltag>dependencySets</sgmltag> à appliquer à chaque module de la série,
        quelques fonctionnalités propres aux artefacts des modules méritent d'être explorées : <sgmltag>attachmentClassifier</sgmltag> et <sgmltag>includeDependencies</sgmltag>. 
        En plus de cela, la balise <sgmltag>binaries</sgmltag> contient une option similaire à la balise <sgmltag>dependencySet</sgmltag>,
        qui a trait à la manipulation de l'artefact du module lui-même.
        Il s'agit : <sgmltag>unpack</sgmltag>, <sgmltag>outputFileNameMapping</sgmltag>, <sgmltag>outputDirectory</sgmltag>, <sgmltag>directoryMode</sgmltag> et <sgmltag>fileMode</sgmltag>. 
        Enfin, les binaires d'un module peuvent contenir une balise <sgmltag>dependencySets</sgmltag> pour spécifier comment les dépendances de chaque module doivent être incluses dans l'assembly. 
        D'abord, jetons un coup d'oeil à la façon dont ces options peuvent être utilisées pour gérer les artefacts propres au module.</para>

        <para>Supposons que nous voulons inclure JARs de Javadoc pour chacun de nos modules à l'intérieur de notre assembly.
        Dans ce cas, nous ne nous soucions pas de l'inclusion des dépendances, nous voulons simplement ajouter le JAR de la Javadoc.
        Toutefois, comme ce JAR un peu particulier est toujours présent en tant que pièce jointe de l'artefact principal, 
        nous devons spécifier le classificateur à utiliser pour le récupérer.
        Pour simplifier, nous ne couvrirons pas dépaquetage les JARs de Javadoc des modules, 
        puisque la configuration est exactement la même que celle utilisée pour les dépendances, comme nous l'avons abordé précédemment dans ce chapitre.
        Le <varname>moduleSet</varname> devrait ressembler à l'<xref linkend="ex-include-javadoc-moduleset" />.</para>

        <example id="ex-include-javadoc-moduleset">
          <title>Inclure la Javadoc des modules dans une Assembly</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;binaries&gt;
        &lt;attachmentClassifier&gt;javadoc&lt;/attachmentClassifier&gt;
        &lt;includeDependencies&gt;false&lt;/includeDependencies&gt;
        &lt;outputDirectory&gt;apidoc-jars&lt;/outputDirectory&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Dans l'<xref linkend="ex-include-javadoc-moduleset" />,
        vous ne spécifiez pas directement de valeur au flag <sgmltag>includeSubModules</sgmltag> flag, celui-ci est activé par défaut.
        Cependant, nous tenons absolument à traiter tous les modules - même les sous-modules - en utilisant ce <varname>moduleSet</varname> :
        nous n'utilisons aucune sorte de pattern de fichier qui pourrait correspondre à des structures de sous-répertoire à l'intérieur du module.
        Pour chaque module, la balise <sgmltag>attachmentClassifier</sgmltag> récupérer l'artefact qui lui est attaché grâce au classificateur Javadoc.
        La balise <sgmltag>includeDependencies</sgmltag> signale au plugin Assembly que l'on n'est pas intéressé par les dépendances des modules, nous récupérons juste les pièces jointes.  
        Enfin, la balise <sgmltag>outputDirectory</sgmltag> demande au plugin Assembly de mettre tous les JARs de JAvadoc dans un répertoire nommé 
        <filename>apidoc-jars/</filename> en dehors du répertoire de l'assembly.</para>

        <para>Bien que nous ne faisons rien de très compliqué dans cet exemple,
        il est important de noter que les mêmes changements de l'exécution de l'algorithme de résolution des expressions, 
        dont nous avions parlé à propos de la balise <sgmltag>outputDirectoryMapping</sgmltag> de la balise <varname>sources</varname>, s'appliquent également ici.
        Tout ce qui est accessible par <varname>\${artifact.*}</varname> dans la configuration de la balise <sgmltag>outputFileNameMapping</sgmltag> du <sgmltag>dependencySet</sgmltag> est également disponible dans <varname>\${module.*}</varname>.  
        La même chose s'applique pour toute balise <sgmltag>outputFileNameMapping</sgmltag> lorsqu'elle est utilisée directement dans une balise <sgmltag>binaries</sgmltag>.</para>

        <para>Enfin, examinons un exemple dans lequel nous voulons simplement traiter l'artefact du module et ses dépendances <varname>runtime</varname>.
        Dans ce cas, nous voulons séparer la configuration de l'artefact pour chaque module dans un set et une structure de répertoire séparés, 
        en fonction de l'<varname>artifactId</varname> et de la <varname>version</varname> des modules.
        Le <varname>moduleSet</varname> reste simple, il ressemble au code de l'<xref linkend="ex-the-big-include" /> :</para>

        <example id="ex-the-big-include">
          <title>Inclusion des artefacts d'un module et de ses dépendances dans une assembly</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;binaries&gt;
        &lt;outputDirectory&gt;
          \${module.artifactId}-\${module.version}
        &lt;/outputDirectory&gt;
        &lt;dependencySets&gt;
          &lt;dependencySet/&gt;
        &lt;/dependencySets&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Dans l'<xref linkend="ex-the-big-include" />, nous utilisons la balise <sgmltag>dependencySet</sgmltag> en la laissant vide.
        Comme vous devez inclure toutes les dépendances, par défaut, vous n'avez pas besoin d'effectuer de configuration. 
        Lorsque la balise <sgmltag>outputDirectory</sgmltag> est spécifiée dans la balise <varname>binaires</varname>,
        toutes les dépendances devraient être incluses aux côtés de l'artefact du module dans le même répertoire.
        Ainsi, nous n'avons pas besoin le configurer tout cela dans le <varname>dependencySet</varname>.</para>  

        <para>La plupart du temps, les binaires d'un module restent assez simples.
        Dans les deux parties
        - la partie principale, chargée de la manipulation de l'artefact du module lui-même, des ensembles de dépendances, et qui est chargé des dépendances du module -  
        les options de configuration restent très similaires à celles des sets de dépendances.
        Bien entendu, la balise <varname>binaires</varname> fournie également des options pour contrôler 
        quelles dépendances sont incluses et quel artefact principal de projet vous souhaitez utiliser.</para>

        <para>Comme pour la balise <varname>source</varname>, la balise <varname>binaries</varname> dispose d'options de configuration qui sont fournies uniquement pour des causes de rétrocompatibilité.
        Celles-ci devraient être dépréciées, comment l'utilisation des sous-sections <varname>includes</varname> et <varname>excludes</varname>.</para>
      </section>

      <section id="assemblies-sect-modulesets-parent-pom">
        <title><sgmltag>moduleSets</sgmltag>, <acronym>POM</acronym>s parents et balise <sgmltag>binaries</sgmltag></title>

        <para>Enfin, clôturons cette discussion avec un avertissement.
        En ce qui concerne les relations parents-module, il existe des interactions subtiles entre le fonctionnement interne de Maven et l'exécution d'un <varname>moduleSet</varname> dans une balise <varname>binaires</varname>.         
        Lorsqu'un <acronym>POM</acronym> déclare un parent, 
        ce parent doit être résolu d'une façon ou d'une autre avant que le <acronym>POM</acronym> en question puisse être construit.
        Si un parent est dans un dépôt Maven, pas de problème.
        Cependant, vous vous exposez à de gros problèmes si le parent dispose d'un <acronym>POM</acronym> de plus haut niveau dans le même build,
        en particulier si le <acronym>POM</acronym> parent utilise les binaires de ces modules.</para>

        <para>Maven 2.0.9 trie les projets d'un build multimodule en fonction de leurs dépendances, avec des dépendances d'un projet construit avant celui-ci.
        Le problème est que l'élément parent est considéré comme une dépendance, 
        ce qui signifie que le build du projet parent doit être effectué avant que le projet enfant soit construit.
        Si une partie du build de ce parent inclus la création d'une assembly qui utilise les binaires des modules, 
        ces binaires ne seront pas encore créés et ne pourront donc pas être inclus.
        Cela provoquera ainsi l'échec de la construction de l'assembly. 
        Il s'agit d'une question complexe et subtile.
        Elle limite sérieusement l'utilité de la section <varname>binaires</varname> module du descripteur d'assembly. 
        En fait, à ce sujet, un bug a été créé sur legestionnaire d'anomalie du plugin Assembly : <ulink
        url="http://jira.codehaus.org/browse/MASSEMBLY-97">http://jira.codehaus.org/browse/MASSEMBLY-97</ulink>.
        Il faut espérer que les futures versions de Maven vont trouver un moyen de réparer cette fonctionnalité, 
        puisque la relation parent-first n'est pas forcément nécessaire.</para>
      </section>
    </section>

    <section id="assemblies-sect-repositories">
      <title>Balise <varname>repositories</varname></title>

      <para>Dans le descripteur d'assembly, la balise <varname>repositories</varname> est un élément un peu plus exotiques,
      peu d'applications (autre que Maven) peuvent tirer pleinement parti de la structure de répertoires d'un dépôt Maven. 
      Pour cette raison, et parceque nombre de ces fonctionnalités ressemblent étroitement à la balise <sgmltag>dependencySets</sgmltag>,
      nous ne passerons que très rapidement sur la présentation de cette balise.  
      Dans la plupart des cas, les utilisateurs qui ont compris comment fonctionnent les <sgmltag>dependencySets</sgmltag> n'auront aucun souci à 
      utiliser la balise <varname>repositories</varname> par l'intermédiaire du plugin Assembly
      Nous n'allons donc pas illustrer cette balise par un cas d'utilisation.
      Nous allons simplement donner quelques mises en garde pour ceux d'entre vous qui ressentent le besoin d'utiliser la balise <sgmltag>repositories</sgmltag>.</para>

      <!--TODO: We probably need to motivate why you would ever want to do this.  Right now, this section
doesn't make sense to new users.-->

      <para>Cela dit, nous avons deux fonctionnalités à mentionner en particulier à propos des balises <varname>repositories</varname>.
      La première est le flag <sgmltag>includeMetadata</sgmltag>. 
      Lorsque activé ce flag, les métadatas sont inclus, comme la liste des versions réelles qui correspondent aux versions virtuelles <varname>-SNAPSHOT</varname>. 
      Par défaut ce flag est désactivé.
      À l'heure actuelle, seules les métadatas incluses lorsque ce flag est à <varname>true</varname> sont téléchargées comme informations à partir du dépôt centra Maven.</para> 

      <para>La seconde fonctionnalité est appelée <sgmltag>groupVersionAlignments</sgmltag>. 
      Ici encore, cette balise représente une liste de configurations individuelles <sgmltag>groupVersionAlignment</sgmltag>,
      dont le but est de normaliser tous les artefacts inclus pour un <varname>groupId</varname> particulier pour utiliser une seule <varname>version</varname>. 
      Chaque entrée se compose de deux éléments obligatoires : un <varname>id</varname> et une <varname>version</varname>,
      ainsi qu'une section optionnelle appelée <sgmltag>excludes</sgmltag> qui fournit une liste d'<varname>artifactId</varname> qui doivent être exclus de ce réalignement.
      Malheureusement, ce remaniement ne semble pas modifier les <acronym>POM</acronym>s impliqués dans le dépôt,
      ni ceux liés à des artefacts réaligner, ni ceux qui dépendent des artefacts réalignés.
      De ce fait, il est difficile d'imaginer un réel cas d'utilisation pour ce genre de réalignement.</para>

      <para>En général, le plus simple est d'utiliser les mêmes principes que ceux des <sgmltag>dependencySets</sgmltag> que vous ajoutez à votre descripteur d'assembly.
      Même si la balise <varname>repositories</varname> supporte d'autres options, 
      elles sont principalement fournies pour des raisons de rétrocompatibilité, et seront probablement dépréciées dans les prochaines releases.</para> 
    </section>

    <section id="assemblies-sect-managing-root">
      <title>Gestion du répertoire racine de l'assembly</title>

      <para>Maintenant que nous avons parcouru les principales fonctionnalités dy déscripteur d'assembly,
      nous pouvons clôturer la discussion du contenu de ce descripteur avec quelque chose de plus léger :
      nommer un répertoire racine et manipulation des répertoires de site.</para>

      <para>Il est souvent important d'avoir le contrôle sur le nom du répertoire racine de votre assembly, ou de savoir a minima où on se trouve celui-ci.
      Deux options de configurations sont disponibles dans le descripteur d'assembly pour vous permettre de gérer le répertoire racine de vos archives :
      <sgmltag>includeBaseDirectory</sgmltag> et <sgmltag>baseDirectory</sgmltag>.
      Dans le cas de JAR execuratables, vous n'avez pas besoin de répertoire racine. 
      Pour ceci, il vous suffit d'inclure la balise <sgmltag>includeBaseDirectory</sgmltag> à <varname>false</varname>
      (sa valeur par défaut est <varname>true</varname>). 
      Ainsi, vous obtiendrez une archive, qui une fois dépaquetée, peut contenir plusieurs répertoires. 
      Ce type d'archives est considéré comme invalide, vous devez les dépaqueter avant de les utiliser.</para>

      <para>Dans les autres cas, vous voudrez garantir le nom de votre répertoire racine de votre archive quelque soientt les informations contenues dans votre <acronym>POM</acronym> (comme la version par exemple).
      Par défaut, la balise <sgmltag>baseDirectory</sgmltag> à pour valeur <varname>\${project.artifactId}-\${project.version}</varname>.
      Cependant, vous pouvez modifier cette valeur aisemment avec n'importe quelle expression provenant du <acronym>POM</acronym>,
      par exemple : <varname>\${project.groupId}-\${project.artifactId}</varname>.    
      Cette fonctionnalité peut s'avèrer très pratique pour les équipes de documentation (tout le mond en a, n'est-ce pas ?).</para>

      <para>Continuons avec la présentation d'un autre flag de configuration : <sgmltag>includeSiteDirectory</sgmltag>.
      Par défaut, celui-ci a pour valeur <varname>false</varname>.  
      Si le build de votre projet construit répertoire racine pour un site en utilisant le cycle de vie ou les goals du plugin Maven Site,  
      la sortie de celui-ci peut être inclus à l'assembly en positionnant ce flag à <varname>false</varname>.       
      Cependant, celle fonctionnalité est un peu limitée,
      comme on se contente d'inclure le répertoire <sgmltag>outputDirectory</sgmltag> dans la section reporting du <acronym>POM</acronym> courant (par défaut, <filename>target/site</filename>)
      sans prendre en considération d'éventuels autres répertoires qui pourraient être disponibles dans d'autres modules.
      Utilisez cette option si vous le désirez, mais vous pouvez obtenir le même résultat en utilisant un <sgmltag>fileSet</sgmltag> ou un <sgmltag>moduleSet</sgmltag>.
      Il s'agit encore d'un autre exemple de configuration legacy supportée par le plugin Assembly pour assurer la rétrocompatibilité.       
      Vos besoins peuvent évoluer, si vous désirer inclure un site provenant de plusieurs modules, privilégiez l'utilisation des 
      <sgmltag>fileSet</sgmltag> ou des <sgmltag>moduleSet</sgmltag> à la place d'activer le flag  <sgmltag>includeSiteDirectory</sgmltag>.</para>

    </section>

    <section id="assemblies-sect-componentDescriptors">
      <title><sgmltag>componentDescriptors</sgmltag> et
      <sgmltag>containerDescriptorHandlers</sgmltag></title>

      <para>Terminons l'exploration du descripteur d'assembly avec la présentation de deux dernières balises :  
      <sgmltag>containerDescriptorHandlers</sgmltag> et <sgmltag>componentDescriptors</sgmltag>. 
      La balise <sgmltag>containerDescriptorHandlers</sgmltag> fait référence à des composants 
      qui vous permettent d'étendre les fonctionnalités du plugin Assembly.
      Précisément, ces composants personnalisés vous permettent de définir et de gérer certains types de fichiers
      qui peuvent être fusionnés à partir de constituants utilisés pour créer votre assembly.
      Par exemple, nous pouvons utiliser ce mécanisme pour construire un unique <filename>web.xml</filename> à partir de plusieurs fragments 
      pour l'intégrer à l'assembly.</para>

      <para>La balise <sgmltag>componentDescriptors</sgmltag> permet de référencer des des descripteurs d'assembly externes et de les inclure dans le decripteur courant.
      Les références des composants peuvent-être une des caractéristiques suivantes :</para>

      <orderedlist>
        <listitem>
          <para>Chemins relatifs :
          <filename>src/main/assembly/component.xml</filename></para>
        </listitem>

        <listitem>
          <para>Références d'artefact :
          <varname>groupId:artifactId:version[:type[:classifier]]</varname></para>
        </listitem>

        <listitem>
          <para>Ressources du classpath :
          <filename>/assemblies/component.xml</filename></para>
        </listitem>

        <listitem>
          <para>URLs : <ulink
          url="http://www.sonatype.com/component.xml">http://www.sonatype.com/component.xml</ulink></para>
        </listitem>
      </orderedlist>

      <para>Lors de la résolution d'un descripteur de composant, le plugin Assembly essaye ces différentes stratégies dans cet ordre précis.
      La première stratégie qui matche est utilisée.</para>

      <para>Les descripteurs de composant peuvent contenir plusieurs fois les mêmes sections disponibles dans le descripteur d'Assembly,
      à l'exception de la balise <sgmltag>moduleSets</sgmltag>.
      Celle-ci est considérée comme spécifique à chaque projet.
      La balise <sgmltag>containerDescriptorHandlers</sgmltag> est également incluse dans le descripteur de composant, nous venons de le présenter. 
      Les descripteurs de composants ne peuvent pas contenir de formats, d'id d'assembly ou toute autre configuration en rapport avec le répertoire racine de l'archive.
      Ils sont tous sont considérés comme propres à un descripteur d'assembly.
      Bien qu'il semble intéressant de permettre le partage de la balise <varname>formats</varname>, 
      cela n'a pas été fait jusqu'à ce jour (version 2.2-beta-2-release du plugin Assembly).</para>
    </section>
  </section>

  <section id="assemblies-sect-best-practices">
    <title>Best Practices</title>

    <para>Le plugin Assemly est assez flexible pour permettre de résoudre la plupart des problèmes par différents moyens.
    Si vous avez un besoin unique pour votre projet, 
    il ya de bonnes chances que vous puissiez utiliser directement l'une des méthodes documentées dans ce chapitre pour obtenir votre structure d'assembly désirée.
    Cette section décrit quelques-unes des bonnes pratiques qui, si elles sont respectées, rendront l'utilisation du plugin Assembly plus productive et moins pénible.</para>  

    <section id="assemblies-sect-standard-reusable">
      <title>Standard, Reusable Assembly Descriptors</title>

      <para>Up to now, we’ve been talking mainly about one-off solutions for
      building a particular type of assembly. But what do you do if you have
      dozens of projects that all need a particular type of assembly? In
      short, how can we reuse the effort we’ve invested to get our assemblies
      just the way we like them across more than one project without copying
      and pasting our assembly descriptor?</para>

      <para>The simplest answer is to create a standardized, versioned
      artifact out of the assembly descriptor, and deploy it. Once that’s
      done, you can specify that the Assembly plugin section of your project’s
      <acronym>POM</acronym> include the assembly-descriptor artifact as a
      plugin-level dependency, which will prompt Maven to resolve and include
      that artifact in the plugin’s classpath. At that point, you can use the
      assembly descriptor via the <sgmltag>descriptorRefs</sgmltag>
      configuration section in the Assembly plugin declaration. To illustrate,
      consider this example assembly descriptor:</para>

      <programlisting language="xml">&lt;assembly&gt;
  &lt;id&gt;war-fragment&lt;/id&gt;
  &lt;formats&gt;
    &lt;format&gt;zip&lt;/format&gt;
  &lt;/formats&gt;
 &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;outputDirectory&gt;WEB-INF/lib&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  &lt;fileSets&gt;
    &lt;fileSet&gt;
      &lt;directory&gt;src/main/webapp&lt;/directory&gt;
      &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;**/web.xml&lt;/exclude&gt;
      &lt;/excludes&gt;
    &lt;/fileSet&gt;
  &lt;/fileSets&gt;
&lt;/assembly&gt;</programlisting>

      <para>Included in your project, this descriptor would be a useful way to
      bundle the project contents so that it could be unpacked directly into
      an existing web application in order to add to it (for adding an
      extending feature, say). However, if your team builds more than one of
      these web-fragment projects, it will likely want to reuse this
      descriptor rather than duplicating it. To deploy this descriptor as its
      own artifact, we’re going to put it in its own project, under the
      <filename>src/main/resources/assemblies</filename> directory.</para>

      <para>The project structure for this assembly-descriptor artifact will
      look similar to the following:</para>

      <programlisting>|-- pom.xml
`-- src
    `-- main
        `-- resources
            `-- assemblies
                `-- web-fragment.xml
</programlisting>

      <para>Notice the path of our <varname>web-fragment</varname> descriptor
      file. By default, Maven includes the files from the
      <filename>src/main/resources</filename> directory structure in the final
      jar, which means our assembly descriptor will be included with no extra
      configuration on our part. Also, notice the
      <filename>assemblies/</filename> path prefix, the Assembly plugin
      expects this path prefix on all descriptors provided in the plugin
      classpath. It’s important that we put our descriptor in the appropriate
      relative location, so it will be picked up by the Assembly plugin as it
      executes.</para>

      <para>Remember, this project is separate from your actual
      <varname>web-fragment</varname> project now; the assembly descriptor has
      become its own artifact with its own version and, possibly, its own
      release cycle. Once you install this new project using Maven, you’ll be
      able to reference it in your <varname>web-fragment</varname> projects.
      For clarity, the build process should look something like this:</para>

      <screen>$ <command>mvn install</command>
(...)
[INFO] [install:install]
[INFO] Installing (...)/web-fragment-descriptor/target/\
                  web-fragment-descriptor-1.0-SNAPSHOT.jar 
       to /Users/~/.m2/repository/org/sonatype/mavenbook/assemblies/\
          web-fragment-descriptor/1.0-SNAPSHOT/\
          web-fragment-descriptor-1.0-SNAPSHOT.jar
[INFO] ---------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ---------------------------------------------------------------
[INFO] Total time: 5 seconds
(...)</screen>

      <para>Since there are no sources for the
      <varname>web-fragment-descriptor</varname> project, the resulting jar
      artifact will include nothing but our <varname>web-fragment</varname>
      assembly descriptor. Now, let’s use this new descriptor artifact:</para>

      <programlisting language="xml">&lt;project&gt;
  (...)
  &lt;artifactId&gt;my-web-fragment&lt;/artifactId&gt;
  (...)
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2-beta-2&lt;/version&gt;
        &lt;dependencies&gt;
          &lt;dependency&gt;
            &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
            &lt;artifactId&gt;web-fragment-descriptor&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;assemble&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;descriptorRefs&gt;
                &lt;descriptorRef&gt;web-fragment&lt;/descriptorRef&gt;
              &lt;/descriptorRefs&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
      (...)
    &lt;/plugins&gt;
  &lt;/build&gt;
  (...)
&lt;/project&gt;
</programlisting>

      <para>Two things are special about this Assembly plugin
      configuration:</para>

      <itemizedlist>
        <listitem>
          <para>We have to include a plugin-level dependency declaration on
          our new <varname>web-fragment-descriptor</varname> artifact in order
          to have access to the assembly descriptor via the plugin’s
          classpath.</para>
        </listitem>

        <listitem>
          <para>Since we’re using a classpath reference instead of a file in
          the local project directory structure, we must use the
          <sgmltag>descriptorRefs</sgmltag> section instead of the
          <sgmltag>descriptor</sgmltag> section. Also, notice that, while the
          assembly descriptor is actually in the
          <filename>assemblies/web-fragment.xml</filename> location within the
          plugin’s classpath, we reference it without the
          <filename>assemblies/</filename> prefix. This is because the
          Assembly plugin assumes that built-in assembly descriptors will
          always reside in the classpath under this path prefix.</para>
        </listitem>
      </itemizedlist>

      <para>Now, you’re free to reuse the <acronym>POM</acronym> configuration
      above in as many projects as you like, with the assurance that all of
      their web-fragment assemblies will turn out the same. As you need to
      make adjustments to the assembly format - maybe to include other
      resources, or to fine-tune the dependency and file sets - you can simply
      increment the version of the assembly descriptor’s project, and release
      it again. <acronym>POM</acronym>s referencing the assembly-descriptor
      artifact can then adopt this new version of the descriptor as they are
      able.</para>

      <para>One final point about assembly-descriptor reuse: you may want to
      consider sharing the plugin configuration itself as well as publishing
      the descriptor as an artifact. This is a fairly simple step; you simply
      add the configuration listed above to the
      <sgmltag>pluginManagement</sgmltag> section of your parent
      <acronym>POM</acronym>, then reference the managed plugin configuration
      from your module <acronym>POM</acronym> like this:</para>

      <programlisting language="xml">(...)
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
      &lt;/plugin&gt;
(...)</programlisting>

      <para>If you’ve added the rest of the plugin’s configuration - listed in
      the previous example - to the <sgmltag>pluginManagement</sgmltag>
      section of the project’s parent POM, then each project inheriting from
      that parent <acronym>POM</acronym> can add a minimal entry like the one
      above and take advantage of an advanced assembly format in their own
      builds.</para>
    </section>

    <section id="assemblies-set-dist-assemblies">
      <title>Distribution (Aggregating) Assemblies</title>

      <para>As mentioned above, the Assembly plugin provides multiple ways of
      creating many archive formats. Distribution archives are typically very
      good examples of this, since they often combine modules from a
      multi-module build, along with their dependencies and possibly, other
      files and artifacts besides these. The distribution aims to include all
      these different sources into a single archive that the user can
      download, unpack, and run with convenience. However, we also examined
      some of the potential drawbacks of using the
      <sgmltag>moduleSets</sgmltag> section of the assembly descriptor -
      namely, that the parent-child relationships between
      <acronym>POM</acronym>s in a build can prevent the availability of
      module artifacts in some cases.</para>

      <para>Specifically, if module <acronym>POM</acronym>s reference as their
      parent the <acronym>POM</acronym> that contains the Assembly-plugin
      configuration, that parent project will be built ahead of the module
      projects when the multi-module build executes. The parent’s assembly
      expects to find artifacts in place for its modules, but these module
      projects are waiting on the parent itself to finish building, a gridlock
      situation is reached and the parent build cannot succeed (since it’s
      unable to find artifacts for its module projects). In other words, the
      child project depends on the parent project which in turn depends on the
      child project.</para>

      <para>As an example, consider the assembly descriptor below, designed to
      be used from the top-level project of a multi-module hierarchy:</para>

      <programlisting language="xml">&lt;assembly&gt;
  &lt;id&gt;distribution&lt;/id&gt;
  &lt;formats&gt;
    &lt;format&gt;zip&lt;/format&gt;
    &lt;format&gt;tar.gz&lt;/format&gt;
    &lt;format&gt;tar.bz2&lt;/format&gt;
  &lt;/formats&gt;
  
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;includes&gt;
        &lt;include&gt;*-web&lt;/include&gt;
      &lt;/includes&gt;
      &lt;binaries&gt;
        &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
        &lt;unpack&gt;true&lt;/unpack&gt;
        &lt;includeDependencies&gt;true&lt;/includeDependencies&gt;
        &lt;dependencySets&gt;
          &lt;dependencySet&gt;
            &lt;outputDirectory&gt;/WEB-INF/lib&lt;/outputDirectory&gt;
          &lt;/dependencySet&gt;
        &lt;/dependencySets&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
    &lt;moduleSet&gt;
      &lt;includes&gt;
        &lt;include&gt;*-addons&lt;/include&gt;
      &lt;/includes&gt;
      &lt;binaries&gt;
        &lt;outputDirectory&gt;/WEB-INF/lib&lt;/outputDirectory&gt;
        &lt;includeDependencies&gt;true&lt;/includeDependencies&gt;
        &lt;dependencySets&gt;
          &lt;dependencySet/&gt;
        &lt;/dependencySets&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
&lt;/assembly&gt;</programlisting>

      <para>Given a parent project - called app-parent - with three modules
      called <varname>app-core</varname>, <varname>app-web</varname>, and
      <varname>app-addons</varname>, notice what happens when we try to
      execute this multi-module build:</para>

      <screen>$ <command>mvn package</command>
[INFO] Reactor build order: 
[INFO]   app-parent &lt;----- PARENT BUILDS FIRST
[INFO]   app-core
[INFO]   app-web
[INFO]   app-addons
[INFO] ---------------------------------------------------------------
[INFO] Building app-parent
[INFO]    task-segment: [package]
[INFO] ---------------------------------------------------------------
[INFO] [site:attach-descriptor]
[INFO] [assembly:single {execution: distro}]
[INFO] Reading assembly descriptor: src/main/assembly/distro.xml
[INFO] ---------------------------------------------------------------
[ERROR] BUILD ERROR
[INFO] ---------------------------------------------------------------
[INFO] Failed to create assembly: Artifact:
org.sonatype.mavenbook.assemblies:app-web:jar:1.0-SNAPSHOT (included by module) 
does not have an artifact with a file. Please ensure the package phase is 
run before the assembly is generated.
...</screen>

      <para>The parent project - <varname>app-parent</varname> - builds first.
      This is because each of the other projects lists that
      <acronym>POM</acronym> as its parent, which causes it to be forced to
      the front of the build order. The <varname>app-web</varname> module,
      which is the first module to be processed in the assembly descriptor,
      hasn’t been built yet. Therefore, it has no artifact associated with it,
      and the assembly cannot succeed.</para>

      <para>One workaround for this is to remove the executions section of the
      Assembly-plugin declaration, that binds the plugin to the
      <varname>package</varname> lifecycle phase in the parent
      <acronym>POM</acronym>, keeping the configuration section intact. Then,
      execute Maven with two command-line tasks: the first,
      <varname>package</varname>, to build the multi-module project graph, and
      a second, <varname>assembly:assembly</varname>, as a direct invocation
      of the assembly plugin to consume the artifacts built on the previous
      run, and create the distribution assembly. The command line for such a
      build might look like this:</para>

      <screen>$ <command>mvn package assembly:assembly</command></screen>

      <para>However, this approach has several drawbacks. First, it makes the
      distribution-assembly process more of a manual task that can increase
      the complexity and potential for error in the overall build process
      significantly. Additionally, it could mean that attached artifacts -
      which are associated in memory as the project build executes - are not
      reachable on the second pass without resorting to file-system
      references.</para>

      <para>Instead of using a <sgmltag>moduleSet</sgmltag> to collect the
      artifacts from your multi-module build, it often makes more sense to
      employ a low-tech approach: using a dedicated distribution project
      module and inter-project dependencies. In this approach, you create a
      new module in your build whose sole purpose is to assemble the
      distribution. This module <acronym>POM</acronym> contains dependency
      references to all the other modules in the project hierarchy, and it
      configures the Assembly plugin to be bound the
      <varname>package</varname> phase of its build lifecycle. The assembly
      descriptor itself uses the <sgmltag>dependencySets</sgmltag> section
      instead of the <sgmltag>moduleSets</sgmltag> section to collect module
      artifacts and determine where to include them in the resulting assembly
      archive. This approach escapes the pitfalls associated with the
      parent-child relationship discussed above, and has the additional
      advantage of using a simpler configuration section within the assembly
      descriptor itself to do the job.</para>

      <para>To do this, we can create a new project structure that’s very
      similar to the one used for the module-set approach above, with the
      addition of a new distribution project, we might end up with five
      <acronym>POM</acronym>s in total: <varname>app-parent</varname>,
      <varname>app-core</varname>, <varname>app-web</varname>,
      <varname>app-addons</varname>, and <varname>app-distribution</varname>.
      The new <varname>app-distribution</varname> <acronym>POM</acronym> looks
      similar to the following:</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;artifactId&gt;app-parent&lt;/artifactId&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;artifactId&gt;app-distribution&lt;/artifactId&gt;
  &lt;name&gt;app-distribution&lt;/name&gt;
  
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;artifactId&gt;app-web&lt;/artifactId&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;war&lt;/type&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;artifactId&gt;app-addons&lt;/artifactId&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- Not necessary since it's brought in via app-web.
    &lt;dependency&gt; [2]
      &lt;artifactId&gt;app-core&lt;/artifactId&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    --&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>

      <para>Notice that we have to include dependencies for the other modules
      in the project structure, since we don’t have a modules section to rely
      on in this <acronym>POM</acronym>. Also, notice that we’re not using an
      explicit dependency on <varname>app-core</varname>. Since it’s also a
      dependency of <varname>app-web</varname>, we don’t need to process it
      (or, avoid processing it) twice.</para>

      <para>Next, when we move the <filename>distro.xml</filename> assembly
      descriptor into the <varname>app-distribution</varname> project, we must
      also change it to use a <sgmltag>dependencySets</sgmltag> section, like
      this:</para>

      <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;includes&gt;
        &lt;include&gt;*-web&lt;/include&gt;
      &lt;/includes&gt;
      &lt;useTransitiveDependencies&gt;false&lt;/useTransitiveDependencies&gt;
      &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
      &lt;unpack&gt;true&lt;/unpack&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;*-web&lt;/exclude&gt;
      &lt;/excludes&gt;
      &lt;useProjectArtifact&gt;false&lt;/useProjectArtifact&gt;
      &lt;outputDirectory&gt;/WEB-INF/lib&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;
</programlisting>

      <para>This time, if we run the build from the top-level project
      directory, we get better news:</para>

      <screen>$ <command>mvn package</command>
(...)
[INFO] ---------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] ---------------------------------------------------------------
[INFO] module-set-distro-parent ...............SUCCESS [3.070s]
[INFO] app-core .............................. SUCCESS [2.970s]
[INFO] app-web ............................... SUCCESS [1.424s]
[INFO] app-addons ............................ SUCCESS [0.543s]
[INFO] app-distribution ...................... SUCCESS [2.603s]
[INFO] ---------------------------------------------------------------
[INFO] ---------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ---------------------------------------------------------------
[INFO] Total time: 10 seconds
[INFO] Finished at: Thu May 01 18:00:09 EDT 2008
[INFO] Final Memory: 16M/29M
[INFO] ---------------------------------------------------------------</screen>

      <para>As you can see, the dependency-set approach is much more stable
      and - at least until Maven’s internal project-sorting logic catches up
      with the Assembly plugin’s capabilities, - involves less opportunity to
      get things wrong when running a build.</para>
    </section>
  </section>

  <section id="assemblies-sect-summary">
    <title>Summary</title>

    <para>As we’ve seen in this chapter, the Maven Assembly plugin offers
    quite a bit of potential for creating custom archive formats. While the
    details of these assembly archives can be complex, they certainly don’t
    have to be in all cases - as we saw with built-in assembly descriptors.
    Even if your aim is to include your project’s dependencies and selected
    project files in some unique, archived directory structure, writing a
    custom assembly descriptor doesn’t have to be an arduous task.</para>

    <para>Assemblies are useful for a wide array of applications, but are most
    commonly used as application distributions of various sorts. And, while
    there are many different ways to use the Assembly plugin, using
    standardized assembly-descriptor artifacts and avoiding
    <sgmltag>moduleSets</sgmltag> when creating distributions containing
    binaries are two sure ways to avoid problems.</para>
  </section>
</chapter>
