<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="assemblies">
  <title>Maven Assemblies</title>

  <section id="assemblies-sect-intro">
    <title>Introduction</title>

    <para>Maven provides plugins that are used to create the most common
    archive types, most of which are consumable as dependencies of other
    projects. Some examples include the <acronym>JAR</acronym>,
    <acronym>WAR</acronym>, <acronym>EJB</acronym>, and <acronym>EAR</acronym>
    plugins. As discussed in <xref linkend="lifecycle" /> these plugins
    correspond to different project packaging types each with a slightly
    different build process. While Maven has plugins and customized lifecycles
    to support standard packaging types, there are times when you'll need to
    create an archive or directory with a custom layout. Such custom archives
    are called Maven Assemblies.</para>

    <para>There are any number of reasons why you may want to build custom
    archives for your project. Perhaps the most common is the project
    distribution. The word ‘distribution’ means many different things to
    different people (and projects), depending on how the project is meant to
    be used. Essentially, these are archives that provide a convenient way for
    users to install or otherwise make use of the project’s releases. In some
    cases, this may mean bundling a web application with an application server
    like Jetty. In others, it could mean bundling API documentation alongside
    source and compiled binaries like jar files. Assemblies usually come in
    handy when you are building the final distribution of a product. For
    example, products like Nexus introduced in <ulink
    url="http://www.sonatype.com/books/nexus-book/reference/">Repository
    Management with Nexus</ulink>, are the product of large multi-module Maven
    products, and the final archive you download from Sonatype was created
    using a Maven Assembly.</para>

    <para>In most cases, the Assembly plugin is ideally suited to the process
    of building project distributions. However, assemblies don’t have to be
    distribution archives; assemblies are intended to provide Maven users with
    the flexibility they need to produce customized archives of all kinds.
    Essentially, assemblies are intended to fill the gaps between the standard
    archive formats provided by project package types. Of course, you could
    write an entire Maven plugin simply to generate your own custom archive
    format, along with a new lifecycle mapping and artifact-handling
    configuration to tell Maven how to deploy it. But the Assembly plugin
    makes this unnecessary in most cases by providing generalized support for
    creating your own archive recipe without spending so much time writing
    Maven code.</para>
  </section>

  <section id="assemblies-sect-basics">
    <title>Assembly Basics</title>

    <para>Before we go any further, it’s best to take a minute and talk about
    the two main goals in the Assembly plugin:
    <varname>assembly:assembly</varname>, and the <varname>single</varname>
    mojo. I list these two goals in different ways because it reflects the
    difference in how they’re used. The <varname>assembly:assembly</varname>
    goal is designed to be invoked directly from the command line, and should
    never be bound to a build lifecycle phase. In contrast, the
    <varname>single</varname> mojo is designed to be a part of your everyday
    build, and should be bound to a phase in your project’s build
    lifecycle.</para>

    <para>The main reason for this difference is that the
    <varname>assembly:assembly</varname> goal is what Maven terms an
    aggregator mojo; that is, a mojo which is designed to run at most once in
    a build, regardless of how many projects are being built. It draws its
    configuration from the root project - usually the top-level
    <acronym>POM</acronym> or the command line. When bound to a lifecycle, an
    aggregator mojo can have some nasty side-effects. It can force the
    execution of the <varname>package</varname> lifecycle phase to execute
    ahead of time, and can result in builds which end up executing the
    <varname>package</varname> phase twice.</para>

    <para>Because the <varname>assembly:assembly</varname> goal is an
    aggregator mojo, it raises some issues in multi-module Maven builds, and
    it should only be called as a stand-alone mojo from the command-line.
    Never bind an <varname>assembly:assembly</varname> execution to a
    lifecycle phase. <varname>assembly:assembly</varname> was the original
    goal in the Assembly plugin, and was never designed to be part of the
    standard build process for a project. As it became clear that assembly
    archives were a legitimate requirement for projects to produce, the
    <varname>single</varname> mojo was developed. This mojo assumes that it
    has been bound to the correct part of the build process, so that it will
    have access to the project files and artifacts it needs to execute within
    the lifecycle of a large multi-module Maven project. In a multi-module
    environment, it will execute as many times as it is bound to the different
    module <acronym>POM</acronym>s. Unlike
    <varname>assembly:assembly</varname>, <varname>single</varname> will never
    force the execution of another lifecycle phase ahead of itself.</para>

    <para>The Assembly plugin provides several other goals in addition to
    these two. However, discussion of these other mojos is beyond the scope of
    this chapter, because they serve exotic or obsolete use cases, and because
    they are almost never needed. Whenever possible, you should definitely
    stick to using <varname>assembly:assembly</varname> for assemblies
    generated from the command line, and to <varname>single</varname> for
    assemblies bound to lifecycle phases.</para>

    <section id="assemblies-sect-predefined">
      <title>Predefined Assembly Descriptors</title>

      <para>While many people opt to create their own archive recipes - called
      assembly descriptors - this isn’t strictly necessary. The Assembly
      plugin provides built-in descriptors for several common archive types
      that you can use immediately without writing a line of configuration.
      The following assembly descriptors are predefined in the Maven Assembly
      plugin:</para>

      <variablelist>
        <varlistentry>
          <term><varname>bin</varname></term>

          <listitem>
            <para>The <varname>bin</varname> descriptor is used to bundle
            project <filename>LICENSE</filename>, <filename>README</filename>,
            and <filename>NOTICE</filename> files with the project’s main
            artifact, assuming this project builds a jar as its main artifact.
            Think of this as the smallest possible binary distribution for
            completely self-contained projects.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>jar-with-dependencies</varname></term>

          <listitem>
            <para>The <varname>jar-with-dependencies</varname> descriptor
            builds a <acronym>JAR</acronym> archive with the contents of the
            main project jar along with the unpacked contents of all the
            project’s runtime dependencies. Coupled with an appropriate
            <varname>Main-Class</varname> Manifest entry (discussed in “Plugin
            Configuration” below), this descriptor can produce a
            self-contained, executable jar for your project, even if the
            project has dependencies.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>project</varname></term>

          <listitem>
            <para>The <varname>project</varname> descriptor simply archives
            the project directory structure as it exists in your file-system
            and, most likely, in your version control system. Of course, the
            target directory is omitted, as are any version-control metadata
            files like the <filename>CVS</filename> and
            <filename>.svn</filename> directories we’re all used to seeing.
            Basically, the point of this descriptor is to create a project
            archive that, when unpacked, can be built using Maven.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>src</varname></term>

          <listitem>
            <para>The <varname>src</varname> descriptor produces an archive of
            your project source and <filename>pom.xml</filename> files, along
            with any <filename>LICENSE</filename>,
            <filename>README</filename>, and <filename>NOTICE</filename> files
            that are in the project’s root directory. This precursor to the
            project descriptor produces an archive that can be built by Maven
            in most cases. However, because of its assumption that all source
            files and resources reside in the standard
            <filename>src</filename> directory, it has the potential to leave
            out non-standard directories and files that are nonetheless
            critical to some builds.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section id="assemblies-sect-building">
      <title>Building an Assembly</title>

      <para>The Assembly plugin can be executed in two ways: you can invoke it
      directly from the command line, or you can configure it as part of your
      standard build process by binding it to a phase of your project’s build
      lifecycle. Direct invocation has its uses, particularly for one-off
      assemblies that are not considered part of your project’s core
      deliverables. In most cases, you’ll probably want to generate the
      assemblies for your project as part of its standard build process. Doing
      this has the effect of including your custom assemblies whenever the
      project is installed or deployed into Maven’s repositories, so they are
      always available to your users.</para>

      <para>As an example of the direct invocation of the Assembly plugin,
      imagine that you wanted to ship off a copy of your project which people
      could build from source. Instead of just deploying the end-product of
      the build, you wanted to include the source as well. You won’t need to
      do this often, so it doesn’t make sense to add the configuration to your
      <sgmltag>POM</sgmltag>. Instead, you can use the following
      command:</para>

      <screen>$ <command>mvn -DdescriptorId=project assembly:single</command> 
...
[INFO] [assembly:single] 
[INFO] Building tar : /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
                      target/direct-invocation-1.0-SNAPSHOT-project.tar.gz 
[INFO] Building tar : /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
                      target/direct-invocation-1.0-SNAPSHOT-project.tar.bz2
[INFO] Building zip: /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
                      target/direct-invocation-1.0-SNAPSHOT-project.zip
...</screen>

      <para>Imagine you want to produce an executable <acronym>JAR</acronym>
      from your project. If your project is totally self-contained with no
      dependencies, this can be achieved with the main project artifact using
      the archive configuration of the <acronym>JAR</acronym> plugin. However,
      most projects have dependencies, and those dependencies must be
      incorporated in any executable <acronym>JAR</acronym>. In this case, you
      want to make sure that every time the main project
      <acronym>JAR</acronym> is installed or deployed, your executable
      <acronym>JAR</acronym> goes along with it.</para>

      <para>Assuming the main class for the project is
      <classname>org.sonatype.mavenbook.App</classname>, the following
      <acronym>POM</acronym> configuration will create an executable
      <acronym>JAR</acronym>:</para>

      <example>
        <title>Assembly Descriptor for Executable JAR</title>

        <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;

  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
  &lt;artifactId&gt;executable-jar&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;name&gt;Assemblies Executable Jar Example&lt;/name&gt;
  &lt;url&gt;http://sonatype.com/book&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;commons-lang&lt;/groupId&gt;
      &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;
      &lt;version&gt;2.4&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
 &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2-beta-2&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;create-executable-jar&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;descriptorRefs&gt;
                &lt;descriptorRef&gt;
                  jar-with-dependencies
                &lt;/descriptorRef&gt;
              &lt;/descriptorRefs&gt;
              &lt;archive&gt;
                &lt;manifest&gt;
                  &lt;mainClass&gt;org.sonatype.mavenbook.App&lt;/mainClass&gt;
                &lt;/manifest&gt;
              &lt;/archive&gt;
           &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>There are two things to notice about the configuration above.
      First, we’re using the <sgmltag>descriptorRefs</sgmltag> configuration
      section instead of the <sgmltag>descriptorId</sgmltag> parameter we used
      last time. This allows multiple assembly types to be built from the same
      Assembly plugin execution, while still supporting our use case with
      relatively little extra configuration. Second, the
      <sgmltag>archive</sgmltag> element under
      <sgmltag>configuration</sgmltag> sets the <varname>Main-Class</varname>
      manifest attribute in the generated <acronym>JAR</acronym>. This section
      is commonly available in plugins that create <acronym>JAR</acronym>
      files, such as the <acronym>JAR</acronym> plugin used for the default
      project package type.</para>

      <para>Now, you can produce the executable <acronym>JAR</acronym> simply
      by executing <command>mvn package</command>. Afterward, we’ll also get a
      directory listing for the target directory, just to verify that the
      executable <acronym>JAR</acronym> was generated. Finally, just to prove
      that we actually do have an executable <acronym>JAR</acronym>, we’ll try
      executing it:</para>

      <screen>$ <command>mvn package</command>
... (output omitted) ...
[INFO] [jar:jar]
[INFO] Building jar: ~/mvn-examples-1.0/assemblies/executable-jar/target/\
                     executable-jar-1.0-SNAPSHOT.jar
[INFO] [assembly:single {execution: create-executable-jar}]
[INFO] Processing DependencySet (output=)
[INFO] Building jar: ~/mvn-examples-1.0/assemblies/executable-jar/target/\
                     executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar
... (output omitted) ...
$ <command>ls -1 target</command>
... (output omitted) ...
executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar
executable-jar-1.0-SNAPSHOT.jar
... (output omitted) ...
$ <command>java -jar \
        target/executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar </command>
Hello, World!</screen>

      <para>From the output shown above, you can see that the normal project
      build now produces a new artifact in addition to the main
      <acronym>JAR</acronym> file. The new one has a classifier of
      <varname>jar-with-dependencies</varname>. Finally, we verified that the
      new <acronym>JAR</acronym> actually is executable, and that executing
      the <acronym>JAR</acronym> produced the desired output of “Hello,
      World!”</para>
    </section>

    <section id="assemblies-sect-as-depend">
      <title>Assemblies as Dependencies</title>

      <para>When you generate assemblies as part of your normal build process,
      those assembly archives will be attached to your main project’s
      artifact. This means they will be installed and deployed alongside the
      main artifact, and are then resolvable in much the same way. Each
      assembly artifact is given the same basic coordinate
      (<varname>groupId</varname>, <varname>artifactId</varname>, and
      <varname>version</varname>) as the main project. However, these
      artifacts are attachments, which in Maven means they are derivative
      works based on some aspect of the main project build. To provide a
      couple of examples, <varname>source</varname> assemblies contain the raw
      inputs for the project build, and
      <varname>jar-with-dependencies</varname> assemblies contain the
      project’s classes plus its dependencies. Attached artifacts are allowed
      to circumvent the Maven requirement of one project, one artifact
      precisely because of this derivative quality.</para>

      <para>Since assemblies are (normally) attached artifacts, each must have
      a classifier to distinguish it from the main artifact, in addition to
      the normal artifact coordinate. By default, the classifier is the same
      as the assembly descriptor’s identifier. When using the built-in
      assembly descriptors, as above, the assembly descriptor’s identifier is
      generally also the same as the identifier used in the
      <sgmltag>descriptorRef</sgmltag> for that type of assembly.</para>

      <para>Once you’ve deployed an assembly alongside your main project
      artifact, how can you use that assembly as a dependency in another
      project? The answer is fairly straightforward. Recall the discussions in
      <xref linkend="simple-project-sect-maven-coordinates" /> and <xref
      linkend="pom-relationships-sect-more-coordinates" /> about project
      dependencies in Maven, projects depend on other projects using a
      combination of four basic elements, referred to as a project’s
      coordinates: <varname>groupId</varname>, <varname>artifactId</varname>,
      <varname>version</varname>, and <varname>packaging</varname>. In <xref
      linkend="profiles-sect-platform-classifier" />, multiple
      platform-specific variants of a project’s artifact and available, and
      the project specifies a <varname>classifier</varname> element with a
      value of either <varname>win</varname> or <varname>linux</varname> to
      select the appropriate dependency artifact for the target platform.
      Assembly artifacts can be used as dependencies using the required
      coordinates of a project plus the classifier under which the assembly
      was installed or deployed. If the assembly is not a
      <acronym>JAR</acronym> archive, we also need to declare its type.</para>
    </section>

    <section id="assemblies-sect-assembling-via-depend">
      <title>Assembling Assemblies via Assembly Dependencies</title>

      <para>How's that for a confusing section title? Let's try to set up a
      scenario which would explain the idea of assembling assemblies. Imagine
      you want to create an archive which itself contains some project
      assemblies. Assume that you have a multi-module build and you want to
      deploy an assembly which contains a set of related project assemblies.
      In this section's example, we create a bundle of "buildable" project
      directories for a set of projects that are commonly used together. For
      simplicity, we’ll reuse the two built-in assembly descriptors discussed
      above - <varname>project</varname> and
      <varname>jar-with-dependencies</varname>. In this particular example, it
      is assumed that each project creates the <varname>project</varname>
      assembly in addition to its main <acronym>JAR</acronym> artifact. Assume
      that every project in a multi-module build binds the
      <varname>single</varname> goal to the <varname>package</varname> phase
      and uses the <varname>project</varname>
      <sgmltag>descriptorRef</sgmltag>. Every project in a multi-module will
      inherit the configuration from a top-level <filename>pom.xml</filename>
      whose <sgmltag>pluginManagement</sgmltag> element is shown in <xref
      linkend="ex-top-pom-assembly" />.</para>

      <example id="ex-top-pom-assembly">
        <title>Configuring the project assembly in top-level POM</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;pluginManagement&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.2-beta-2&lt;/version&gt;
          &lt;executions&gt;
            &lt;execution&gt;
              &lt;id&gt;create-project-bundle&lt;/id&gt;
              &lt;phase&gt;package&lt;/phase&gt;
              &lt;goals&gt;
                &lt;goal&gt;single&lt;/goal&gt;
              &lt;/goals&gt;
              &lt;configuration&gt;
                &lt;descriptorRefs&gt;
                  &lt;descriptorRef&gt;project&lt;/descriptorRef&gt;
                &lt;/descriptorRefs&gt;
              &lt;/configuration&gt;
            &lt;/execution&gt;
          &lt;/executions&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
  &lt;/build&gt;
  ...
&lt;/project&gt;</programlisting>
      </example>

      <para>Each project <acronym>POM</acronym> references the managed plugin
      configuration from <xref linkend="ex-top-pom-assembly" /> using a
      minimal plugin declaration in its build section shown in <xref
      linkend="ex-activating-assembly" />.</para>

      <example id="ex-activating-assembly">
        <title>Activating the Assembly Plugin Configuration in Child
        Projects</title>

        <programlisting language="xml">&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;
</programlisting>
      </example>

      <para>To produce the set of project assemblies, run <command>mvn
      install</command> from the top-level directory. You should see Maven
      installing artifacts with classifiers in your local repository.</para>

      <screen>$ <command>mvn install</command>
...
Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
           second-project/target/second-project-1.0-SNAPSHOT-project.tar.gz to 
  ~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\
           second-project-1.0-SNAPSHOT-project.tar.gz
...
Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
           second-project/target/second-project-1.0-SNAPSHOT-project.tar.bz2 to 
  ~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\
           second-project-1.0-SNAPSHOT-project.tar.bz2
...
Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
           second-project/target/second-project-1.0-SNAPSHOT-project.zip to 
  ~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\\
           second-project-1.0-SNAPSHOT-project.zip
...</screen>

      <para>When you run install, Maven will copy the each project's main
      artifact and each assembly to your local Maven repository. All of these
      artifacts are now available for reference as dependencies in other
      projects locally. If your ultimate goal is to create a bundle which
      includes assemblies from multiple project, you can do so by creating
      another project which will include other project's assemblies as
      dependencies. This bundling project (aptly named project-bundle) is
      responsible for creating the bundled assembly. The
      <acronym>POM</acronym> for the bundling project would resemble the XML
      document listed in <xref linkend="ex-bundling-pom" />.</para>

      <example id="ex-bundling-pom">
        <title>POM for the Assembly Bundling Project</title>

        <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
  &lt;artifactId&gt;project-bundle&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;name&gt;Assemblies-as-Dependencies Example Project Bundle&lt;/name&gt;
  &lt;url&gt;http://sonatype.com/book&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;artifactId&gt;first-project&lt;/artifactId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;classifier&gt;project&lt;/classifier&gt;
      &lt;type&gt;zip&lt;/type&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;artifactId&gt;second-project&lt;/artifactId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;classifier&gt;project&lt;/classifier&gt;
      &lt;type&gt;zip&lt;/type&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2-beta-2&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;bundle-project-sources&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;descriptorRefs&gt;
                &lt;descriptorRef&gt;
                  jar-with-dependencies
                &lt;/descriptorRef&gt;
              &lt;/descriptorRefs&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</programlisting>
      </example>

      <para>This bundling project's <acronym>POM</acronym> references the two
      assemblies from <varname>first-project</varname> and
      <varname>second-project</varname>. Instead of referencing the main
      artifact of each project, the bundling project's <acronym>POM</acronym>
      specifies a classifier of <varname>project</varname> and a type of
      <varname>zip</varname>. This tells Maven to resolve the
      <acronym>ZIP</acronym> archive which was created by the
      <varname>project</varname> assembly. Note that the bundling project
      generates a <varname>jar-with-dependencies</varname> assembly.
      <varname>jar-with-dependencies</varname> does not create a particularly
      elegant bundle, it simply creates a <acronym>JAR</acronym> file with the
      unpacked contents of all of the dependencies.
      <varname>jar-with-dependencies</varname> is really just telling Maven to
      take all of the dependencies, unpack them, and then create a single
      archive which includes the output of the current project. In this
      project, it has the effect of creating a single <acronym>JAR</acronym>
      file that puts the two project assemblies from
      <varname>first-project</varname> and <varname>second-project</varname>
      side-by-side.</para>

      <para>This example illustrates how the basic capabilities of the Maven
      Assembly plugin can be combined without the need for a custom assembly
      descriptor. It achieves the purpose of creating a single archive that
      contains the project directories for multiple projects side-by-side.
      This time, the <varname>jar-with-dependencies</varname> is just a
      storage format, so we don’t need to specify a
      <varname>Main-Class</varname> manifest attribute. To build the bundle,
      we just build the <varname>project-bundle</varname> project
      normally:</para>

      <screen>$ <command>mvn package</command>
...
[INFO] [assembly:single {execution: bundle-project-sources}]
[INFO] Processing DependencySet (output=)
[INFO] Building jar: ~/downloads/mvn-examples-1.0/assemblies/as-dependencies/\
  project-bundle/target/project-bundle-1.0-SNAPSHOT-jar-with-dependencies.jar
</screen>

      <para>To verify that the project-bundle assembly contains the unpacked
      contents of the assembly dependencies, run <command>jar
      tf</command>:</para>

      <screen>$ <command>jar tf \
  target/project-bundle-1.0-SNAPSHOT-jar-with-dependencies.jar</command>
...
first-project-1.0-SNAPSHOT/pom.xml
first-project-1.0-SNAPSHOT/src/main/java/org/sonatype/mavenbook/App.java
first-project-1.0-SNAPSHOT/src/test/java/org/sonatype/mavenbook/AppTest.java
...
second-project-1.0-SNAPSHOT/pom.xml
second-project-1.0-SNAPSHOT/src/main/java/org/sonatype/mavenbook/App.java
second-project-1.0-SNAPSHOT/src/test/java/org/sonatype/mavenbook/AppTest.java</screen>

      <para>After reading this section, the title should make more sense.
      You've assembled assemblies from two projects into an assembly using a
      bundling project which has a dependency on each of the
      assemblies.</para>
    </section>
  </section>

  <section id="assemblies-sect-overview-descriptor">
    <title>Overview of the Assembly Descriptor</title>

    <para>When the standard assembly descriptors introduced in <xref
    linkend="assemblies-sect-basics" /> are not adequate, you will need to
    define your own assembly descriptor. The assembly descriptor is an XML
    document which defines the structure and contents of an assembly. The
    assembly descriptor contains five main configuration sections, plus two
    additional sections: one for specifying standard assembly-descriptor
    fragments, called component descriptors, and another for specifying custom
    file processor classes to help manage the assembly-production
    process.</para>

    <variablelist>
      <varlistentry>
        <term>Base Configuration</term>

        <listitem>
          <para>This section contains the information required by all
          assemblies, plus some additional configuration options related to
          the format of the entire archive, such as the base path to use for
          all archive entries. For the assembly descriptor to be valid, you
          must at least specify the assembly id, at least one format, and at
          least one of the other sections shown above.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>File Information</term>

        <listitem>
          <para>The configurations in this segment of the assembly descriptor
          apply to specific files on the file system within the project’s
          directory structure. This segment contains two main sections:
          <sgmltag>files</sgmltag> and <sgmltag>fileSets</sgmltag>. You use
          <sgmltag>files</sgmltag> and <sgmltag>fileSets</sgmltag> to control
          the permissions of files in an assembly and to include or exclude
          files from an assembly.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Dependency Information</term>

        <listitem>
          <para>Almost all projects of any size depend on other projects. When
          creating distribution archives, project dependencies are usually
          included in the end-product of an assembly. This section manages the
          way dependencies are included in the resulting archive. This section
          allows you to specify whether dependencies are unpacked, added
          directly to the <filename>lib/</filename> directory, or mapped to
          new file names. This section also allows you to control the
          permissions of dependencies in the assembly, and which dependencies
          are included in an assembly.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Repository Information</term>

        <listitem>
          <para>At times, it’s useful to isolate the sum total of all
          artifacts necessary to build a project, whether they’re dependency
          artifacts, <acronym>POM</acronym>s of dependency artifacts, or even
          a project’s own POM ancestry (your parent <acronym>POM</acronym>,
          its parent, and so on). This section allows you to include one or
          more artifact-repository directory structures inside your assembly,
          with various configuration options. The Assembly plugin does not
          have the ability to include plugin artifacts in these repositories
          yet.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Module Information</term>

        <listitem>
          <para>This section of the assembly descriptor allows you to take
          advantage of these parent-child relationships when assembling your
          custom archive, to include source files, artifacts, and dependencies
          from your project’s modules. This is the most complex section of the
          assembly descriptor, because it allows you to work with modules and
          sub-modules in two ways: as a series of <sgmltag>fileSets</sgmltag>
          (via the <sgmltag>sources</sgmltag> section) or as a series of
          <sgmltag>dependencySets</sgmltag> (via the
          <sgmltag>binaries</sgmltag> section).</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>

  <section id="assemblies-sect-descriptor">
    <title>The Assembly Descriptor</title>

    <para>This section is a tour of the assembly descriptor which contains
    some guidelines for developing a custom assembly descriptor. The Assembly
    plugin is one of the largest plugins in the Maven ensemble, and one of the
    most flexible.</para>

    <section id="assemblies-sect-prop-refs">
      <title>Property References in Assembly Descriptors</title>

      <para>Any property discussed in <xref
      linkend="resource-filtering-sect-properties" /> can be referenced in an
      assembly descriptor. Before any assembly descriptor is used by Maven, it
      is interpolated using information from the <acronym>POM</acronym> and
      the current build environment. All properties supported for
      interpolation within the <acronym>POM</acronym> itself are valid for use
      in assembly descriptors, including <acronym>POM</acronym> properties,
      <acronym>POM</acronym> element values, system properties, user-defined
      properties, and operating-system environment variables.</para>

      <para>The only exceptions to this interpolation step are elements in
      various sections of the descriptor named
      <sgmltag>outputDirectory</sgmltag>,
      <sgmltag>outputDirectoryMapping</sgmltag>, or
      <sgmltag>outputFileNameMapping</sgmltag>. The reason these are held back
      in their raw form is to allow artifact- or module-specific information
      to be applied when resolving expressions in these values, on a per-item
      basis.</para>

      <!--This last paragraph is not clear.-->
    </section>

    <section id="assemblies-sect-required">
      <title>Required Assembly Information</title>

      <para>There are two essential pieces of information that are required
      for every assembly: the <sgmltag>id</sgmltag>, and the list of archive
      formats to produce. In practice, at least one other section of the
      descriptor is required - since most archive format components will choke
      if they don’t have at least one file to include - but without at least
      one <sgmltag>format</sgmltag> and an <sgmltag>id</sgmltag>, there is no
      archive to create. The <sgmltag>id</sgmltag> is used both in the
      archive’s file name, and as part of the archive’s artifact classifier in
      the Maven repository. The format string also controls the
      archiver-component instance that will create the final assembly archive.
      All assembly descriptors must contain an <sgmltag>id</sgmltag> and at
      least one <sgmltag>format</sgmltag>:</para>

      <example id="ex-required-assembly">
        <title>Required Assembly Descriptor Elements</title>

        <programlisting language="xml">&lt;assembly&gt;
  &lt;id&gt;bundle&lt;/id&gt; 
  &lt;formats&gt;
    &lt;format&gt;zip&lt;/format&gt;
  &lt;/formats&gt;
  ...
&lt;/assembly&gt;</programlisting>
      </example>

      <para>The assembly <sgmltag>id</sgmltag> can be any string that does not
      contain spaces. The standard practice is to use dashes when you must
      separate words within the assembly <sgmltag>id</sgmltag>. If you were
      creating an assembly to create an interesting unique package structure,
      you would give your an <varname>id</varname> of something like
      <varname>interesting-unique-package</varname>. It also supports multiple
      formats within a single assembly descriptor, allowing you to create the
      familiar <filename>.zip</filename>, <filename>.tar.gz</filename>, and
      <filename>.tar.bz2</filename> distribution archive set with ease. If you
      don't find the archive format you need, you can also create a custom
      format. Custom formats are discussed in <xref
      linkend="assemblies-sect-componentDescriptors" />. The Assembly plugin
      supports several archive formats natively, including:</para>

      <itemizedlist>
        <listitem>
          <para><varname>jar</varname></para>
        </listitem>

        <listitem>
          <para><varname>zip</varname></para>
        </listitem>

        <listitem>
          <para><varname>tar</varname></para>
        </listitem>

        <listitem>
          <para><varname>bzip2</varname></para>
        </listitem>

        <listitem>
          <para><varname>gzip</varname></para>
        </listitem>

        <listitem>
          <para><varname>tar.gz</varname></para>
        </listitem>

        <listitem>
          <para><varname>tar.bz2</varname></para>
        </listitem>

        <listitem>
          <para><varname>rar</varname></para>
        </listitem>

        <listitem>
          <para><varname>war</varname></para>
        </listitem>

        <listitem>
          <para><varname>ear</varname></para>
        </listitem>

        <listitem>
          <para><varname>sar</varname></para>
        </listitem>

        <listitem>
          <para><varname>dir</varname></para>
        </listitem>
      </itemizedlist>

      <para>The <varname>id</varname> and <varname>format</varname> are
      essential because they will become a part of the coordinates for the
      assembled archive. The example from <xref
      linkend="ex-required-assembly" /> will create an assembly artifact of
      type <varname>zip</varname> with a classifier of
      <varname>bundle</varname>.</para>
    </section>
  </section>

  <section id="assemblies-sect-controlling-contents">
    <title>Controlling the Contents of an Assembly</title>

    <para>In theory, <varname>id</varname> and <varname>format</varname> are
    the only absolute requirements for a valid assembly descriptor; however,
    many assembly archivers will fail if they do not have at least one file to
    include in the output archive. The task of defining the files to be
    included in the assembly is handled by the five main sections of the
    assembly descriptor: <sgmltag>files</sgmltag>,
    <sgmltag>fileSets</sgmltag>, <sgmltag>dependencySets</sgmltag>,
    <sgmltag>repositories</sgmltag>, and <sgmltag>moduleSets</sgmltag>. To
    explore these sections most effectively, we’ll start by discussing the
    most elemental section: <sgmltag>files</sgmltag>. Then, we’ll move on to
    the two most commonly used sections, <sgmltag>fileSets</sgmltag> and
    <sgmltag>dependencySets</sgmltag>. Once you understand the workings of
    <sgmltag>fileSets</sgmltag> and <sgmltag>dependencySets</sgmltag>, it’s
    easier to understand <sgmltag>repositories</sgmltag> and
    <sgmltag>moduleSets</sgmltag>.</para>

    <section id="assemblies-sect-files">
      <title><sgmltag>Files</sgmltag> Section</title>

      <para>The <sgmltag>files</sgmltag> section is the simplest part of the
      assembly descriptor, it is designed for files that have a definite
      location relative to your project’s directory. Using this section, you
      have absolute control over the exact set of files that are included in
      your assembly, exactly what they are named, and where they will reside
      in the archive.</para>

      <example id="ex-assembly-files">
        <title>Including a <acronym>JAR</acronym> file in an Assembly using
        <sgmltag>files</sgmltag></title>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;files&gt;
    &lt;file&gt;
      &lt;source&gt;target/my-app-1.0.jar&lt;/source&gt;
      &lt;outputDirectory&gt;lib&lt;/outputDirectory&gt;
      &lt;destName&gt;my-app.jar&lt;/destName&gt;
      &lt;fileMode&gt;0644&lt;/fileMode&gt;
    &lt;/file&gt;
  &lt;/files&gt;
  ...
&lt;/assembly&gt;</programlisting>
      </example>

      <para>Assuming you were building a project called
      <varname>my-app</varname> with a version of <varname>1.0</varname>,
      <xref linkend="ex-assembly-files" /> would include your project's
      <acronym>JAR</acronym> in the assembly’s <filename>lib/</filename>
      directory, trimming the version from the file name in the process so the
      final file name is simply <filename>my-app.jar</filename>. It would then
      make the <acronym>JAR</acronym> readable by everyone and writable by the
      user that owns it (this is what the mode 0644 means for files, using
      Unix four-digit Octal permission notation). For more information about
      the format of the value in <sgmltag>fileMode</sgmltag>, please see the
      Wikipedia's explanation of <ulink
      url="http://en.wikipedia.org/wiki/File_system_permissions#Octal_notation_and_additional_permissions">four-digit
      Octal notation</ulink>.</para>

      <para>You could build a very complex assembly using file entries, if you
      knew the full list of files to be included. Even if you didn’t know the
      full list before the build started, you could probably use a custom
      Maven plugin to discover that list and generate the assembly descriptor
      using references like the one above. While the files section gives you
      fine-grained control over the permission, location, and name of each
      file in the assembly archive, listing a <sgmltag>file</sgmltag> element
      for every file in a large archive would be a tedious exercise. For the
      most part, you will be operating on groups of files and dependencies
      using <sgmltag>fileSets</sgmltag>. The remaining four file-inclusion
      sections are designed to help you include entire sets of files that
      match a particular criteria.</para>
    </section>

    <section id="assemblies-sect-filesets">
      <title><sgmltag>FileSets</sgmltag> Section</title>

      <para>Similar to the <sgmltag>files</sgmltag> section,
      <sgmltag>fileSets</sgmltag> are intended for files that have a definite
      location relative to your project’s directory structure. However, unlike
      the <sgmltag>files</sgmltag> section, <sgmltag>fileSets</sgmltag>
      describe sets of files, defined by file and path patterns they match (or
      don’t match), and the general directory structure in which they are
      located. The simplest <sgmltag>fileSet</sgmltag> just specifies the
      directory where the files are located:</para>

      <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;fileSets&gt;
    &lt;fileSet&gt;
      &lt;directory&gt;src/main/java&lt;/directory&gt;
    &lt;/fileSet&gt;
  &lt;/fileSets&gt;
  ...
&lt;/assembly&gt;</programlisting>

      <para>This file set simply includes the contents of the
      <filename>src/main/java</filename> directory from our project. It takes
      advantage of many default settings in the section, so let’s discuss
      those briefly.</para>

      <para>First, you’ll notice that we haven’t told the file set where
      within the assembly matching files should be located. By default, the
      destination directory (specified with
      <sgmltag>outputDirectory</sgmltag>) is the same as the source directory
      (in our case, <filename>src/main/java</filename>). Additionally, we
      haven’t specified any inclusion or exclusion file patterns. When these
      are empty, the file set assumes that all files within the source
      directory are included, with some important exceptions. The exceptions
      to this rule pertain mainly to source-control metadata files and
      directories, and are controlled by the
      <sgmltag>useDefaultExcludes</sgmltag> flag, which is defaulted to
      <sgmltag>true</sgmltag>. When active,
      <sgmltag>useDefaultExcludes</sgmltag> will keep directories like
      <filename>.svn/</filename> and <filename>CVS/</filename> from being
      added to the assembly archive. <xref
      linkend="assemblies-sect-default-excludes" /> provides a detailed list
      of the default exclusion patterns.</para>

      <para>If we want more control over this file set, we can specify it more
      explicitly. <xref linkend="ex-explicit-fileSet" /> shows a
      <sgmltag>fileSet</sgmltag> element with all of the default elements
      specified.</para>

      <example id="ex-explicit-fileSet">
        <title>Including Files with <sgmltag>fileSet</sgmltag></title>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;fileSets&gt;
    &lt;fileSet&gt;
      &lt;directory&gt;src/main/java&lt;/directory&gt;
      &lt;outputDirectory&gt;src/main/java&lt;/outputDirectory&gt;
      &lt;includes&gt;
        &lt;include&gt;**&lt;/include&gt;
      &lt;/includes&gt;
      &lt;useDefaultExcludes&gt;true&lt;/useDefaultExcludes&gt;
      &lt;fileMode&gt;0644&lt;/fileMode&gt;
      &lt;directoryMode&gt;0755&lt;/directoryMode&gt;
    &lt;/fileSet&gt;
  &lt;/fileSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
      </example>

      <para>The <sgmltag>includes</sgmltag> section uses a list of
      <sgmltag>include</sgmltag> elements, which contain path patterns. These
      patterns may contain wildcards such as ‘**’ which matches one or more
      directories or ‘*’ which matches part of a file name, and ‘?’ which
      matches a single character in a file name. <xref
      linkend="ex-explicit-fileSet" /> uses a <sgmltag>fileMode</sgmltag>
      entry to specify that files in this set should be readable by all, but
      only writable by the owner. Since the <sgmltag>fileSet</sgmltag>
      includes directories, we also have the option of specifying a
      <sgmltag>directoryMode</sgmltag> that works in much the same way as the
      <sgmltag>fileMode</sgmltag>. Since a directories’ execute permission is
      what allows users to list their contents, we want to make sure
      directories are executable in addition to being readable. Like files,
      only the owner can write to directories in this set.</para>

      <para>The <sgmltag>fileSet</sgmltag> entry offers some other options as
      well. First, it allows for an <sgmltag>excludes</sgmltag> section with a
      form identical to the <sgmltag>includes</sgmltag> section. These
      exclusion patterns allow you to exclude specific file patterns from a
      <sgmltag>fileSet</sgmltag>. Include patterns take precedence over
      exclude patterns. Additionally, you can set the
      <sgmltag>filtering</sgmltag> flag to true if you want to substitute
      property values for expressions within the included files. Expressions
      can be delimited either by <varname>\${</varname> and
      <varname>}</varname> (standard Maven expressions like
      <varname>\${project.groupId}</varname>) or by <varname>@</varname> and
      <varname>@</varname> (standard Ant expressions like
      <varname>@project.groupId@</varname>). You can adjust the line ending of
      your files using the <sgmltag>lineEnding</sgmltag> element; valid values
      for <sgmltag>lineEnding</sgmltag> are:</para>

      <variablelist>
        <varlistentry>
          <term>keep</term>

          <listitem>
            <para>Preserve line endings from original files. (This is the
            default value.)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>unix</term>

          <listitem>
            <para>Unix-style line endings</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>lf</term>

          <listitem>
            <para>Only a Line Feed Character</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>dos</term>

          <listitem>
            <para>MS-DOS-style line endings</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>crlf</term>

          <listitem>
            <para>Carriage-return followed by a Line Feed</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Finally, if you want to ensure that all file-matching patterns are
      used, you can use the <sgmltag>useStrictFiltering</sgmltag> element with
      a value of <sgmltag>true</sgmltag> (the default is
      <sgmltag>false</sgmltag>). This can be especially useful if unused
      patterns may signal missing files in an intermediary output directory.
      When <sgmltag>useStrictFiltering</sgmltag> is set to
      <sgmltag>true</sgmltag>, the Assembly plugin will fail if an include
      pattern is not satisfied. In other words, if you have an include pattern
      which includes a file from a build, and that file is not present,
      setting <sgmltag>useStrictFiltering</sgmltag> to <sgmltag>true</sgmltag>
      will cause a failure if Maven cannot find the file to be
      included.</para>

      <!--TODO: JCasey, I had to take the statement about Ant Expressions out because I couldn't verify it.
I can add this back in later.  I didn't want to talk about it without an example.  - TIM-->
    </section>

    <section id="assemblies-sect-default-excludes">
      <title>Default Exclusion Patterns for
      <sgmltag>fileSets</sgmltag></title>

      <para>When you use the default exclusion patterns, the Maven Assembly
      plugin is going to be ignoring more than just <acronym>SVN</acronym> and
      <acronym>CVS</acronym> information. By default the exclusion patterns
      are defined by the <ulink
      url="http://svn.codehaus.org/plexus/plexus-utils/trunk/src/main/java/org/codehaus/plexus/util/DirectoryScanner.java">DirectoryScanner</ulink>
      class in the <ulink
      url="http://plexus.codehaus.org/plexus-utils/">plexus-utils</ulink>
      project hosted at Codehaus. The array of exclude patterns is defined as
      a static, final <classname>String</classname> array named
      <varname>DEFAULTEXCLUDES</varname> in
      <classname>DirectoryScanner</classname>. The contents of this variable
      are shown in <xref linkend="ex-default-excludes" />.</para>

      <example id="ex-default-excludes">
        <title>Definition of Default Exclusion Patterns from Plexus
        Utils</title>

        <programlisting language="java">   public static final String[] DEFAULTEXCLUDES = {
        // Miscellaneous typical temporary files
        "**/*~",
        "**/#*#",
        "**/.#*",
        "**/%*%",
        "**/._*",

        // CVS
        "**/CVS",
        "**/CVS/**",
        "**/.cvsignore",

        // SCCS
        "**/SCCS",
        "**/SCCS/**",

        // Visual SourceSafe
        "**/vssver.scc",

        // Subversion
        "**/.svn",
        "**/.svn/**",

        // Arch
        "**/.arch-ids",
        "**/.arch-ids/**",

        //Bazaar
        "**/.bzr",
        "**/.bzr/**",

        //SurroundSCM
        "**/.MySCMServerInfo",

        // Mac
        "**/.DS_Store"
    };</programlisting>
      </example>

      <para>This default array of patterns excludes temporary files from
      editors like <ulink url="http://www.gnu.org/software/emacs/">GNU
      Emacs</ulink>, and other common temporary files from Macs and a few
      common source control systems (although Visual SourceSafe is more of a
      curse than a source control system). If you need to override these
      default exclusion patterns you set <sgmltag>useDefaultExcludes</sgmltag>
      to false and then define a set of exclusion patterns in your own
      assembly descriptor.</para>
    </section>

    <section id="assemblies-sect-output-algorithm">
      <title><sgmltag>dependencySets</sgmltag> Section</title>

      <para>One of the most common requirements for assemblies is the
      inclusion of a project’s dependencies in an assembly archive. Where
      <sgmltag>files</sgmltag> and <sgmltag>fileSets</sgmltag> deal with files
      in your project, dependency files don't have a location in your project.
      The artifacts your project depends on have to be resolved by Maven
      during the build. Dependency artifacts are abstract, they lack a
      definite location, and are resolved using a symbolic set of Maven
      coordinates. Since <sgmltag>file</sgmltag> and
      <sgmltag>fileSet</sgmltag> specifications require a concrete source
      path, dependencies are included or excluded from an assembly using a
      combination of Maven coordinates and dependency scopes.</para>

      <para>The simplest <sgmltag>dependencySet</sgmltag> is an empty
      element:</para>

      <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet/&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>

      <para>The <sgmltag>dependencySet</sgmltag> above will match all runtime
      dependencies of your project (runtime scope includes the compile scope
      implicitly), and it will add these dependencies to the root directory of
      your assembly archive. It will also copy the current project’s main
      artifact into the root of the assembly archive, if it exists.</para>

      <note>
        <para>Wait? I thought <sgmltag>dependencySet</sgmltag> was about
        including my project's dependencies, not my project's main archive?
        This counterintuitive side-effect was a widely-used bug in the 2.1
        version of the Assembly plugin, and, because Maven puts an emphasis on
        backward compatibility, this counterintuitive and incorrect behavior
        needed to be preserved between a 2.1 and 2.2 release. You can control
        this behavior by changing the <sgmltag>useProjectArtifact</sgmltag>
        flag to <varname>false</varname>.</para>
      </note>

      <para>While the default dependency set can be quite useful with no
      configuration whatsoever, this section of the assembly descriptor also
      supports a wide array of configuration options, allowing your to tailor
      its behavior to your specific requirements. For example, the first thing
      you might do to the dependency set above is exclude the current project
      artifact, by setting the <sgmltag>useProjectArtifact</sgmltag> flag to
      <varname>false</varname> (again, its default value is
      <varname>true</varname> for legacy reasons). This will allow you to
      manage the current project’s build output separately from its dependency
      files. Alternatively, you might choose to unpack the dependency
      artifacts using by setting the <sgmltag>unpack</sgmltag> flag to
      <varname>true</varname> (this is <varname>false</varname> by default).
      When unpack is set to true, the Assembly plugin will combine the
      unpacked contents of all matching dependencies inside the archive’s root
      directory.</para>

      <para>From this point, there are several things you might choose to do
      with this dependency set. The next sections discuss how to define the
      output location for dependency sets and how include and exclude
      dependencies by scope. Finally, we’ll expand on the unpacking
      functionality of the dependency set by exploring some advanced options
      for unpacking dependencies.</para>

      <section id="assemblies-sect-output-location">
        <title>Customizing Dependency Output Location</title>

        <para>There are two configuration options that are used in concert to
        define the location for a dependency file within the assembly archive:
        <sgmltag>outputDirectory</sgmltag> and
        <sgmltag>outputFileNameMapping</sgmltag>. You may want to customize
        the location of dependencies in your assembly using properties of the
        dependency artifacts themselves. Let's say you want to put all the
        dependencies in directories that match the dependency artifact's
        <sgmltag>groupId</sgmltag>. In this case, you would use the
        <sgmltag>outputDirectory</sgmltag> element of the
        <sgmltag>dependencySet</sgmltag>, and you would supply something
        like:</para>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;outputDirectory&gt;\${artifact.groupId}&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>

        <para>This would have the effect of placing every single dependency in
        a subdirectory that matched the name of each dependency artifact's
        <sgmltag>groupId</sgmltag>.</para>

        <para>If you wanted to perform a further customization and remove the
        version numbers from all dependencies. You could customize the the
        output file name for each dependency using the
        <sgmltag>outputFileNameMapping</sgmltag> element as follows:</para>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;outputDirectory&gt;\${artifact.groupId}&lt;/outputDirectory&gt;
      &lt;outputFileNameMapping&gt;
        \${artifact.artifactId}.\${artifact.extension} 
      &lt;/outputFileNameMapping&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>

        <para>In the previous example, a dependency on
        <varname>commons:commons-codec</varname> version 1.3, would end up in
        the file <filename>commons/commons-codec.jar</filename>.</para>
      </section>

      <section id="assemblies-sect-interpolate">
        <title>Interpolation of Properties in Dependency Output
        Location</title>

        <para>As mentioned in the Assembly Interpolation section above,
        neither of these elements are interpolated with the rest of the
        assembly descriptor, because their raw values have to be interpreted
        using additional, artifact-specific expression resolvers.</para>

        <para>The artifact expressions available for these two elements vary
        only slightly. In both cases, all of the
        <varname>\${project.*}</varname>, <varname>\${pom.*}</varname>, and
        <varname>\${*}</varname> expressions that are available in the
        <acronym>POM</acronym> and the rest of the assembly descriptor are
        also available here. For the <sgmltag>outputFileNameMapping</sgmltag>
        element, the following process is applied to resolve
        expressions:</para>

        <orderedlist>
          <listitem>
            <para>If the expression matches the pattern
            <varname>\${artifact.*}</varname>:</para>

            <orderedlist numeration="loweralpha">
              <listitem>
                <para>Match against the dependency’s
                <classname>Artifact</classname> instance (resolves:
                <varname>groupId</varname>, <varname>artifactId</varname>,
                <varname>version</varname>, <varname>baseVersion</varname>,
                <varname>scope</varname>, <varname>classifier</varname>, and
                <varname>file.*</varname>)</para>
              </listitem>

              <listitem>
                <para>Match against the dependency’s
                <classname>ArtifactHandler</classname> instance (resolves:
                <varname>expression</varname>)</para>
              </listitem>

              <listitem>
                <para>Match against the project instance associated with the
                dependency’s Artifact (resolves: mainly POM properties)</para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>If the expression matches the patterns
            <varname>\${pom.*}</varname> or
            <varname>\${project.*}</varname>:</para>

            <orderedlist numeration="loweralpha">
              <listitem>
                <para>Match against the project instance
                (<classname>MavenProject</classname>) of the current
                build.</para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>If the expression matches the pattern
            <varname>\${dashClassifier?}</varname> and the Artifact instance
            contains a non-null classifier, resolve to the classifier preceded
            by a dash (-classifier). Otherwise, resolve to an empty
            string.</para>
          </listitem>

          <listitem>
            <para>Attempt to resolve the expression against the project
            instance of the current build.</para>
          </listitem>

          <listitem>
            <para>Attempt to resolve the expression against the POM properties
            of the current build.</para>
          </listitem>

          <listitem>
            <para>Attempt to resolve the expression against the available
            system properties.</para>
          </listitem>

          <listitem>
            <para>Attempt to resolve the expression against the available
            operating-system environment variables.</para>
          </listitem>
        </orderedlist>

        <para>The <sgmltag>outputDirectory</sgmltag> value is interpolated in
        much the same way, with the difference being that there is no
        available <varname>\${artifact.*}</varname> information, only the
        <varname>\${project.*}</varname> instance for the particular artifact.
        Therefore, the expressions listed above associated with those classes
        (1a, 1b, and 3 in the process listing above) are unavailable.</para>

        <para>How do you know when to use <sgmltag>outputDirectory</sgmltag>
        and <sgmltag>outputFileNameMapping</sgmltag>? When dependencies are
        unpacked only the <sgmltag>outputDirectory</sgmltag> is used to
        calculate the output location. When dependencies are managed as whole
        files (not unpacked), both <sgmltag>outputDirectory</sgmltag> and
        <sgmltag>outputFileNameMapping</sgmltag> can be used together. When
        used together, the result is the equivalent of:</para>

        <programlisting language="xml">&lt;archive-root-dir&gt;/&lt;outputDirectory&gt;/&lt;outputFileNameMapping&gt;</programlisting>

        <para>When <sgmltag>outputDirectory</sgmltag> is missing, it is not
        used. When <sgmltag>outputFileNameMapping</sgmltag> is missing, its
        default value is:
        <code>\${artifact.artifactId}-\${artifact.version}\${dashClassifier?}.\${artifact.extension}</code></para>
      </section>

      <section id="assemblies-sect-include-by-scope">
        <title>Including and Excluding Dependencies by Scope</title>

        <para>In <xref
        linkend="pom-relationships-sect-project-dependencies" />, it was noted
        that all project dependencies have one scope or another. Scope
        determines when in the build process that dependency normally would be
        used. For instance, test-scoped dependencies are not included in the
        classpath during compilation of the main project sources; but they are
        included in the classpath when compiling unit test sources. This is
        because your project’s main source code should not contain any code
        specific to testing, since testing is not a function of the project
        (it’s a function of the project’s build process). Similarly,
        provided-scoped dependencies are assumed to be present in the
        environment of any eventual deployment. However, if a project depends
        on a particular provided dependency, it is likely to require that
        dependency in order to compile. Therefore, provided-scoped
        dependencies are present in the compilation classpath, but not in the
        dependency set that should be bundled with the project’s artifact or
        assembly.</para>

        <para>Also from <xref
        linkend="pom-relationships-sect-project-dependencies" />, recall that
        some dependency scopes imply others. For instance, the
        <varname>runtime</varname> dependency scope implies the
        <varname>compile</varname> scope, since all compile-time dependencies
        (except for those in the <varname>provided</varname> scope) will be
        required for the code to execute. There are a number of complex
        relationships between the various dependency scopes which control how
        the scope of a direct dependency affects the scope of a transitive
        dependency. In a Maven Assembly descriptor, we can use scopes to apply
        different settings to different sets of dependencies
        accordingly.</para>

        <para>For instance, if we plan to bundle a web application with <ulink
        url="http://www.mortbay.org/jetty-6/">Jetty</ulink> to create a
        completely self-contained application, we’ll need to include all
        provided-scope dependencies somewhere in the jetty directory structure
        we’re including. This ensures those provided dependencies actually are
        present in the runtime environment. Non-provided, runtime dependencies
        will still land in the WEB-INF/lib directory, so these two dependency
        sets must be processed separately. These dependency sets might look
        similar to the following XML.</para>

        <example>
          <title>Defining Dependency Sets Using Scope</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
      &lt;outputDirectory&gt;lib/\${project.artifactId}&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/\${webContextName}/WEB-INF/lib
      &lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Provided-scoped dependencies are added to the
        <filename>lib/</filename> directory in the assembly root, which is
        assumed to be a libraries directory that will be included in the Jetty
        global runtime classpath. We’re using a subdirectory named for the
        project’s <varname>artifactId</varname> in order to make it easier to
        track the origin of a particular library. Runtime dependencies are
        included in the <filename>WEB-INF/lib</filename> path of the web
        application, which is located within a subdirectory of the standard
        Jetty <filename>webapps/</filename> directory that is named using a
        custom <acronym>POM</acronym> property called
        <varname>webContextName</varname>. What we've done in the previous
        example is separate application-specific dependencies from
        dependencies which will be present in a Servlet contains global
        classpath.</para>

        <para>However, simply separating according to scope may not be enough,
        particularly in the case of a web application. It’s conceivable that
        one or more runtime dependencies will actually be bundles of
        standardized, non-compiled resources for use in the web application.
        For example, consider a set of web application which reuse a common
        set of Javascript, CSS, SWF, and image resources. To make these
        resources easy to standardize, it’s a common practice to bundle them
        up in an archive and deploy them to the Maven repository. At that
        point, they can be referenced as standard Maven dependencies -
        possibly with a dependency type of <varname>zip</varname> - that are
        normally specified with a runtime scope. Remember, these are
        resources, not binary dependencies of the application code itself;
        therefore, it’s not appropriate to blindly include them in the
        <filename>WEB-INF/lib</filename> directory. Instead, these resource
        archives should be separated from binary runtime dependencies, and
        unpacked into the web application document root somewhere. In order to
        achieve this kind of separation, we’ll need to use inclusion and
        exclusion patterns that apply to the coordinates of a specific
        dependency.</para>

        <para>In other words, say you have three or four web application which
        reuse the same resources and you want to create an assembly that puts
        provided dependencies into <filename>lib/</filename>, runtime
        dependencies into
        <filename>webapps/&lt;contextName&gt;/WEB-INF/lib</filename>, and then
        unpacks a specific runtime dependency into your web application's
        document root. You can do this because the Assembly allows you to
        define multiple include and exclude patterns for a given
        <sgmltag>dependencySet</sgmltag> element. Read the next section for
        more development of this idea.</para>
      </section>

      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->
      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->

      <section id="assemblies-sect-fine-tune">
        <title>Configuration fine : inclusion et exclusion de dépendances</title>

        <para>Une dépendance de ressources peut être une simple liste de ressources (CSS, Javascript, images ...) dans un projet
        qui a une assembly qui crée une archive <acronym>ZIP</acronym>.
        En fonction des particularités de votre application web,
        vous voudrez distinguer les dépendances de ressources des dépendances de binaires en fonction de leur type.
        La plupart des applications web vont dépendre d'autres dépendances de type <varname>jar</varname>, 
        du coup, il est possible de dire avec certitude que toutes les dépendances de type <varname>zip</varname> sont des dépendances de ressources.
        Ou, nous pourrions avoir une situation où les ressources sont conservées sous un format <varname>jar</varname> mais 
        que nous pouvons distinguer les ressources par un tag <varname>resources</varname>.
        Dans tous les cas, nous pouvons spécifier un pattern d'inclusion pour cibler ces dépendances de ressources
        et appliquer une logique différente que celle utilisée pour les binaires. 
        Nous pouvons effectue cette distinction par l'intermédiaire de balises <sgmltag>includes</sgmltag> et <sgmltag>excludes</sgmltag> 
        dans le <sgmltag>dependencySet</sgmltag>.</para>

        <para>Les balises <sgmltag>includes</sgmltag> et <sgmltag>excludes</sgmltag> sont des listes, 
        cela veut dire qu'elles acceptent des sous éléments du type <sgmltag>include</sgmltag> et <sgmltag>exclude</sgmltag>.
        Chaque balise <sgmltag>include</sgmltag> ou <sgmltag>exclude</sgmltag> contient une valeur sous forme de chaîne de caractère, celles-ci pouvant contenir des wildcards.
        Chaque valeur peut matcher des dépendances selon différents moyens.         
        Généralement, trois formats de pattern sont supportés :</para>

        <variablelist>
          <varlistentry>
            <term><varname>groupId:artifactId</varname> - sans la version</term>

            <listitem>
              <para>Utilisez ce pattern pour trouver des dépendances par <varname>groupId</varname> et <varname>artifactId</varname></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><varname>groupId:artifactId:type[:classifier]</varname> - id de conflit</term>

            <listitem>
              <para>Ce pattern vous permet de fournir un ensemble plus large de coordonnées pour créer des patterns include/exclude plus spécifiques.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><varname>groupId:artifactId:type[:classifier]:version</varname> - identité complète de l'artefact</term>

            <listitem>
              <para>Si vous avez un récupérer un artefact bien spécifique, vous pouvez renseigner l'intégralité des coordonnées.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Tous ces formats de patterns supportent l'utilisation de widcard ‘*’, 
        ils permettent de matcher n'importe quelle sous-section de l'identité et n'est pas limitée à une seule sous-section (sections entre ':').         
        En outre, notez que la section classificateur ci-dessus est facultative,
        le pattern matching des dépendances qui n'ont pas de classificateur ne prennent pas en compte la section 'classificateur' de ce pattern.</para>

        <para>Dans l'exemple donné ci-dessus, là où la distinction essentielle est l'artefact de type sip et qu'aucune des dépendances n'a de classificateur,
        le pattern suivant matcherait toutes les ressources de type <varname>zip</varname> :</para> 

        <programlisting>*:zip</programlisting>

        <para>Le pattern ci-dessus utilise la seconde identité de la dépendance : l'id de conflit.
        Maintenant que nous avons un pattern qui distingue les dépendances ressources des binaires, 
        nous pouvons modifier notre liste de dépendances pour gérer les archives différemment :</para>  

        <example id="ex-complex-dependencySet">
          <title>Utilisation des l'inclusion et d'exclusion de dépendances dans le <sgmltag>dependencySets</sgmltag></title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
      &lt;outputDirectory&gt;lib/\${project.artifactId}&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/\${webContextName}/WEB-INF/lib
      &lt;/outputDirectory&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;*:zip&lt;/exclude&gt;
      &lt;/excludes&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/\${webContextName}/resources
      &lt;/outputDirectory&gt;
      &lt;includes&gt;
        &lt;include&gt;*:zip&lt;/include&gt;
      &lt;/includes&gt;
      &lt;unpack&gt;true&lt;/unpack&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Dans l'<xref linkend="ex-complex-dependencySet" />, 
        la liste de dépendances scopée <varname>runtime</varname> de notre dernier exemple à été mis à jour pour exclure les dépendances de type ressource.
        Seules les dépendances de type binaire (les dépendances qui ne sont pas de ZIP) sont ajoutées dans le répertoire <filename>WEB-INF/lib</filename> de l'application. 
        Les dépendances de type ressource sont rassemblées dans une même liste,        
        celle-ci est configurée pour copier ses dépendances dans le répertoire ressource de l'application.
        La balise <sgmltag>includes</sgmltag> du dernier <sgmltag>dependencySet</sgmltag> annule les exclusions du <sgmltag>dependencySet</sgmltag> précédent.
        Ainsi, les dépendances ressources sont incluses en utilisant un seul pattern d'identité : <varname>*:zip</varname>.
        La dernière balise <sgmltag>dependencySet</sgmltag> fait référence à des ressources partagées et est configurée pour deziper celles-ci à la racine de l'application web.</para>

        <para>L'<xref linkend="ex-complex-dependencySet" /> présume que le projet contenant les ressources partagées a un type différent des autres dépendances. 
        Que se passerait-il si celle-ci avait le même type que celui des autres dépendances ?
        Comment différencieriez-vous cette dépendance ?
        Dans ce cas, si une dépendance de ressources partagées a été packagée comme un JAR avec le classificateur de type <varname>resources</varname>,  
        vous pouvez changer le pattern d'identité pour qu'il match ces dépendances :</para> 

        <programlisting>*:jar:resources</programlisting>

        <para>Au lieu de matcher les artefacts de type <varname>zip</varname> sans classificateur,
        nous matchons ici les artefacts de type <varname>jar</varname> qui possède un classificateur <varname>resources</varname>.</para>   

        <para>Comme pour la section <sgmltag>fileSets</sgmltag>, <sgmltag>dependencySets</sgmltag> supporte l'utilisation du flag <sgmltag>useStrictFiltering</sgmltag>. 
        Lorsque celui-ci est activé, n'importe quel pattern qui ne match pas une ou plusieurs dépendances causera l'échec de l'assembly, et donc par conséquent, du build.  
        Très pratique pour utiliser comment soupape de sécurité, pour vous assurer que les dépendances de votre projet et votre descripteur d'assembly soient correctement synchronisés.  
        Par défaut, ce flag est désactivé pour des raisons de rétrocompatibilité.</para> 
      </section>

      <section id="assemblies-sect-transitive">
        <title>Dépendances transitives, pièces jointes et artefacts de projet</title>

        <para>La section <sgmltag>dependencySet</sgmltag> vous propose deux autres mécanismes pour vous aider dans le choix de vos artefacts :  
        options de sélection transitive et options pour travailler avec des artefacts du projet.
        Ces deux fonctionnalités proviennent de la nécessité de supporter des configurations existantes qui utilisent une définition un peu plus libérale du mot «dépendance». 
        Comme premier exemple, examinons l'artefact principal du projet.
        Typiquement, dans la majorité des cas, il ne doit pas être considéré comme une dépendance.
        Pourtant, les plus anciennes versions du plugin Assembly l'utilisaient dans le calcul des dépendances.
        Pour fournir une rétrocompatibilité avec cette “fonctionnalité”,
        la version 2.2 du plugin Assembly dispose d'un flag à mettre dans le <sgmltag>dependencySet</sgmltag>, celui-ci est appelé <sgmltag>useProjectArtifact</sgmltag>,
        La valeur par défaut de ce flag est <varname>true</varname>. 
        Par défaut, le set de dépendances essayera d'inclure l'artefact du projet dans le calcul de ses dépendances.  
        Si vous préférez gérer l'artefact du projet séparément, affectez ce flag à <varname>false</varname>.</para>

        <tip>
          <para>Les auteurs de ce livre vous recommandent de toujours laisser le flag
          <sgmltag>useProjectArtifact</sgmltag> à <varname>false</varname>.</para>
        </tip>

        <para>Comme extension naturelle à l'inclusion d'un artefact projet, 
        les artefacts rattachés à un projet peuvent également être gérés par un  <sgmltag>dependencySet</sgmltag> en utilisant
        le flag <sgmltag>useProjectAttachments</sgmltag> (celui-ci est désactivé par défaut). 
        Activer ce flag permet aux patterns qui précisent des classificateurs et des types d'artefacts de matcher les artefacts rattachés.
        Ils partagent la même identité <varname>groupId</varname>/<varname>artifactId</varname>/<varname>version</varname>,
        mais diffèrent de <varname>type</varname> et de <varname>classifier</varname>.
        Cette fonctionnalité peut s'avérer utilise pour inclure les JARs de Javadoc ou de Source dans une assembly.</para>

        <para>En plus de traiter avec des artefacts du projet,
        il est également possible de configurer un set de dépendances en utilisant deux flags permettant d'activer la résolution transitive.
        Le premier, appelé <sgmltag>useTransitiveDependencies</sgmltag> (et activé par défaut), permet d'activer l'inclusion des dépendances transitives lors du matching.
        Comme exemple pour savoir comment il peut être utilisé, considérer ce qui arrive lorsque votre <acronym>POM</acronym> à une dépendance sur une autre assembly.
        Cette assembly aura (probablement) un classificateur qui le sépare de l'artefact principal du projet, ce qui en fait une pièce jointe.    
        Cependant, une particularité du processus de résolution des dépendances Maven que les informations des dépendances transitives pour l'artefact principal
        sont toujours utilisées pour résoudre l'artefact de l'assembly.
        Si l'assembly package ses dépendances à l'intérieur de lui-même, 
        dans ce cas, utiliser la résolution des dépendances transitives dupliquerait effectivement ces dépendances.         
        Pour éviter cela, nous pouvons simplement affecter le flag <sgmltag>useTransitiveDependencies</sgmltag> à <varname>false</varname>.</para>

        <para>L'autre flag permettant de résoudre les dépedances dépendances est plus subtil.
        Il est appelé <sgmltag>useTransitiveFiltering</sgmltag> et sa valeur par défaut est <varname>false</varname>.
        Pour comprendre ce que fait ce flag, nous devons d'abord comprendre quelles informations sont disponibles pour un artefact donné lors du processus de résolution des dépendances. 
        Quand un artefact est une dépendance d'un autre (qui est, retiré au moins un niveau à partir de votre <acronym>POM</acronym>),
        elle a ce que Maven appelle un "chemin de dépendances", laquelle est maintenue comme une liste de chaînes de caractère et correspond à l'identité complète de l'artefact 
        (<varname>groupId:artifactId:type:[classifier:]version</varname>)
        de toutes les dépendances entre votre <acronym>POM</acronym> et l'artefact a qui appartient ce chemin.
        Si vous vous rappelez des trois types d'identités des artefacts disponibles pour pattern matching,
        vous remarquerez que les entrées dans ce chemin de dépendances - l'identité complète de l'artefact  - correspond au troisième type.
        Lorsque le flag <sgmltag>useTransitiveFiltering</sgmltag> est affecté à <varname>true</varname>, 
        toutes les entrées du chemin de dépendances d'un artefact peuvent agir sur l'inclusion ou l'exclusion de cet artefact.</para>

        <para>Si vous considérez l'utisation de ce filtrage transitif, prennez garde !
        Un artefact peut être inclus à partie de nombreux emplacement dans un graphe de dépendance, mais dans Maven 2.0.9,
        seul le premier chemin de dépendances est utilisé pour ce type de matching.
        Cela peut conduire à des problèmes subtils dans la collecte des dépendances de votre projet.</para>

        <warning>
          <para>La plupart des assembly ne nécessitent ce niveau de contrôle sur les sets de dépendances,
          reflechissez attentivement pour savoir si la vôtre en a vraiment besoin. Astuce : ce n'est probablement pas le cas.</para>
        </warning>
      </section>

      <section id="assemblies-sect-unpack">
        <title>Options avancées de dépaquetage</title>

        <para>Comme discuté précédemment, certaines dépendances de projet ont besoin d'être dézippées pour créer une assembly.
        Dans les exemples ci-dessus, la décision de dézipper ou non était simple.
        Il ne tient pas compte de ce qui doit être dépaqueté, ou plus important, de ce qui ne doit pas être dépaqueté. 
        Pour obtenir plus de contrôle sur le processus de dépaquetage,
        vous pouvez configurer la balise <sgmltag>unpackOptions</sgmltag> dans votre <sgmltag>dependencySet</sgmltag>.
        Ainsi, vous avez la possibilité de choisir quels fichiers vous voulez inclure dans votre assembly,
        et quels fichiers doivent être filtrés pour résoudre des expressions à partir des informations du <acronym>POM</acronym>.
        En fait, les options disponibles pour dépaqueter vos sets de dépendances sont similaires à celles disponibles pour l'inclusion ou l'exclusion de fichier.</para>

        <para>Pour continuer notre exemple d'application web,
        supposons que certaines dépendances de ressources aient été zippées avec un fichier qui décrit les détails de leur licence de distribution.
        Dans le cas de notre application web,
        ces licences se présenteront sous la forme d'un fichier <filename>NOTICES</filename> inclu dans notre paquetage.
        Pour exclure ce fichier, ajoutons-le simplement aux options de dépaquetage dans le set des dépendances qui gère les artefacts de ressources :</para> 

        <example>
          <title>Exclusion de fichiers dans le dépaquetage d'une dépendance</title>

          <programlisting language="xml">&lt;asembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/\${webContextName}/resources
      &lt;/outputDirectory&gt;
      &lt;includes&gt;
        &lt;include&gt;*:zip&lt;/include&gt;
      &lt;/includes&gt;
      &lt;unpack&gt;true&lt;/unpack&gt;
      &lt;unpackOptions&gt;
        &lt;excludes&gt;
          &lt;exclude&gt;**/LICENSE*&lt;/exclude&gt;
        &lt;/excludes&gt;
      &lt;/unpackOptions&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Notez que le tag <sgmltag>exclude</sgmltag> que nous utilisons ressemble beaucoup à celui de la déclaration du <sgmltag>fileSet</sgmltag>.  
        Ici, nous interdisons les fichiers qui commencent par le mot <filename>LICENSE</filename> dans les répertoires de nos artefacts de ressources.
        Vous pouvez comparer la section des options de dépaquetage à un petit <sgmltag>fileSet</sgmltag> appliqué à chaque dépendance qui match ce set.
        En d'autres mots, il s'agit d'un <sgmltag>fileSet</sgmltag> utilisé pour le dépaquetage des dépendances.
        Tout comme nous avons spécifié un modèle d'exclusion pour les dossiers dans les dépendances de ressources afin de bloquer certains fichiers,
        vous pouvez également choisir un ensemble restreint de fichiers à inclure en utilisant la section <varname>includes</varname>.
        Le même code que celui du processus d'inclusion et d'exclusion des <sgmltag>fileSets</sgmltag> peut-être réutilisé pour le traitement des <sgmltag>unpackOptions</sgmltag>.</para>

        <para>En plus de mécanisme d'inclusion et d'exclusion,
        les options de dépaquetages sur un set de dépendances peuvent également fournir un flag <sgmltag>filtering</sgmltag>,
        par défaut sa valeur est <varname>false</varname>.
        Encore une fois, cela ressemble beaucoup au mécanisme proposé par les sets de fichiers discuté ci-dessus.
        Les expressions peuvent utiliser soit la syntaxe Maven d'une <varname>\${property}</varname>, soit la syntaxe Ant d'une <varname>@property@</varname>.
        Le filtrage des ressources est particulièrement intéressant pour les sets de dépendances.        
        Car elle permet de créer des templates ressources normalisés et versionnés qui peuvent être personnalisés pour chaque assembly dans lequel ils sont inclus.
        Une fois que vous maîtrisez la fonctionnalité de filtrage, que vous avez dépaqueté les dépendances qui sont stockées dans des ressources partagées,
        vous serez en mesure de commencer à abstraire certaines ressources répétées.</para>
      </section>

      <section id="assemblies-sect-summarizing">
        <title>Résumer les sets de dépendances</title>

        <para>Au final, il est important de mentionner que les sets de dépendances supportent les mêmes options de configuration <sgmltag>fileMode</sgmltag> et <sgmltag>directoryMode</sgmltag> que celles des sets de fichiers.
        Cependant, vous devrez vous rappeler que le <sgmltag>directoryMode</sgmltag> ne sera utilisé que si les dépendances sont dépaquetées.</para>
      </section>
    </section>

    <section id="assemblies-sect-modulesets">
      <title>Sections <sgmltag>moduleSets</sgmltag></title>

      <para>
      
      Multi-module builds are generally stitched together using the parent and modules sections of interrelated <acronym>POM</acronym>s.
      Typically, parent <acronym>POM</acronym>s specify their children in a <sgmltag>modules</sgmltag> section, 
      which under normal circumstances causes the child <acronym>POM</acronym>s to be included in the build process of the parent. 
      Exactly how this relationship is constructed can have important implications for the ways in which the Assembly plugin can participate in this process, 
      but we’ll discuss that more later. 
      For now, it’s enough to keep in mind this parent-module relationship as we discuss the <sgmltag>moduleSets</sgmltag> section.</para>

      <!--TODO: I think we need a simple example of how/why this would be used.-->

      <para>Les projets sont construits sous la forme d'un projet multimodule parce qu'ils font partie d'un système plus vaste.
      Ces projets sont conçus pour être utilisés ensemble, un module unique dans un grand build n'a peu de valeur en lui-même.
      De cette façon, la structure du build du projet est liée à la façon dont nous espérons que ce projet (et ses modules) soit utilisé.
      Si vous considérez le projet du point de vue de l'utilisateur, 
      il semble logique que l'objectif final de ce build soit de construire et distribuer un seul fichier que les utilisateurs pourront directement déployer sans trop de tracas. 
      Comme les builds multimodule Maven s'appuient habituellement sur une structure top-down,
      où des informations de dépendances, des configurations de plugin et bien d'autres informations sont hérités du projet parent à l'enfant,
      il semble naturel que la tâche de transformation de ces modules dans un fichier unique distribuable doive incomber au projet le plus haut dans la hiérarchie.
      Voilà où la balise <sgmltag>moduleSet</sgmltag> intervient.</para>

      <para>Les sets de modules permettent l'inclusion de ressources dans l'assembly final, celles-ci dépendent de chaque module dans la structure du projet. 
      Tout comme vous pouvez choisir un groupe de fichiers à inclure dans un assembly en utilisant les balises <sgmltag>fileSet</sgmltag> et <sgmltag>dependencySet</sgmltag>,
      vous pouvez inclure un set de fichier et de ressources en utilisant un <sgmltag>moduleSet</sgmltag> pour se référer aux modules d'un build multimodule.
      Cela est rendu possible grâce aux deux types d'inclusion spécifique aux modules : l'un basé sur les fichiers, l'autre sur les artefacts. 
      Avant d'entrer dans les particularités ces deux types d'inclusion de modules ressources dans une assembly,
      parlons un peu de comment sélectionner les modules à traiter.</para>

      <section id="assemblies-sect-module-selection">
        <title>Sélection des modules</title>

        <para>
        
        By now, you should be familiar with <sgmltag>includes</sgmltag>/<sgmltag>excludes</sgmltag> patterns as
        they are used throughout the assembly descriptor to filter files and dependencies. 
        When you are referring to modules in an assembly descriptor, 
        you will also use the <sgmltag>includes</sgmltag>/<sgmltag>excludes</sgmltag> patterns to define rules which apply to different sets of modules. 
        The difference in <sgmltag>moduleSet</sgmltag> <sgmltag>includes</sgmltag> and
        <sgmltag>excludes</sgmltag> is that these rules do not allow for wildcard patterns. 
        (As of the 2.2-beta-2 release, this feature has not really seen much demand, so it hasn’t been implemented.) 
        Instead, each include or exclude value is simply the <varname>groupId</varname> and <varname>artifactId</varname> for the module, separated by a colon, like this:</para>

        <programlisting>groupId:artifactId</programlisting>

        <para>In addition to <sgmltag>includes</sgmltag> and
        <sgmltag>excludes</sgmltag>, the <sgmltag>moduleSet</sgmltag> also
        supports an additional selection tool: the
        <sgmltag>includeSubModules</sgmltag> flag (whose default value is
        <varname>true</varname>). The parent-child relationship in any
        multi-module build structure is not strictly limited to two tiers of
        projects. In fact, you can include any number of tiers, or layers, in
        your build. Any project that is a module of a module of the current
        project is considered a sub-module. In some cases, you may want to
        deal with each individual module in the build separately (including
        sub-modules). For example, this is often simplest when dealing with
        artifact-based contributions from these modules. To do this, you would
        simply leave the <sgmltag>useSubModules</sgmltag> flag set to the
        default of <varname>true</varname>.</para>

        <para>When you’re trying to include files from each module’s directory
        structure, you may wish to process that module’s directory structure
        only once. If your project directory structure mirrors that of the
        parent-module relationships that are included in the
        <acronym>POM</acronym>s, this approach would allow file patterns like
        **/src/main/java to apply not only to that direct module’s project
        directory, but also to the directories of its own modules as well. In
        this case you don’t want to process sub-modules directly (they will be
        processed as subdirectories within your own project’s modules
        instead), you should set the <sgmltag>useSubModules</sgmltag> flag to
        <varname>false</varname>.</para>

        <para>Once we’ve determined how module selection should proceed for
        the module set in question, we’re ready to choose what to include from
        each module. As mentioned above, this can include files or artifacts
        from the module project.</para>
      </section>

      <section id="assemblies-sect-sources-section">
        <title>Sources Section</title>

        <para>Suppose you want to include the source of all modules in your
        project's assembly, but you would like to exclude a particular module.
        Maybe you have a project named <varname>secret-sauce</varname> which
        contains secret and sensitive code that you don't want to distribute
        with your project. The simplest way to accomplish this is to use a
        <sgmltag>moduleSet</sgmltag> which includes each project's directory
        in <varname>\${module.basedir.name}</varname> and which excludes the
        <varname>secret-sauce</varname> module from the assembly.</para>

        <example id="ex-include-exclude-moduleSet">
          <title>Includes and Excluding Modules with a
          <sgmltag>moduleSet</sgmltag></title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;includeSubModules&gt;false&lt;/includeSubModules&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;
          com.mycompany.application:secret-sauce
        &lt;/exclude&gt;
      &lt;/excludes&gt;
      &lt;sources&gt;
        &lt;outputDirectoryMapping&gt;
          \${module.basedir.name}
        &lt;/outputDirectoryMapping&gt;
        &lt;excludeSubModuleDirectories&gt;
          false
        &lt;/excludeSubModuleDirectories&gt;
        &lt;fileSets&gt;
          &lt;fileSet&gt;
            &lt;directory&gt;/&lt;/directory&gt;
            &lt;excludes&gt;
              &lt;exclude&gt;**/target&lt;/exclude&gt;
            &lt;/excludes&gt;
          &lt;/fileSet&gt;
        &lt;/fileSets&gt;
      &lt;/sources&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>In <xref linkend="ex-include-exclude-moduleSet" />, since we’re
        dealing with each module’s sources it’s simpler to deal only with
        direct modules of the current project, handling sub-modules using
        file-path wildcard patterns in the file set. We set the
        <sgmltag>includeSubModules</sgmltag> element to
        <varname>false</varname> so we don't have to worry about submodules
        showing up in the root directory of the assembly archive. The
        <sgmltag>exclude</sgmltag> element will take care of excluding the
        <varname>secret-sauce</varname> module. We’re not going to include the
        project sources for the secret-sauce module; they’re, well,
        secret.</para>

        <para>Normally, module sources are included in the assembly under a
        subdirectory named after the module’s <varname>artifactId</varname>.
        However, since Maven allows modules that are not in directories named
        after the module project’s <varname>artifactId</varname>, it’s often
        better to use the expression
        <varname>\${module.basedir.name}</varname> to preserve the module
        directory’s actual name (<varname>\${module.basedir.name}</varname> is
        the same as calling
        <methodname>MavenProject.getBasedir().getName()</methodname>). It is
        critical to remember that modules are not required to be
        subdirectories of the project that declares them. If your project has
        a particularly strange directory structure, you may need to resort to
        special <sgmltag>moduleSet</sgmltag> declarations that include
        specific project and account for your own project's
        idiosyncracies.</para>

        <warning>
          <para>Try to minimize your own project's idiosyncracies, while Maven
          is flexible, if you find yourself doing too much configuration there
          is likely an easier way.</para>
        </warning>

        <para>Continuing through <xref
        linkend="ex-include-exclude-moduleSet" />, since we’re not processing
        sub-modules explicitly in this module set, we need to make sure
        sub-module directories are not excluded from the source directories we
        consider for each direct module. By setting the
        <sgmltag>excludeSubModuleDirectories</sgmltag> flag to
        <varname>false</varname>, this allows us to apply the same file
        pattern to directory structures within a sub-module of the one we’re
        processing. Finally in <xref
        linkend="ex-include-exclude-moduleSet" />, we’re not interested in any
        output of the build process for this module set. We exclude the
        target/ directory from all modules.</para>

        <para>It’s also worth mentioning that the <sgmltag>sources</sgmltag>
        section supports <sgmltag>fileSet</sgmltag>-like elements directly
        within itself, in addition to supporting nested
        <sgmltag>fileSets</sgmltag>. These configuration elements are used to
        provide backward compatibility to previous versions of the Assembly
        plugin (versions 2.1 and under) that didn’t support multiple distinct
        file sets for the same module without creating a separate module set
        declaration. They are deprecated, and should not be used.</para>
      </section>

      <section id="assemblies-sect-interpolate-modulesets">
        <title>Interpolation of <sgmltag>outputDirectoryMapping</sgmltag> in
        <sgmltag>moduleSets</sgmltag></title>

        <para>In <xref linkend="assemblies-sect-output-location" />, we used
        the element <sgmltag>outputDirectoryMapping</sgmltag> to change the
        name of the directory under which each module’s sources would be
        included. The expressions contained in this element are resolved in
        exactly the same way as the <sgmltag>outputFileNameMapping</sgmltag>,
        used in dependency sets (see the explanation of this algorithm in
        <xref linkend="assemblies-sect-output-algorithm" />).</para>

        <para>In <xref linkend="ex-include-exclude-moduleSet" />, we used the
        expression <varname>\${module.basedir.name}</varname>. You might
        notice that the root of that expression, <varname>module</varname>, is
        not listed in the mapping-resolution algorithm from the dependency
        sets section; this object root is specific to configurations within
        <sgmltag>moduleSets</sgmltag>. It works in exactly the same way as the
        <varname>\${artifact.*}</varname> references available in the
        <sgmltag>outputFileNameMapping</sgmltag> element, except it is applied
        to the module’s <classname>MavenProject</classname>,
        <classname>Artifact</classname>, and
        <classname>ArtifactHandler</classname> instances instead of those from
        a dependency artifact.</para>
      </section>

      <section id="assemblies-sect-binaries">
        <title>Binaries section</title>

        <para>Just as the <sgmltag>sources</sgmltag> section is primarily
        concerned with including a module in its source form, the
        <sgmltag>binaries</sgmltag> section is primarily concerned with
        including the module’s build output, or its artifacts. Though this
        section functions primarily as a way of specifying
        <sgmltag>dependencySets</sgmltag> that apply to each module in the
        set, there are a few additional features unique to module artifacts
        that are worth exploring: <sgmltag>attachmentClassifier</sgmltag> and
        <sgmltag>includeDependencies</sgmltag>. In addition, the
        <sgmltag>binaries</sgmltag> section contains options similar to the
        <sgmltag>dependencySet</sgmltag> section, that relate to the handling
        of the module artifact itself. These are: <sgmltag>unpack</sgmltag>,
        <sgmltag>outputFileNameMapping</sgmltag>,
        <sgmltag>outputDirectory</sgmltag>, <sgmltag>directoryMode</sgmltag>,
        and <sgmltag>fileMode</sgmltag>. Finally, module binaries can contain
        a <sgmltag>dependencySets</sgmltag> section, to specify how each
        module’s dependencies should be included in the assembly archive.
        First, let’s take a look at how the options mentioned here can be used
        to manage the module’s own artifacts.</para>

        <para>Suppose we want to include the javadoc jars for each of our
        modules inside our assembly. In this case, we don’t care about
        including the module dependencies; we just want the javadoc jar.
        However, since this particular jar is always going to be present as an
        attachment to the main project artifact, we need to specify which
        classifier to use to retrieve it. For simplicity, we won’t cover
        unpacking the module javadoc jars, since this configuration is exactly
        the same as what we used for dependency sets earlier in this chapter.
        The resulting module set might look similar to <xref
        linkend="ex-include-javadoc-moduleset" />.</para>

        <example id="ex-include-javadoc-moduleset">
          <title>Including JavaDoc from Modules in an Assembly</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;binaries&gt;
        &lt;attachmentClassifier&gt;javadoc&lt;/attachmentClassifier&gt;
        &lt;includeDependencies&gt;false&lt;/includeDependencies&gt;
        &lt;outputDirectory&gt;apidoc-jars&lt;/outputDirectory&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>In <xref linkend="ex-include-javadoc-moduleset" />, we don’t
        explicitly set the <sgmltag>includeSubModules</sgmltag> flag, since
        it’s <varname>true</varname> by default. However, we definitely want
        to process all modules - even sub-modules - using this module set,
        since we’re not using any sort of file pattern that could match on
        sub-module directory structures within. The
        <sgmltag>attachmentClassifier</sgmltag> grabs the attached artifact
        with the javadoc classifier for each module processed. The
        <sgmltag>includeDependencies</sgmltag> element tells the Assembly
        plugin that we're not interested in any of the module's dependencies,
        just the javadoc attachment. Finally, the
        <sgmltag>outputDirectory</sgmltag> element tells the Assembly plugin
        to put all of the javadoc jars into a directory named
        <filename>apidoc-jars/</filename> off of the assembly root
        directory.</para>

        <para>Although we’re not doing anything too complicated in this
        example, it’s important to understand that the same changes to the
        expression-resolution algorithm discussed for the
        <sgmltag>outputDirectoryMapping</sgmltag> element of the sources
        section also applies here. That is, whatever was available as
        <varname>\${artifact.*}</varname> inside a
        <sgmltag>dependencySet</sgmltag>’s
        <sgmltag>outputFileNameMapping</sgmltag> configuration is also
        available here as <varname>\${module.*}</varname>. The same applies
        for <sgmltag>outputFileNameMapping</sgmltag> when used directly within
        a <sgmltag>binaries</sgmltag> section.</para>

        <para>Finally, let’s examine an example where we simply want to
        process the module’s artifact and its runtime dependencies. In this
        case, we want to separate the artifact set for each module into
        separate directory structures, according to the module’s
        <varname>artifactId</varname> and <varname>version</varname>. The
        resulting module set is surprisingly simply, and it looks like the
        listing in <xref linkend="ex-the-big-include" />:</para>

        <example id="ex-the-big-include">
          <title>Including Module Artifacts and Dependencies in an
          Assembly</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;binaries&gt;
        &lt;outputDirectory&gt;
          \${module.artifactId}-\${module.version}
        &lt;/outputDirectory&gt;
        &lt;dependencySets&gt;
          &lt;dependencySet/&gt;
        &lt;/dependencySets&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>In <xref linkend="ex-the-big-include" />, we’re using the empty
        <sgmltag>dependencySet</sgmltag> element here, since that should
        include all runtime dependencies by default, with no configuration.
        With the <sgmltag>outputDirectory</sgmltag> specified at the binaries
        level, all dependencies should be included alongside the module’s own
        artifact in the same directory, so we don’t even need to specify that
        in our dependency set.</para>

        <para>For the most part, module binaries are fairly straightforward.
        In both parts - the main part, concerned with handling the module
        artifact itself, and the dependency sets, concerned with the module’s
        dependencies - the configuration options are very similar to those in
        a dependency set. Of course, the binaries section also provides
        options for controlling whether dependencies are included, and which
        main-project artifact you want to use.</para>

        <para>Like the sources section, the binaries section contains a couple
        of configuration options that are provided solely for backward
        compatibility, and should be considered deprecated. These include the
        includes and excludes sub-sections.</para>
      </section>

      <section id="assemblies-sect-modulesets-parent-pom">
        <title><sgmltag>moduleSets</sgmltag>, Parent <acronym>POM</acronym>s
        and the <sgmltag>binaries</sgmltag> Section</title>

        <para>Finally, we close the discussion about module handling with a
        strong warning. There are subtle interactions between Maven’s internal
        design as it relates to parent-module relationships and the execution
        of a module-set’s binaries section. When a <acronym>POM</acronym>
        declares a parent, that parent must be resolved in some way or other
        before the <acronym>POM</acronym> in question can be built. If the
        parent is in the Maven repository, there is no problem. However, as of
        Maven 2.0.9 this can cause big problems if that parent is a
        higher-level <acronym>POM</acronym> in the same build, particularly if
        that parent <acronym>POM</acronym> expects to build an assembly using
        its modules’ binaries.</para>

        <para>Maven 2.0.9 sorts projects in a multi-module build according to
        their dependencies, with a given project’s dependencies being built
        ahead of itself. The problem is the parent element is considered a
        dependency, which means the parent project’s build must complete
        before the child project is built. If part of that parent’s build
        process includes the creation of an assembly that uses module
        binaries, those binaries will not exist yet, and therefore cannot be
        included, causing the assembly to fail. This is a complex and subtle
        issue, which severely limits the usefulness of the module binaries
        section of the assembly descriptor. In fact, it has been filed in the
        bug tracker for the Assembly plugin at: <ulink
        url="http://jira.codehaus.org/browse/MASSEMBLY-97">http://jira.codehaus.org/browse/MASSEMBLY-97</ulink>.
        Hopefully, future versions of Maven will find a way to restore this
        functionality, since the parent-first requirement may not be
        completely necessary.</para>
      </section>
    </section>

    <section id="assemblies-sect-repositories">
      <title>Repositories Section</title>

      <para>The repositories section represents a slightly more exotic feature
      in the assembly descriptor, since few applications other than Maven can
      take full advantage of a Maven-repository directory structure. For this
      reason, and because many of its features closely resemble those in the
      <sgmltag>dependencySets</sgmltag> section, we won’t spend too much time
      on the repositories section of the assembly descriptor. In most cases,
      users who understand dependency sets should have no trouble constructing
      repositories via the Assembly plugin. We're not going to motivate the
      <sgmltag>repositories</sgmltag> section; we're not going to go through a
      the business of setting up a use case and walking you through the
      process. We're just going to bring up a few caveats for those of you who
      find the need to use the <sgmltag>repositories</sgmltag> section.</para>

      <!--TODO: We probably need to motivate why you would ever want to do this.  Right now, this section
doesn't make sense to new users.-->

      <para>Having said that, there are a two features particular to the
      repositories section that deserve some mention. The first is the
      <sgmltag>includeMetadata</sgmltag> flag. When set to
      <varname>true</varname> it includes metadata such as the list of real
      versions that correspond to <varname>-SNAPSHOT</varname> virtual
      versions, and by default it’s set to <varname>false</varname>. At
      present, the only metadata included when this flag is
      <varname>true</varname> is the information downloaded from Maven’s
      central repository.</para>

      <para>The second feature is called
      <sgmltag>groupVersionAlignments</sgmltag>. Again, this section is a list
      of individual <sgmltag>groupVersionAlignment</sgmltag> configurations,
      whose purpose is to normalize all included artifacts for a particular
      <varname>groupId</varname> to use a single <varname>version</varname>.
      Each alignment entry consists of two mandatory elements -
      <varname>id</varname> and <varname>version</varname> - along with an
      optional section called <sgmltag>excludes</sgmltag> that supplies a list
      of <varname>artifactId</varname> string values which are to be excluded
      from this realignment. Unfortunately, this realignment doesn’t seem to
      modify the <acronym>POM</acronym>s involved in the repository, neither
      those related to realigned artifacts nor those that depend on realigned
      artifacts, so it’s difficult to imagine what the practical application
      for this sort of realignment would be.</para>

      <para>In general, it’s simplest to apply the same principles you would
      use in dependency sets to repositories when adding them to your assembly
      descriptor. While the repositories section does support the above extra
      options, they are mainly provided for backward compatibility, and will
      probably be deprecated in future releases.</para>
    </section>

    <section id="assemblies-sect-managing-root">
      <title>Managing the Assembly’s Root Directory</title>

      <para>Now that we’ve made it through the main body of the assembly
      descriptor, we can close the discussion of content-related descriptor
      sections with something lighter: root-directory naming and
      site-directory handling.</para>

      <para>Some may consider it a stylistic concern, but it’s often important
      to have control over the name of the root directory for your assembly,
      or whether the root directory is there at all. Fortunately, two
      configuration options in the root of the assembly descriptor make
      managing the archive root directory simple:
      <sgmltag>includeBaseDirectory</sgmltag> and
      <sgmltag>baseDirectory</sgmltag>. In cases like executable jar files,
      you probably don’t want a root directory at all. To skip it, simply set
      the <sgmltag>includeBaseDirectory</sgmltag> flag to
      <varname>false</varname> (it’s <varname>true</varname> by default). This
      will result in an archive that, when unpacked, may create more than one
      directory in the unpack target directory. While this is considered bad
      form for archives that are meant to be unpacked before use, it’s not so
      bad for archives that are consumable as-is.</para>

      <para>In other cases, you may want to guarantee the name of the archive
      root directory regardless of the <acronym>POM</acronym>’s version or
      other information. By default, the <sgmltag>baseDirectory</sgmltag>
      element has a value equal to
      <varname>\${project.artifactId}-\${project.version}</varname>. However,
      we can easily set this element to any value that consists of literal
      strings and expressions which can be interpolated from the current
      <acronym>POM</acronym>, such as
      <varname>\${project.groupId}-\${project.artifactId}</varname>. This
      could be very good news for your documentation team! (We all have those,
      right?)</para>

      <para>Another configuration available is the
      <sgmltag>includeSiteDirectory</sgmltag> flag, whose default value is
      <varname>false</varname>. If your project build has also constructed a
      website document root using the site lifecycle or the Site plugin goals,
      that output can be included by setting this flag to
      <varname>true</varname>. However, this feature is a bit limited, since
      it only includes the <sgmltag>outputDirectory</sgmltag> from the
      reporting section of the current <acronym>POM</acronym> (by default,
      <filename>target/site</filename>) and doesn’t take into consideration
      any site directories that may be available in module projects. Use it if
      you want, but a good <sgmltag>fileSet</sgmltag> specification or
      <sgmltag>moduleSet</sgmltag> specification with sources configured could
      serve equally well, if not better. This is yet another example of legacy
      configuration currently supported by the Assembly plugin for the purpose
      of backward compatibility. Your mileage may vary. If you really want to
      include a site that is aggregated from many modules, you'll want to
      consider using a <sgmltag>fileSet</sgmltag> or
      <sgmltag>moduleSet</sgmltag> instead of setting
      <sgmltag>includeSiteDirectory</sgmltag> to
      <varname>true</varname>.</para>
    </section>

    <section id="assemblies-sect-componentDescriptors">
      <title><sgmltag>componentDescriptors</sgmltag> and
      <sgmltag>containerDescriptorHandlers</sgmltag></title>

      <para>To round out our exploration of the assembly descriptor, we should
      touch briefly on two other sections:
      <sgmltag>containerDescriptorHandlers</sgmltag> and
      <sgmltag>componentDescriptors</sgmltag>. The
      <sgmltag>containerDescriptorHandlers</sgmltag> section refers to custom
      components that you use to extend the capabilities of the Assembly
      plugin. Specifically, these custom components allow you to define and
      handle special files which may need to be merged from the multiple
      constituents used to create your assembly. A good example of this might
      be a custom container-descriptor handler that merged
      <filename>web.xml</filename> files from constituent war or war-fragment
      files included in your assembly, in order to create the single
      web-application descriptor required for you to use the resulting
      assembly archive as a war file.</para>

      <para>The <sgmltag>componentDescriptors</sgmltag> section allows you to
      reference external assembly-descriptor fragments and include them in the
      current descriptor. Component references can be any of the
      following:</para>

      <orderedlist>
        <listitem>
          <para>Relative file paths:
          <filename>src/main/assembly/component.xml</filename></para>
        </listitem>

        <listitem>
          <para>Artifact references:
          <varname>groupId:artifactId:version[:type[:classifier]]</varname></para>
        </listitem>

        <listitem>
          <para>Classpath resources:
          <filename>/assemblies/component.xml</filename></para>
        </listitem>

        <listitem>
          <para>URLs: <ulink
          url="http://www.sonatype.com/component.xml">http://www.sonatype.com/component.xml</ulink></para>
        </listitem>
      </orderedlist>

      <para>Incidentally, when resolving a component descriptor, the Assembly
      plugin tries those different strategies in that exact order. The first
      one to succeed is used.</para>

      <para>Component descriptors can contain many of the same
      content-oriented sections available in the assembly descriptor itself,
      with the exception of <sgmltag>moduleSets</sgmltag>, which is considered
      so specific to each project that it’s not a good candidate for reuse.
      Also included in a component descriptor is the
      <sgmltag>containerDescriptorHandlers</sgmltag> section, which we briefly
      discussed above. Component descriptors cannot contain formats, assembly
      id’s, or any configuration related to the base directory of the assembly
      archive, all of which are also considered unique to a particular
      assembly descriptor. While it may make sense to allow sharing of the
      formats section, this has not been implemented as of the 2.2-beta-2
      Assembly-plugin release.</para>
    </section>
  </section>

  <section id="assemblies-sect-best-practices">
    <title>Best Practices</title>

    <para>The Assembly plugin provides enough flexibility to solve many
    problems in a number of different ways. If you have a unique requirement
    for your project, there's a good chance that you can use the methods
    documented in this chapter to achieve almost any assembly structure. This
    section of the chapter details some common best practices which, if
    adhered to, will make your experiences with the assembly plugin more
    productive and less painful.</para>

    <section id="assemblies-sect-standard-reusable">
      <title>Standard, Reusable Assembly Descriptors</title>

      <para>Up to now, we’ve been talking mainly about one-off solutions for
      building a particular type of assembly. But what do you do if you have
      dozens of projects that all need a particular type of assembly? In
      short, how can we reuse the effort we’ve invested to get our assemblies
      just the way we like them across more than one project without copying
      and pasting our assembly descriptor?</para>

      <para>The simplest answer is to create a standardized, versioned
      artifact out of the assembly descriptor, and deploy it. Once that’s
      done, you can specify that the Assembly plugin section of your project’s
      <acronym>POM</acronym> include the assembly-descriptor artifact as a
      plugin-level dependency, which will prompt Maven to resolve and include
      that artifact in the plugin’s classpath. At that point, you can use the
      assembly descriptor via the <sgmltag>descriptorRefs</sgmltag>
      configuration section in the Assembly plugin declaration. To illustrate,
      consider this example assembly descriptor:</para>

      <programlisting language="xml">&lt;assembly&gt;
  &lt;id&gt;war-fragment&lt;/id&gt;
  &lt;formats&gt;
    &lt;format&gt;zip&lt;/format&gt;
  &lt;/formats&gt;
 &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;outputDirectory&gt;WEB-INF/lib&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  &lt;fileSets&gt;
    &lt;fileSet&gt;
      &lt;directory&gt;src/main/webapp&lt;/directory&gt;
      &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;**/web.xml&lt;/exclude&gt;
      &lt;/excludes&gt;
    &lt;/fileSet&gt;
  &lt;/fileSets&gt;
&lt;/assembly&gt;</programlisting>

      <para>Included in your project, this descriptor would be a useful way to
      bundle the project contents so that it could be unpacked directly into
      an existing web application in order to add to it (for adding an
      extending feature, say). However, if your team builds more than one of
      these web-fragment projects, it will likely want to reuse this
      descriptor rather than duplicating it. To deploy this descriptor as its
      own artifact, we’re going to put it in its own project, under the
      <filename>src/main/resources/assemblies</filename> directory.</para>

      <para>The project structure for this assembly-descriptor artifact will
      look similar to the following:</para>

      <programlisting>|-- pom.xml
`-- src
    `-- main
        `-- resources
            `-- assemblies
                `-- web-fragment.xml
</programlisting>

      <para>Notice the path of our <varname>web-fragment</varname> descriptor
      file. By default, Maven includes the files from the
      <filename>src/main/resources</filename> directory structure in the final
      jar, which means our assembly descriptor will be included with no extra
      configuration on our part. Also, notice the
      <filename>assemblies/</filename> path prefix, the Assembly plugin
      expects this path prefix on all descriptors provided in the plugin
      classpath. It’s important that we put our descriptor in the appropriate
      relative location, so it will be picked up by the Assembly plugin as it
      executes.</para>

      <para>Remember, this project is separate from your actual
      <varname>web-fragment</varname> project now; the assembly descriptor has
      become its own artifact with its own version and, possibly, its own
      release cycle. Once you install this new project using Maven, you’ll be
      able to reference it in your <varname>web-fragment</varname> projects.
      For clarity, the build process should look something like this:</para>

      <screen>$ <command>mvn install</command>
(...)
[INFO] [install:install]
[INFO] Installing (...)/web-fragment-descriptor/target/\
                  web-fragment-descriptor-1.0-SNAPSHOT.jar 
       to /Users/~/.m2/repository/org/sonatype/mavenbook/assemblies/\
          web-fragment-descriptor/1.0-SNAPSHOT/\
          web-fragment-descriptor-1.0-SNAPSHOT.jar
[INFO] ---------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ---------------------------------------------------------------
[INFO] Total time: 5 seconds
(...)</screen>

      <para>Since there are no sources for the
      <varname>web-fragment-descriptor</varname> project, the resulting jar
      artifact will include nothing but our <varname>web-fragment</varname>
      assembly descriptor. Now, let’s use this new descriptor artifact:</para>

      <programlisting language="xml">&lt;project&gt;
  (...)
  &lt;artifactId&gt;my-web-fragment&lt;/artifactId&gt;
  (...)
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2-beta-2&lt;/version&gt;
        &lt;dependencies&gt;
          &lt;dependency&gt;
            &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
            &lt;artifactId&gt;web-fragment-descriptor&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;assemble&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;descriptorRefs&gt;
                &lt;descriptorRef&gt;web-fragment&lt;/descriptorRef&gt;
              &lt;/descriptorRefs&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
      (...)
    &lt;/plugins&gt;
  &lt;/build&gt;
  (...)
&lt;/project&gt;
</programlisting>

      <para>Two things are special about this Assembly plugin
      configuration:</para>

      <itemizedlist>
        <listitem>
          <para>We have to include a plugin-level dependency declaration on
          our new <varname>web-fragment-descriptor</varname> artifact in order
          to have access to the assembly descriptor via the plugin’s
          classpath.</para>
        </listitem>

        <listitem>
          <para>Since we’re using a classpath reference instead of a file in
          the local project directory structure, we must use the
          <sgmltag>descriptorRefs</sgmltag> section instead of the
          <sgmltag>descriptor</sgmltag> section. Also, notice that, while the
          assembly descriptor is actually in the
          <filename>assemblies/web-fragment.xml</filename> location within the
          plugin’s classpath, we reference it without the
          <filename>assemblies/</filename> prefix. This is because the
          Assembly plugin assumes that built-in assembly descriptors will
          always reside in the classpath under this path prefix.</para>
        </listitem>
      </itemizedlist>

      <para>Now, you’re free to reuse the <acronym>POM</acronym> configuration
      above in as many projects as you like, with the assurance that all of
      their web-fragment assemblies will turn out the same. As you need to
      make adjustments to the assembly format - maybe to include other
      resources, or to fine-tune the dependency and file sets - you can simply
      increment the version of the assembly descriptor’s project, and release
      it again. <acronym>POM</acronym>s referencing the assembly-descriptor
      artifact can then adopt this new version of the descriptor as they are
      able.</para>

      <para>One final point about assembly-descriptor reuse: you may want to
      consider sharing the plugin configuration itself as well as publishing
      the descriptor as an artifact. This is a fairly simple step; you simply
      add the configuration listed above to the
      <sgmltag>pluginManagement</sgmltag> section of your parent
      <acronym>POM</acronym>, then reference the managed plugin configuration
      from your module <acronym>POM</acronym> like this:</para>

      <programlisting language="xml">(...)
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
      &lt;/plugin&gt;
(...)</programlisting>

      <para>If you’ve added the rest of the plugin’s configuration - listed in
      the previous example - to the <sgmltag>pluginManagement</sgmltag>
      section of the project’s parent POM, then each project inheriting from
      that parent <acronym>POM</acronym> can add a minimal entry like the one
      above and take advantage of an advanced assembly format in their own
      builds.</para>
    </section>

    <section id="assemblies-set-dist-assemblies">
      <title>Distribution (Aggregating) Assemblies</title>

      <para>As mentioned above, the Assembly plugin provides multiple ways of
      creating many archive formats. Distribution archives are typically very
      good examples of this, since they often combine modules from a
      multi-module build, along with their dependencies and possibly, other
      files and artifacts besides these. The distribution aims to include all
      these different sources into a single archive that the user can
      download, unpack, and run with convenience. However, we also examined
      some of the potential drawbacks of using the
      <sgmltag>moduleSets</sgmltag> section of the assembly descriptor -
      namely, that the parent-child relationships between
      <acronym>POM</acronym>s in a build can prevent the availability of
      module artifacts in some cases.</para>

      <para>Specifically, if module <acronym>POM</acronym>s reference as their
      parent the <acronym>POM</acronym> that contains the Assembly-plugin
      configuration, that parent project will be built ahead of the module
      projects when the multi-module build executes. The parent’s assembly
      expects to find artifacts in place for its modules, but these module
      projects are waiting on the parent itself to finish building, a gridlock
      situation is reached and the parent build cannot succeed (since it’s
      unable to find artifacts for its module projects). In other words, the
      child project depends on the parent project which in turn depends on the
      child project.</para>

      <para>As an example, consider the assembly descriptor below, designed to
      be used from the top-level project of a multi-module hierarchy:</para>

      <programlisting language="xml">&lt;assembly&gt;
  &lt;id&gt;distribution&lt;/id&gt;
  &lt;formats&gt;
    &lt;format&gt;zip&lt;/format&gt;
    &lt;format&gt;tar.gz&lt;/format&gt;
    &lt;format&gt;tar.bz2&lt;/format&gt;
  &lt;/formats&gt;
  
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;includes&gt;
        &lt;include&gt;*-web&lt;/include&gt;
      &lt;/includes&gt;
      &lt;binaries&gt;
        &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
        &lt;unpack&gt;true&lt;/unpack&gt;
        &lt;includeDependencies&gt;true&lt;/includeDependencies&gt;
        &lt;dependencySets&gt;
          &lt;dependencySet&gt;
            &lt;outputDirectory&gt;/WEB-INF/lib&lt;/outputDirectory&gt;
          &lt;/dependencySet&gt;
        &lt;/dependencySets&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
    &lt;moduleSet&gt;
      &lt;includes&gt;
        &lt;include&gt;*-addons&lt;/include&gt;
      &lt;/includes&gt;
      &lt;binaries&gt;
        &lt;outputDirectory&gt;/WEB-INF/lib&lt;/outputDirectory&gt;
        &lt;includeDependencies&gt;true&lt;/includeDependencies&gt;
        &lt;dependencySets&gt;
          &lt;dependencySet/&gt;
        &lt;/dependencySets&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
&lt;/assembly&gt;</programlisting>

      <para>Given a parent project - called app-parent - with three modules
      called <varname>app-core</varname>, <varname>app-web</varname>, and
      <varname>app-addons</varname>, notice what happens when we try to
      execute this multi-module build:</para>

      <screen>$ <command>mvn package</command>
[INFO] Reactor build order: 
[INFO]   app-parent &lt;----- PARENT BUILDS FIRST
[INFO]   app-core
[INFO]   app-web
[INFO]   app-addons
[INFO] ---------------------------------------------------------------
[INFO] Building app-parent
[INFO]    task-segment: [package]
[INFO] ---------------------------------------------------------------
[INFO] [site:attach-descriptor]
[INFO] [assembly:single {execution: distro}]
[INFO] Reading assembly descriptor: src/main/assembly/distro.xml
[INFO] ---------------------------------------------------------------
[ERROR] BUILD ERROR
[INFO] ---------------------------------------------------------------
[INFO] Failed to create assembly: Artifact:
org.sonatype.mavenbook.assemblies:app-web:jar:1.0-SNAPSHOT (included by module) 
does not have an artifact with a file. Please ensure the package phase is 
run before the assembly is generated.
...</screen>

      <para>The parent project - <varname>app-parent</varname> - builds first.
      This is because each of the other projects lists that
      <acronym>POM</acronym> as its parent, which causes it to be forced to
      the front of the build order. The <varname>app-web</varname> module,
      which is the first module to be processed in the assembly descriptor,
      hasn’t been built yet. Therefore, it has no artifact associated with it,
      and the assembly cannot succeed.</para>

      <para>One workaround for this is to remove the executions section of the
      Assembly-plugin declaration, that binds the plugin to the
      <varname>package</varname> lifecycle phase in the parent
      <acronym>POM</acronym>, keeping the configuration section intact. Then,
      execute Maven with two command-line tasks: the first,
      <varname>package</varname>, to build the multi-module project graph, and
      a second, <varname>assembly:assembly</varname>, as a direct invocation
      of the assembly plugin to consume the artifacts built on the previous
      run, and create the distribution assembly. The command line for such a
      build might look like this:</para>

      <screen>$ <command>mvn package assembly:assembly</command></screen>

      <para>However, this approach has several drawbacks. First, it makes the
      distribution-assembly process more of a manual task that can increase
      the complexity and potential for error in the overall build process
      significantly. Additionally, it could mean that attached artifacts -
      which are associated in memory as the project build executes - are not
      reachable on the second pass without resorting to file-system
      references.</para>

      <para>Instead of using a <sgmltag>moduleSet</sgmltag> to collect the
      artifacts from your multi-module build, it often makes more sense to
      employ a low-tech approach: using a dedicated distribution project
      module and inter-project dependencies. In this approach, you create a
      new module in your build whose sole purpose is to assemble the
      distribution. This module <acronym>POM</acronym> contains dependency
      references to all the other modules in the project hierarchy, and it
      configures the Assembly plugin to be bound the
      <varname>package</varname> phase of its build lifecycle. The assembly
      descriptor itself uses the <sgmltag>dependencySets</sgmltag> section
      instead of the <sgmltag>moduleSets</sgmltag> section to collect module
      artifacts and determine where to include them in the resulting assembly
      archive. This approach escapes the pitfalls associated with the
      parent-child relationship discussed above, and has the additional
      advantage of using a simpler configuration section within the assembly
      descriptor itself to do the job.</para>

      <para>To do this, we can create a new project structure that’s very
      similar to the one used for the module-set approach above, with the
      addition of a new distribution project, we might end up with five
      <acronym>POM</acronym>s in total: <varname>app-parent</varname>,
      <varname>app-core</varname>, <varname>app-web</varname>,
      <varname>app-addons</varname>, and <varname>app-distribution</varname>.
      The new <varname>app-distribution</varname> <acronym>POM</acronym> looks
      similar to the following:</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;artifactId&gt;app-parent&lt;/artifactId&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;artifactId&gt;app-distribution&lt;/artifactId&gt;
  &lt;name&gt;app-distribution&lt;/name&gt;
  
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;artifactId&gt;app-web&lt;/artifactId&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;war&lt;/type&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;artifactId&gt;app-addons&lt;/artifactId&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- Not necessary since it's brought in via app-web.
    &lt;dependency&gt; [2]
      &lt;artifactId&gt;app-core&lt;/artifactId&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    --&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>

      <para>Notice that we have to include dependencies for the other modules
      in the project structure, since we don’t have a modules section to rely
      on in this <acronym>POM</acronym>. Also, notice that we’re not using an
      explicit dependency on <varname>app-core</varname>. Since it’s also a
      dependency of <varname>app-web</varname>, we don’t need to process it
      (or, avoid processing it) twice.</para>

      <para>Next, when we move the <filename>distro.xml</filename> assembly
      descriptor into the <varname>app-distribution</varname> project, we must
      also change it to use a <sgmltag>dependencySets</sgmltag> section, like
      this:</para>

      <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;includes&gt;
        &lt;include&gt;*-web&lt;/include&gt;
      &lt;/includes&gt;
      &lt;useTransitiveDependencies&gt;false&lt;/useTransitiveDependencies&gt;
      &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
      &lt;unpack&gt;true&lt;/unpack&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;*-web&lt;/exclude&gt;
      &lt;/excludes&gt;
      &lt;useProjectArtifact&gt;false&lt;/useProjectArtifact&gt;
      &lt;outputDirectory&gt;/WEB-INF/lib&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;
</programlisting>

      <para>This time, if we run the build from the top-level project
      directory, we get better news:</para>

      <screen>$ <command>mvn package</command>
(...)
[INFO] ---------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] ---------------------------------------------------------------
[INFO] module-set-distro-parent ...............SUCCESS [3.070s]
[INFO] app-core .............................. SUCCESS [2.970s]
[INFO] app-web ............................... SUCCESS [1.424s]
[INFO] app-addons ............................ SUCCESS [0.543s]
[INFO] app-distribution ...................... SUCCESS [2.603s]
[INFO] ---------------------------------------------------------------
[INFO] ---------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ---------------------------------------------------------------
[INFO] Total time: 10 seconds
[INFO] Finished at: Thu May 01 18:00:09 EDT 2008
[INFO] Final Memory: 16M/29M
[INFO] ---------------------------------------------------------------</screen>

      <para>As you can see, the dependency-set approach is much more stable
      and - at least until Maven’s internal project-sorting logic catches up
      with the Assembly plugin’s capabilities, - involves less opportunity to
      get things wrong when running a build.</para>
    </section>
  </section>

  <section id="assemblies-sect-summary">
    <title>Summary</title>

    <para>As we’ve seen in this chapter, the Maven Assembly plugin offers
    quite a bit of potential for creating custom archive formats. While the
    details of these assembly archives can be complex, they certainly don’t
    have to be in all cases - as we saw with built-in assembly descriptors.
    Even if your aim is to include your project’s dependencies and selected
    project files in some unique, archived directory structure, writing a
    custom assembly descriptor doesn’t have to be an arduous task.</para>

    <para>Assemblies are useful for a wide array of applications, but are most
    commonly used as application distributions of various sorts. And, while
    there are many different ways to use the Assembly plugin, using
    standardized assembly-descriptor artifacts and avoiding
    <sgmltag>moduleSets</sgmltag> when creating distributions containing
    binaries are two sure ways to avoid problems.</para>
  </section>
</chapter>
