<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="assemblies" lang="fr">
  <title>Maven Assemblies</title>

  <section id="assemblies-sect-intro">
    <title>Introduction</title>

    <para>Maven fournit des plugins qui sont utilisés pour créer des
    archives dans les formats les plus courants, et qui seront pour la
    plupart utilisées comme dépendances d'autres projets. Par exemples
    nous avons les plugins <acronym>JAR</acronym>, <acronym>WAR</acronym>,
    <acronym>EJB</acronym> et <acronym>EAR</acronym>. Comme nous l'avons
    déjà vu dans le <xref linkend="lifecycle" /> ces plugins correspondent
    à différents formats de packaging de projet, chacun avec son processus
    de build légérement différent. Même si Maven supporte les différents
    formats standards de packagaing grâce à ses plugins et des cycles de vie
    personnalisés, il va arriver un moment où vous aurez besoin de créer une
    archive ou un répertoire avec une structure qui lui est propre. Ces archives
    personnalisées sont appelées Assemblies Maven.</para>

    <para>Il existe de nombreuses raisons pour lesquelles vous voulez construire
    ces archives personnalisées pour votre projet. La plus courante, peut-être,
    est la distribution du projet. Ce mot 'distribution' peut signifier plusieurs
    choses selon la personne qui l'emploie (ou selon le projet), tout cela dépendant
    de la manière dont le projet doit être utilisé. Essentiellement, il s'agit
    d'archives qui fournissent un moyen simple pour les utilisateurs d'installer
    ou d'utiliser le produit du projet. Dans certains cas, cela peut signifier
    fournir un serveur d'application comme Jety avec l'application Web. Dans d'autres,
    il s'agit de fournir un paquet contenant le code source, la documentation de l'API
    avec le binaire compilé comme par exemple un fichier jar. C'est souvent lorsque
    vous êtes en train de construire la version distribuable d'un produit que les assemblies
    vont pouvoir vous aider. Par exemple, les produits comme Nexus dont on parle plus
    en détail dans <ulink
    url="http://www.sonatype.com/books/nexus-book/reference/">Repository
    Management with Nexus</ulink>, sont le résultat de plusieurs énormes projets
    Maven multimodules, et c'est une assembly Maven qui a construit l'archive finale
    que vous téléchargez depuis Sonatype.</para>

    <para>Dans la plupart des cas, le plugin Assembly est idéallement taillé
    pour construire des packages distribuables de projets. Cependant, les assemblies
    ne sont pas forcéemnt des archives distribuables ; les assemblies doivent apporter
    aux utilisateurs de Maven la flexibilité dont ils ont besoin pour produire des
    achives personnalisées de tout type.
    Essentiellement, les assemblies doivent combler les trous entre les formats
    standards d'archive fournis par les types de packaging des projets. Bien sûr,
    vous pourriez écrire un plugin Maven complet pour produire votre propre
    format d'archive, avec une nouvelle association au cycle de vie et la
    configuration de gestion d'artefact pour indiquer à Maven comment le déployer.
    Mais le plugin Assembly rend tout cela superflu dans la plupart des cas en vous
    donnant les moyen de construire votre archive selon votre propre recette sans
    avoir à écrire une ligne de code Maven.</para>
  </section>

  <section id="assemblies-sect-basics">
    <title>Les bases du plugin Assembly</title>

    <para>Avant d'aller plus loin, prenons une minute pour parler des deux principaux
    goals du plugin Assembly : <varname>assembly:assembly</varname> et le mojo
    <varname>single</varname>. J'ai cité ces deux goals de manière différente pour
    indiquer qu'on ne les utilise pas de la même manière. Le goal
    <varname>assembly:assembly</varname> est conçu pour être invoqué directement
    depuis la ligne de commande et il ne doit jamais être lié à une hase du cycle 
    de vie. Au contraire, le mojo <varname>single</varname> est lui conçu pour
    faire partie de votre build de tous les jours et doit être rattaché à une phase
    du cycle de vie du build de votre projet.</para>

    <para>La raison de cette différence est que le le goal 
    <varname>assembly:assembly</varname> est ce que Maven appelle un mojo
    aggrégateur ; c'est à dire un mojo qui a été conçu pour pour être exécuté
    au plus une fois dans un build, quelque soit le nombre de projets qui sont
    construits. Il prend sa configuration du projet racine - habituellement
    le <acronym>POM</acronym> de plus haut niveau ou la ligne de commande.
    Quand il est rattaché à un cycle de vie, un mojo aggrégateur peut provoquer
    de désagréables effets secondaires. Il peut forcer l'exécution de la phase
    <varname>package</varname> du cycle de vie en avance de phase, ce qui fait que le build
    exécute cette phase <varname>package</varname> deux fois.</para>

    <para>Comme le goal <varname>assembly:assembly</varname> est un mojo aggrégateur,
    cela peut poser des problèmes avec les builds Maven multimodules et il doit donc
    être appelé seul en ligne de commande. Ne rattachez jamais l'exécution de
    <varname>assembly:assembly</varname> à une phase du cycle de vie.
    <varname>assembly:assembly</varname> était le goal originel du plugin Assembly
    et il n'a jamais été conçu pour faire partie du processus standard de build
    d'un projet. Quand il est devenu clair que les archives produites par assembly
    étaient une exigence légitime des projets le mojo <varname>single</varname> a été
    développé. Ce mojo suppose qu'il a été rattaché à la bonne partie du processus
    de build et que donc il aura accès aux fichiers et artefacts du projetdont il
    a besoin pour s'exécuter au sein d'un grand projet Maven multimodule. Dans un
    environnemet multimodule il s'exécutera autant de fois qu'il est lié aux
    <acronym>POM</acronym>s des différetes modules. Contrairement à
    <varname>assembly:assembly</varname>, <varname>single</varname> ne forcera
    jamais l'exécution d'une étape du cycle de vie en avance de phase.</para>

    <para>Le plugin Assembly propose plusieurs autres goals en plus de ces deux là.
    Cependant le détail de ces autres mojos dépasse le cadre de ce chapitre, parce
    qu'ils servent des cas d'utilisation obsoletes ou exotiques et parce qu'on a
    très rarement besoin d'eux. Autant que possible, pour produire vos packages
    utilisez <varname>assembly:assembly</varname> depuis la ligne de commande et
    <varname>single</varname> pour rattacher cette opération aux phases du cycle
    de vie.</para>

    <section id="assemblies-sect-predefined">
      <title>Les descripteurs Assembly prédéfinis</title>

      <para>Nombreux sont ceux qui choisissent de créer leurs propres recettes -
      appelées descripteurs assembly - cependant cela n'est pas forcément
      nécessaire. Le plugin Assembly fournit des descripteurs prêts à l'emploi
      pour plusieurs types communs d'archives. Vous pouvez donc les utiliser
      immédiatement sans écrire une ligne de configuration. Voici la liste
      des descripteurs assembly prédéfinis dans le plugin Maven Assembly :</para>

      <variablelist>
        <varlistentry>
          <term><varname>bin</varname></term>

          <listitem>
            <para>Le descripteur <varname>bin</varname> est utilisé pour packager
            les fichiers <filename>LICENSE</filename>, <filename>README</filename>
            et <filename>NOTICE</filename> du projet avec on artefact principal, pour
            peu que ce dernier soit un jar. Vous pouvez voir cela comme la plus petite
            distribution binaire pour un projet autoporté.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>jar-with-dependencies</varname></term>

          <listitem>
            <para>Le descripteur <varname>jar-with-dependencies</varname> construit
            une archive <acronym>JAR</acronym> avec le contenu du jar du projet principal
            et les contenus des dépendances d'exécution de ce projet. Associé avec la bonne
            définition de la <varname>Main-Class</varname> Manifest ( dont on parle dans
            “Plugin Configuration” ci-dessous), ce descripteur permet de produire un jar exécutable
            autoporté de votre projet, même si ce projet a des dépendances.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>project</varname></term>

          <listitem>
            <para>Le descripteur <varname>project</varname> construit une archive
            à partir de la structure du répertoire du projet telle qu'elle existe sur
            votre système de fichier, et probablement dans votre outil de gestion de 
            configuration. Bien sûr, le répertoire <filename>target</filename> n'est
            pas pris en compte ainsi que les fichiers de métadonnées comme les
            répertoires <filename>CVS</filename> et <filename>.svn</filename> que nous
            avons l'habitude de voir. En bref, le but de ce descripteur est de créer
            une archive du projet qui, une fois décompressée, permet de construire
            le projet avec Maven.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>src</varname></term>

          <listitem>
            <para>Le descripteur <varname>src</varname> produit une archive du code source
            de votre projet avec les fichiers <filename>pom.xml</filename>, ainsi que les
            évntuels fichiers <filename>LICENSE</filename>,
            <filename>README</filename> et <filename>NOTICE</filename> qui se trouvent
            dans le répertoire racine du projet. Ce descripteur produit une archive 
            qui peut être construite par Maven dans la plupart des cas. Cependant,
            comme il suppose que tout le code source et les ressources sont dans le 
            répertoire standard <filename>src</filename> et donc il peut oublier
            les fichiers et les répertoires non-standards même s'ils sont critiques
            pour le build.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section id="assemblies-sect-building">
      <title>Construire une Assembly</title>

      <para>Le plugin Assembly peut être exécuté de deux manières : vous pouvez
      l'invoquer directement depuis la ligne de commande ou le configurer comme
      un élément standard de votre processus de build en le rattachant à une
      phase du cycle de vie du build de votre projet. L'invocation directe a son
      utilité , particulièrement pour les assemblies qui ne font pas partie des
      principaux délivrables de votre projet. Dans la plupart des cas, vous
      voudrez produire les assemblies de votre projet au cours de son processus
      de build standard. Ainsi vos packagings personnalisés sont inclus lorsque
      votre projet est installé ou deployé dans les dépôts Maven et ils sont donc
      toujours disponibles pour vos utilisateurs.</para>

      <para>Comme exemple d'inocation directe du plugin Assembly, imaginez que vous
      voulez livrer une copie de votre projet que l'on puisse construire à partir des
      sources. Au lieu de le déployer le produit final du build vous voulez aussi
      inclure le code source. Ce n'est pas une opération que vous avez besoin de répeter
      souvent, donc ça n'a pas de sens que d'ajouter cette configuration à votre
      <sgmltag>POM</sgmltag>. AU lieu de cela, vous pouvez utiliser la commande
      suivante : </para>
      <screen>$ <command>mvn -DdescriptorId=project assembly:single</command> 
...
[INFO] [assembly:single] 
[INFO] Building tar : /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
                      target/direct-invocation-1.0-SNAPSHOT-project.tar.gz 
[INFO] Building tar : /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
                      target/direct-invocation-1.0-SNAPSHOT-project.tar.bz2
[INFO] Building zip: /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
                      target/direct-invocation-1.0-SNAPSHOT-project.zip
...</screen>

      <para>Imaginez que vous voulez produire un <acronym>JAR</acronym>
      exécutable à partir de votre projet. Si votre projet est autoporté
      et sans dépendacevous pouvez obtenir ce résultat à partir de votre
      artefact avec un peu de configuration du plugin <acronym>JAR</acronym>.
      Cependant, la plupart des projets ont des dépendances et celles-ci
      doivent être incorporées pour obtenir un <acronym>JAR</acronym> exécutable.
      Dans ce cas, vous voulez vous assurer qu'à chaque fois que vous installez ou
      déployez l'artefact <acronym>JAR</acronym> de votre projet, le <acronym>JAR</acronym>
      exécutable le soit aussi.</para>

      <para>Supposons que la classe princiaple de votre projet est
      <classname>org.sonatype.mavenbook.App</classname>, la configuration de
      <acronym>POM</acronym> suivante permet de crer un <acronym>JAR</acronym>
      exécutable :</para>

      <example>
        <title>Descripteur assembly pour un JAR exécutable</title>

        <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;

  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
  &lt;artifactId&gt;executable-jar&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;name&gt;Assemblies Executable Jar Example&lt;/name&gt;
  &lt;url&gt;http://sonatype.com/book&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;commons-lang&lt;/groupId&gt;
      &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;
      &lt;version&gt;2.4&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
 &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2-beta-2&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;create-executable-jar&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;descriptorRefs&gt;
                &lt;descriptorRef&gt;
                  jar-with-dependencies
                &lt;/descriptorRef&gt;
              &lt;/descriptorRefs&gt;
              &lt;archive&gt;
                &lt;manifest&gt;
                  &lt;mainClass&gt;org.sonatype.mavenbook.App&lt;/mainClass&gt;
                &lt;/manifest&gt;
              &lt;/archive&gt;
           &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>Il y a deux points auxquels il faut prêter attention dans la
      configuration ci-dessus. Premièrement, nous utilisons l'élément 
      <sgmltag>descriptorRefs</sgmltag> dans configuration plutôt que
      le paramètre <sgmltag>descriptorId</sgmltag> que nous avions utilisé
      précédemment. cela nous permet de construire différents packages
      durant la même exécution du plugin Assembly tout en supportant
      notre cas d'utilisation avec très peu de configuration supplémentaire.
      Deuxièmement, la balise <sgmltag>archive</sgmltag> sous
      <sgmltag>configuration</sgmltag> spécifie l'attribut <varname>Main-Class</varname>
      du fichier manifest dans le <acronym>JAR</acronym> produit. Cette section est
      généralement disponible dans les plugins qui créent des fichiers 
      <acronym>JAR</acronym> comme le plugin <acronym>JAR</acronym> utilisé
      pour le packaging par défaut des projets.</para>

      <para>Maintenant, vous pouvez produire un <acronym>JAR</acronym> exécutable
      simplement en exécutant la commande <command>mvn package</command>. Après,
      nous listerons le contenu du répertoire<filename>target</filename> pour
      vérifier que le <acronym>JAR</acronym> exécutable a bien été généré. Enfin,
      pour prouver qu'il s'agit bien d'un <acronym>JAR</acronym> exécutable, nous
      essayerons de l'exécuter :</para>

      <screen>$ <command>mvn package</command>
... (output omitted) ...
[INFO] [jar:jar]
[INFO] Building jar: ~/mvn-examples-1.0/assemblies/executable-jar/target/\
                     executable-jar-1.0-SNAPSHOT.jar
[INFO] [assembly:single {execution: create-executable-jar}]
[INFO] Processing DependencySet (output=)
[INFO] Building jar: ~/mvn-examples-1.0/assemblies/executable-jar/target/\
                     executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar
... (output omitted) ...
$ <command>ls -1 target</command>
... (output omitted) ...
executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar
executable-jar-1.0-SNAPSHOT.jar
... (output omitted) ...
$ <command>java -jar \
        target/executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar </command>
Hello, World!</screen>

      <para>Des traces présentées ci-dessus vous pouvez voir 
      que maintenant le build normal du projet produit un nouvel
      artefact en plus du principal fichier <acronym>JAR</acronym>.
      Ce nouvel artefact à le classifer <varname>jar-with-dependencies</varname>.
      Enfin, nous avons vérifié que ce nouveau <acronym>JAR</acronym>
      est réellement exécutable et que son exécution produit le résutat
      attendu : l'affichage de “Hello, World!”</para>
    </section>

    <section id="assemblies-sect-as-depend">
      <title>Utilisation des assemblies comme dépendances</title>

      <para>Lorsque des assemblies sont produits durant le processus de
      build normal du projet les archives résultantes sont jointes à
      l'artefact principal du projet. Cela signifie qu'ils seront installés
      et déployés au côté de l'artefact et qu'ils seront donc accessibles
      comme ce dernier. Cahque artefact assembly aura les mêmes 
      coordonnées de base que le projet princiapl (à savoir le 
      <varname>groupId</varname>, l'<varname>artifactId</varname> et la
      <varname>version</varname>). Cependant ces artefacts sont des pièces 
      jointes ce qui signifie pour Maven quil s'agit de produits dérivés du
      build du projet princiapl. Par exemple, les assemblies <varname>source</varname>
      contiennent les données d'entrée brutes du build du projet et les
      assemblies <varname>jar-with-dependencies</varname> contiennent l'ensemble
      des classes du projet et de ses dépendances. Les artefacts ainsi rattachés
      peuvent ne pas respecter la règle Maven un projet un artefact de par cette
      nature de produits dérivés.</para>

      <para>Comme les assemblies sont (normalement) des artefacts rattachés, chaucun
      doit avoir son classifier en plus des coordonnées de l'artfact principal pour
      le distinguer de ce dernier. Par défauut ce classifier est l'identifiant du
      descripteur de l'assembly. Quand on utilise les descripteurs pré-définis
      l'identifiant du descripteur d'assembly est le même que l'identifiant utilisé 
      dans la balise <sgmltag>descriptorRef</sgmltag> pour ce type d'assembly.</para>

      <para>Maintenant que vous avez déployé l'assembly au côté de votre artefact
      principal, comment pouvez vous l'utiliser comme dépendance dans un autre
      projet ? La réponse est simple. Rappelez-vous la discussion dans la
      <xref linkend="simple-project-sect-maven-coordinates" /> et dans la <xref
      linkend="pom-relationships-sect-more-coordinates" /> à propos des dépendances
      entre projets avec Maven, les projets dépendent les uns des autres grâce à
      quatre éléments de base que l'on appelle coordonées d'un projet :
      <varname>groupId</varname>, <varname>artifactId</varname>,
      <varname>version</varname>et <varname>packaging</varname>. Dans la <xref
      linkend="profiles-sect-platform-classifier" />, il existe de nombreuses
      variantes de l'artefact du projet selon la plate-forme cible et le 
      projet spécifie un élément <varname>classifier</varname> qui prend la
      valeur <varname>win</varname> ou <varname>linux</varname> de manière à
      pouvoir choisir le bon artefact selon la plate-forme cible. Les artefacts
      assembly peuvent être utilisés comme dépendance grâce aux coordonnées de
      base du projet plus le calssifier avec lequel l'assembly a été installé 
      ou déployé. Si l'assembly n'est pas une archive <acronym>JAR</acronym>
      nous allons devoir déclarer aussi son type.</para>
    </section>

    <section id="assemblies-sect-assembling-via-depend">
      <title>Construction d'assemblies via des assemblies dépendances</title>

      <para>Assez perturbant ce titre n'est ce pas ? Essayons de mettre en place
      un scénario pour expliquer cette notion d'assemblage d'assembly. Imaginez que
      vous voulez construire une archive qui elle-même contient des assemblies d'un
      projet. Supposons que vous avez un build multimodule et que vous voulez
      déployer un assembly qui contient un ensemble d'assemblies de ce projet
      liés entre eux. Dans l'exemple de cette section nous créons un package
      qui rassemble des répertoires "constructibles" du projet pour des
      sous-projets qui sont utilisés ensembles. Pour essayer de rester simple nous
      utiliserons les descripteurs d'assembly dont nous venons de parler -
      <varname>project</varname> et <varname>jar-with-dependencies</varname>.
      Dans cet exemple particulier nous supposons que chaque projet construit
      son assembly en plus de l'artefact <acronym>JAR</acronym> principal.
      Nous supposerons aussi que cahque projet de ce build multimodule rattache
      le goal <varname>single</varname> à la phase <varname>package</varname> et
      qu'il utilise la balise <sgmltag>descriptorRef</sgmltag>. Tous les projets
      de ce build multimodule hérite de la configuration du fichier
      <filename>pom.xml</filename> de plus haut niveau et notamment de sa
      balise <sgmltag>pluginManagement</sgmltag> qui est décrite dans l'<xref
      linkend="ex-top-pom-assembly" />.</para>

      <example id="ex-top-pom-assembly">
        <title>Configuration de l'assembly du projet dans le POM de plus haut niveau</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;pluginManagement&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.2-beta-2&lt;/version&gt;
          &lt;executions&gt;
            &lt;execution&gt;
              &lt;id&gt;create-project-bundle&lt;/id&gt;
              &lt;phase&gt;package&lt;/phase&gt;
              &lt;goals&gt;
                &lt;goal&gt;single&lt;/goal&gt;
              &lt;/goals&gt;
              &lt;configuration&gt;
                &lt;descriptorRefs&gt;
                  &lt;descriptorRef&gt;project&lt;/descriptorRef&gt;
                &lt;/descriptorRefs&gt;
              &lt;/configuration&gt;
            &lt;/execution&gt;
          &lt;/executions&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
  &lt;/build&gt;
  ...
&lt;/project&gt;</programlisting>
      </example>

      <para>Le <acronym>POM</acronym> de chaque projet référence le plugin dont la
      configuration est décrite dans <xref linkend="ex-top-pom-assembly" /> par une
      déclaration minimale dans son build comme le montre l' <xref
      linkend="ex-activating-assembly" />.</para>

      <example id="ex-activating-assembly">
        <title>Activation de la configuration du plugin Assembly dans les projets fils</title>

        <programlisting language="xml">&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;
</programlisting>
      </example>

      <para>Pour produire l'ensemble des assemblies de projet, exécutez la commande
      <command>mvn install</command> depuis le répertoire racine. Vous devriez voir
      Maven installer les artefacts avec des classifiers dans votre dépôt.</para>

      <screen>$ <command>mvn install</command>
...
Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
           second-project/target/second-project-1.0-SNAPSHOT-project.tar.gz to 
  ~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\
           second-project-1.0-SNAPSHOT-project.tar.gz
...
Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
           second-project/target/second-project-1.0-SNAPSHOT-project.tar.bz2 to 
  ~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\
           second-project-1.0-SNAPSHOT-project.tar.bz2
...
Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
           second-project/target/second-project-1.0-SNAPSHOT-project.zip to 
  ~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\\
           second-project-1.0-SNAPSHOT-project.zip
...</screen>

      <para>Lorsque vous exécutez <varname>install</varname>, Maven va copier
      l'artefact principal de chaque projet ainsi que chaque assembly dans
      votre dépôt Maven local. Tous cesartefacts sont maintenant disponibles
      comme dépendance pour d'autres projets localement. Si votre but final
      est de créer un paquet qui inclut les assemblies de différents projets
      vous pouvez créer un autre projet qui référence comme dépendances les
      assemblies de ce projet. Ce projet chapeau prend la responsabilité
      de construire l'assembly englobant tous les autres. Le
      <acronym>POM</acronym> de ce projet chapeau d'empaquetage ressemblerait
      au document XML décrit dans l'<xref linkend="ex-bundling-pom" />.</para>

      <example id="ex-bundling-pom">
        <title>POM du projet assembly chapeau</title>

        <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
  &lt;artifactId&gt;project-bundle&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;name&gt;Assemblies-as-Dependencies Example Project Bundle&lt;/name&gt;
  &lt;url&gt;http://sonatype.com/book&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;artifactId&gt;first-project&lt;/artifactId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;classifier&gt;project&lt;/classifier&gt;
      &lt;type&gt;zip&lt;/type&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;artifactId&gt;second-project&lt;/artifactId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;classifier&gt;project&lt;/classifier&gt;
      &lt;type&gt;zip&lt;/type&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2-beta-2&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;bundle-project-sources&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;descriptorRefs&gt;
                &lt;descriptorRef&gt;
                  jar-with-dependencies
                &lt;/descriptorRef&gt;
              &lt;/descriptorRefs&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</programlisting>
      </example>

      <para>Le <acronym>POM</acronym> de ce projet chapeau d'empaquetage 
      fait référence à deux assemblies des projets 
      <varname>first-project</varname> et <varname>second-project</varname>.
      Au lieu de référencer l'artefact princiapl de chaque projet, le
      <acronym>POM</acronym> de ce projet d'empaquetage spécifie un
      <varname>project</varname> et un type <varname>zip</varname>.
      Cela indique à Maven qu'il v devoir résoudre une archive de
      type <acronym>ZIP</acronym> qui a été créée par l'assembly
      <varname>project</varname>. Remarquez que le projet d'empaquetage
      produit lui-même un assembly <varname>jar-with-dependencies</varname>. 
      <varname>jar-with-dependencies</varname> ne produit pas un paquet 
      particulièrement élégant puisqu'il construit un fichier <acronym>JAR</acronym>
      contenant toutes les dépendances dépaquettées.
      <varname>jar-with-dependencies</varname> demande à Maven de récupérer toutes
      les dépendances , de les décompresser et ensuite de créer une archive
      unique en y incluant le résultat du projet courant. Dans ce projet, cela
      produit un unique fichier <acronym>JAR</acronym> qui aggrège les contenus des
      assemblies de <varname>first-project</varname> et de
      <varname>second-project</varname>.</para>

      <para>Cet exemple illustre comment les capacités de base du plugin Maven
      Assembly peuvent être combinées sans avoir recours à un descripteur 
      d'assembly. Il crée une unique archive qui contient les répertoires
      de plusieurs projets les uns à coté des autres. Cette fois, le 
      <varname>jar-with-dependencies</varname> est juste un format de stockage
      et nous n'avons pas besoin de spécifier l'attribut de
      manifest <varname>Main-Class</varname>. Pour construire ce paquet, nous
      exécutons le projet <varname>project-bundle</varname> comme d'habitude :</para>

      <screen>$ <command>mvn package</command>
...
[INFO] [assembly:single {execution: bundle-project-sources}]
[INFO] Processing DependencySet (output=)
[INFO] Building jar: ~/downloads/mvn-examples-1.0/assemblies/as-dependencies/\
  project-bundle/target/project-bundle-1.0-SNAPSHOT-jar-with-dependencies.jar
</screen>

      <para>Pour vérifier que l'assembly <varname>project-bundle</varname>
      contient bien les élémnts dépaquettés des assemblies dépendances
      exécutez la commande <command>jar tf</command> :</para>

      <screen>$ <command>jar tf \
  target/project-bundle-1.0-SNAPSHOT-jar-with-dependencies.jar</command>
...
first-project-1.0-SNAPSHOT/pom.xml
first-project-1.0-SNAPSHOT/src/main/java/org/sonatype/mavenbook/App.java
first-project-1.0-SNAPSHOT/src/test/java/org/sonatype/mavenbook/AppTest.java
...
second-project-1.0-SNAPSHOT/pom.xml
second-project-1.0-SNAPSHOT/src/main/java/org/sonatype/mavenbook/App.java
second-project-1.0-SNAPSHOT/src/test/java/org/sonatype/mavenbook/AppTest.java</screen>

      <para>Maintenant que vous avez lu cette section son titre devrait
      avoir un peu plus de sens. Vous avez assemblé les assemblies de deux
      projects dans un assembly grâce à un projet d'empaquetage dépendant
      de chcun de ces assemblies.</para>
    </section>
  </section>

  <section id="assemblies-sect-overview-descriptor">
    <title>Vue d'ensmble du descripteur d'assembly</title>

    <para>Quand les descripteurs d'assembly standard dont nous avons parlé 
    dans la <xref linkend="assemblies-sect-basics" /> ne sont pas pertinents,
    vous allez avoir besoin  de définir votre propre descripteur. Un 
    descripteur d'assembly est un document XML qui définit la structure et
    les contenus d'un assembly. Ce descripteur se compose de cinq sections
    principales de configuration et de deux sections additionnelles : une
    pour spécifier des fragments de descripteur d'assembly standard, que l'on
    appelle descripteurs de composant, et une autre pour définir des classes
    de traitement personnalisé de fichier pour aider à gérer la production
    de l'assembly.</para>

    <variablelist>
      <varlistentry>
        <term>Configuration de base</term>

        <listitem>
          <para>Cette section contient les informations nécessaires à tous
          les assemblies plus quelques options de configuration pour
          l'archive finale, comme le chemin de base à utiliser pour toutes les
          entrées d'archive. Pour que le descripteur soit valide vous devez
          spécifier l'identifiant de l'assembly, au moins un format et au moins
          une des sections présentées ci-dessus.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Information de fichier</term>

        <listitem>
          <para>La configuration de ce segment du descripteur d'assembly
          s'applique aux fichiers du système de fichier contenus dans les
          répertoires du projet. Ce segment se compose de deux sections
          principales : <sgmltag>files</sgmltag> et <sgmltag>fileSets</sgmltag>.
          Vous pouvez utiliser les balises <sgmltag>files</sgmltag> et
          <sgmltag>fileSets</sgmltag> pour controler quels fichiers seront
          inclus ou exclus de l'assembly et avec quelles permissions.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Informations de dépendance</term>

        <listitem>
          <para>Presque tous les projets, quelque soit leur taille, dépendent
          d'autres projets. Durant la création d'archives de distribution, les
          dépendances d'un projet sont souvent ajoutées dans l'assembly du
          produit final. Cette section gère la manière dont les dépendances sont 
          ajoutées dans l'archive finale. Cette dans cette section que vous 
          configurez si dépendances doivent être décompressées, ajoutées 
          directement au répertoire <filename>lib/</filename> ou renommées.
          Cette section vous permet aussi de controler quelles dépendances doivent
          être ajoutées à l'assembly et avec quelles permissions.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Information de dépôt</term>

        <listitem>
          <para>Parfois il est utile d'isoler l'ensemble des arefacts nécessaires
          à la construction d'un projet, qu'il s'agisse d'artefacts de dépendance,
          des <acronym>POM</acronym>s des artefacts de dépendance ou même d'un POM
          ancêtre du projet (le <acronym>POM</acronym> parent, son parent, etc.).
          Cette sectionvous permet d'inclure une ou plusieurs structures de répertoires
          de dépôt d'artefact dans votre assembly avec différentes options de 
          configuration. Le plugin Assembly n'est pas capable d'inclure les artefacts
          de plugin dans ces dépôts pour l'instant.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Information de module</term>

        <listitem>
          <para>Cette section du descripteur d'assembly vous permet de profiter
          des relations parent-enfant lors de la construction de votre archive
          personnalisée pour inclure des fichiers de code source, des artefacts
          et des dépendances des sous-modules de votre projet. C'est la section
          la plus complexe du descripteur d'assembly car elle vous permet de
          travailler avec des modules et des sous-modules de deux façons :
          comme un ensemble de balises <sgmltag>fileSets</sgmltag> (via la section
          <sgmltag>sources</sgmltag>) ou comme un ensemble de
          <sgmltag>dependencySets</sgmltag> (via la section
          <sgmltag>binaries</sgmltag>).</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>

  <section id="assemblies-sect-descriptor">
    <title>Le descripteur d'assembly</title>

    <para>This section is a tour of the assembly descriptor which contains
    some guidelines for developing a custom assembly descriptor. The Assembly
    plugin is one of the largest plugins in the Maven ensemble, and one of the
    most flexible.</para>

    <section id="assemblies-sect-prop-refs">
      <title>Référence de propriété dans un descripteur d'assembly</title>

      <para>Toutes les propriétés dont nous avons parlé dans le <xref
      linkend="resource-filtering-sect-properties" /> peut être
      référencée dans un descripteur d'assembly. Avant qu'un descripteur
      d'assembly soit utilisé par Maven, il doit être interpolé en utilisant les
      données du <acronym>POM</acronym> et de l'environnement de build. Toutes
      les propriétés du <acronym>POM</acronym> suuportées pour l'interpolation
      sont utilisables dans les descripteurs d'assembly, qu'il s'agisse de 
      propriétés du <acronym>POM</acronym>, de valeurs d'éléments du
      <acronym>POM</acronym>, de propriétés système ou définies par
      l'utilisateur et de variables d'environnement du système d'exploitation.</para>

      <para>Les seules exceptions à cette étape d'interpolation sont les balises 
      <sgmltag>outputDirectory</sgmltag>, <sgmltag>outputDirectoryMapping</sgmltag> ou
      <sgmltag>outputFileNameMapping</sgmltag> des différentes sections du descripteur.
      Ces éléments sont conservés sous leur forme primitive pour permettre d'appliquer
      les données spécifiques à chaque artéfacts ou module pour la résolution des
      expressions.</para>
    </section>

    <section id="assemblies-sect-required">
      <title>Informations obligatoires pour un assembly</title>

      <para>Tout assembly a besoin obligatoirement de deux données :
      la balise <sgmltag>id</sgmltag> et la liste des formats d'archive à produire.
      En pratique il faut en plus au moins une autre section du descripteur - 
      car la plupart des assembleurs vont se bloquer s'il y a aucun fichier à
      incorporer - mais sans une balise <sgmltag>format</sgmltag> et une
      balise <sgmltag>id</sgmltag> il n'y a aucune archive à réaliser. La
      balise <sgmltag>id</sgmltag> est utilisée à la fois pour le nom et le
      classifier dans le dépôt Maven de l'artefact de l'archive produite.
      Le format détermine quel composant archiveur sera utilisé pour
      produire l'archive assembly finale. Tous les descripteurs d'assembly doivent
      contenir une balise <sgmltag>id</sgmltag> et au moins une balise
      <sgmltag>format</sgmltag> :</para>

      <example id="ex-required-assembly">
        <title>Balises obligatoires d'un descripteur d'assembly</title>

        <programlisting language="xml">&lt;assembly&gt;
  &lt;id&gt;bundle&lt;/id&gt; 
  &lt;formats&gt;
    &lt;format&gt;zip&lt;/format&gt;
  &lt;/formats&gt;
  ...
&lt;/assembly&gt;</programlisting>
      </example>

      <para>L'<sgmltag>id</sgmltag> de l'assembly est une chaine de caractères
      sans espace. La pratique standard est d'utiliser des tirets entre les mots 
      de l'<sgmltag>id</sgmltag> de l'assembly. Si vous produisez un assembly
      qui construit une structure unique d'un package intéressant, vous lui
      donnerez une <varname>id</varname> comme <varname>unique-package-interessant</varname>.
      Il est possible de déclarer plusieurs formats différents dans un même
      descripteur d'assembly, ce qui vous permet de créer les archives de
      distribution habituelles <filename>.zip</filename>, <filename>.tar.gz</filename>
      et <filename>.tar.bz2</filename> facilement. Si vous ne trouvez pas le format
      d'archive qu'il vous faut vous pouvez créer un format personel. Les formats personnels
      sont décrits dans la <xref linkend="assemblies-sect-componentDescriptors" />. Le plugin
      Assembly supporte nativement plusieurs formats d'archive, ce qui inclut :</para>

      <itemizedlist>
        <listitem>
          <para><varname>jar</varname></para>
        </listitem>

        <listitem>
          <para><varname>zip</varname></para>
        </listitem>

        <listitem>
          <para><varname>tar</varname></para>
        </listitem>

        <listitem>
          <para><varname>bzip2</varname></para>
        </listitem>

        <listitem>
          <para><varname>gzip</varname></para>
        </listitem>

        <listitem>
          <para><varname>tar.gz</varname></para>
        </listitem>

        <listitem>
          <para><varname>tar.bz2</varname></para>
        </listitem>

        <listitem>
          <para><varname>rar</varname></para>
        </listitem>

        <listitem>
          <para><varname>war</varname></para>
        </listitem>

        <listitem>
          <para><varname>ear</varname></para>
        </listitem>

        <listitem>
          <para><varname>sar</varname></para>
        </listitem>

        <listitem>
          <para><varname>dir</varname></para>
        </listitem>
      </itemizedlist>

      <para>L'<varname>id</varname> et le <varname>format</varname> sont
      indispensables car il vont faire partie des coordonnées de l'archive
      assemblée. L'exemple de <xref linkend="ex-required-assembly" /> va
      créer un artefact d'assemblyde type <varname>zip</varname> avec comme
      classifier <varname>bundle</varname>.</para>
    </section>
  </section>

  <section id="assemblies-sect-controlling-contents">
    <title>Choisir les contenus d'un assembly</title>

    <para>En théorie, l'<varname>id</varname> et le <varname>format</varname>
    sont les seuls éléments obligatoires pour un descripteur d'assembly valide ;
    cependant la plupart des composants archiveurs 'assembly échoueront s'ils
    n'ont pas au moins un fichier à inclure dans l'archive finale. La définition
    des fichiers à inclure dans l'assembly se fait dans les cinq sections principales
    du descripteur d'assembly : <sgmltag>files</sgmltag>,
    <sgmltag>fileSets</sgmltag>, <sgmltag>dependencySets</sgmltag>,
    <sgmltag>repositories</sgmltag> et <sgmltag>moduleSets</sgmltag>.
    Pour explorer ces sections le plus efficacement possibl nous allons commencer
    par étudier la plus simple : <sgmltag>files</sgmltag>. Puis nous traiterons
    les deux sections les plus utilisées <sgmltag>fileSets</sgmltag> et
    <sgmltag>dependencySets</sgmltag>. Une fois que vous avez compris le
    fonctionnement de <sgmltag>fileSets</sgmltag> et de <sgmltag>dependencySets</sgmltag>,
    il est beaucoup plus facile de comprendre comment fonctionnent 
    <sgmltag>repositories</sgmltag> et <sgmltag>moduleSets</sgmltag>.</para>

    <section id="assemblies-sect-files">
      <title>Section <sgmltag>files</sgmltag></title>

      <para>La <sgmltag>files</sgmltag> est la partie la plus simple du descripteur
      d'assembly, elle a été conçue pour les fichiers qui ont une position
      relative au répertoire du projet. Avec cette section vous avez un total
      contrôle sur les fichiers qui seront inclus dans votre assembly, quel
      seront leurs noms et où ils se positionneront dans l'archive.</para>

      <example id="ex-assembly-files">
        <title>Ajout d'un fichier <acronym>JAR</acronym> dans un assembly avec la balise 
        <sgmltag>files</sgmltag></title>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;files&gt;
    &lt;file&gt;
      &lt;source&gt;target/my-app-1.0.jar&lt;/source&gt;
      &lt;outputDirectory&gt;lib&lt;/outputDirectory&gt;
      &lt;destName&gt;my-app.jar&lt;/destName&gt;
      &lt;fileMode&gt;0644&lt;/fileMode&gt;
    &lt;/file&gt;
  &lt;/files&gt;
  ...
&lt;/assembly&gt;</programlisting>
      </example>

      <para>Supposons que vous construisiez le projet <varname>my-app</varname>
      dans sa version <varname>1.0</varname>, <xref linkend="ex-assembly-files" />
      permet d'inclure le <acronym>JAR</acronym> de votre projet dans le répertoire
      <filename>lib/</filename> de l'assembly, en supprimant le numéro de version
      du nom du fichier renommé en <filename>my-app.jar</filename>. Ensuite,
      il faudrait rendre ce <acronym>JAR</acronym> lisible par tout le monde et 
      éditable par l'utilisateur qui le possède (c'est ce que le mode 0644 signifie
      pour les fichiers avec la notation de permission Unix sur quatre chiffres).
      Pour plus d'informations sur le format de la valeur de la balise 
      <sgmltag>fileMode</sgmltag>, allez consulter l'explication de Wikipédia <ulink
      url="http://en.wikipedia.org/wiki/File_system_permissions#Octal_notation_and_additional_permissions">système
      Octal de représentation des droits</ulink>.</para>

      <para>Vous pouvez construire un assembly très complexe avec ces fichiers,
      si vous connaissez la liste complète des fichiers à inclure. Même si
      vous ne connaissez pas la liste de tous les fichiers à inclure au
      lancement du build, vous pouvez très facilement utiliser un plugin
      Maven personnalisé pour produire ce descripteur d'assembly avec des
      références comme celui ci-dessus. Si la section <sgmltag>files</sgmltag>
      vous permet un contrôle très fin des permissions, de la position et du nom
      de chaque fichier dans l'archive assembly, écrire une balise
      <sgmltag>file</sgmltag> pour chaque fichier est une tâche pénible. La
      plupart du temps vous allez travailler sur des groupes de fichiers et de 
      dépendances grâce à la balise <sgmltag>fileSets</sgmltag>. Les quatre
      sections suivantes sont conçues pour vous permettre de sélectionner des
      listes de fichiers selon des critères particuliers.</para>
    </section>

    <section id="assemblies-sect-filesets">
      <title>Section <sgmltag>fileSets</sgmltag></title>

      <para>Comme pour la section <sgmltag>files</sgmltag>, les
      <sgmltag>fileSets</sgmltag> correspondent à des fichiers qui ont une
      position relative par rapport à la structure de répertoires du projet.
      Cependant, au contraire de la section <sgmltag>files</sgmltag>,
      <sgmltag>fileSets</sgmltag> décrit des ensembles de fichiers dont
      le nom et le chemin respectent (ou ne respectent pas) un certain
      format et la structure de répertoire dans laquelle ils se trouvent.
      La forme la plus simple de <sgmltag>fileSet</sgmltag> spécifie
      uniqument le répertoire où se trouvent les fichiers :</para>

      <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;fileSets&gt;
    &lt;fileSet&gt;
      &lt;directory&gt;src/main/java&lt;/directory&gt;
    &lt;/fileSet&gt;
  &lt;/fileSets&gt;
  ...
&lt;/assembly&gt;</programlisting>

      <para>Cet ensemble de fichiers contient tout le contenu du répertoire
      <filename>src/main/java</filename> de notre projet. Il profite des
      valeurs par défauts des nombreux paramètres de cette section, aussi
      regardons les brièvement.</para>

      <para>Tout d'abord, vous avez remarqué que nous n'avons pas indiqué où
      nous souhaitons mettre les fichiers à inclure dans l'assembly. Par
      défaut, le répertoire de destination (que l'on peut préciser au moyen
      de la balise <sgmltag>outputDirectory</sgmltag>) est le même que le
      répertoire source (dans notre cas, <filename>src/main/java</filename>).
      De plus, nous n'avons pas pécifier de format à respecter pour l'inclusion
      ou l'exclusion de fichiers. Dans ce cas, le comportement par défaut est
      de sélectionner tous les fichiers qui se trouvent dans le répertoire
      source avec quelques exceptions importantes. Les exceptions à cette règle sont
      surtout les fichiers et les répertoires de métadonnées des outils de gestion de
      configuration. Ces exceptions par défaut sont utilisées lorsque la balise
      <sgmltag>useDefaultExcludes</sgmltag> est à <varname>true</varname>, ce qui
      est le cas par défaut. Lorsque l'option <sgmltag>useDefaultExcludes</sgmltag>
      est activée, les répertoires tels que <filename>.svn/</filename> et
      <filename>CVS/</filename> sont exclus d'office pour l'ajout dans l'archive
      assembly. La <xref linkend="assemblies-sect-default-excludes" /> présente une
      liste détaillée des formats d'exclusion par défaut.</para>

      <para>Si vous voulons contrôler plus finement cet ensemble de 
      fichiers, vous pouvez le spécifier explicitement. L'
      <xref linkend="ex-explicit-fileSet" /> montre une balise
      <sgmltag>fileSet</sgmltag> qui spécifie toutes les valeurs par défaut.</para>

      <example id="ex-explicit-fileSet">
        <title>Inclusion de fichiers avec la balise <sgmltag>fileSet</sgmltag></title>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;fileSets&gt;
    &lt;fileSet&gt;
      &lt;directory&gt;src/main/java&lt;/directory&gt;
      &lt;outputDirectory&gt;src/main/java&lt;/outputDirectory&gt;
      &lt;includes&gt;
        &lt;include&gt;**&lt;/include&gt;
      &lt;/includes&gt;
      &lt;useDefaultExcludes&gt;true&lt;/useDefaultExcludes&gt;
      &lt;fileMode&gt;0644&lt;/fileMode&gt;
      &lt;directoryMode&gt;0755&lt;/directoryMode&gt;
    &lt;/fileSet&gt;
  &lt;/fileSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
      </example>

      <para>Les sections <sgmltag>includes</sgmltag> se composent d'une
      liste de balises <sgmltag>include</sgmltag> qui contiennent des patterns
      de chemin et de nom de fichier. Ces formats peuvent avoir un ou plusieurs
      jokers comme ‘**’ qui correspond à un ou plusieurs répertoires, ‘*’ qui
      correspond à une partie d'un nom de fichier ou ‘?’ qui remplace
      un caractère quelqconque dans un nom de fichier. L'<xref
      linkend="ex-explicit-fileSet" /> utilise une balise <sgmltag>fileMode</sgmltag>
      pour spécifier que les fichiers de ce groupe devront être lisibles par tous mais
      éditables uniquement par le propriétaire. Comme la balise <sgmltag>fileSet</sgmltag>
      peut inclure des répertoires il existe aussi la balise <sgmltag>directoryMode</sgmltag>
      pour spécifier le mode du répertoire. Elle fonctionne comme
      <sgmltag>fileMode</sgmltag>. Comme il faut avoir les droits d'exécution
      sur un répertoire pour pouvoir en lister le contenu, il faut
      s'assurer que les répertoires sont bien exécutables en plus d'être
      lisibles. Comme pour les fichiers, seul le propriétaire peut modifier
      les répertoires et leurs contenus dans ce cas.</para>

      <para>La balise <sgmltag>fileSet</sgmltag> possède des options supplémentaires.
      Premièrement, il peut contenir une balise <sgmltag>excludes</sgmltag>
      de la même forme que la balise <sgmltag>includes</sgmltag>. Les patterns
      d'exclusion vous permettent d'exclure des fichiers spécifiques d'un
      <sgmltag>fileSet</sgmltag> qui correspondent à ce modèle. Les patterns
      d'inclusion prennent le pas sur les formats d'exclusion. Vous pouvez aussi
      mettre à <varname>true</varname> l'élément <sgmltag>filtering</sgmltag> si
      vous voulez remplacer les expressions dans les fichiers inclus par les
      valeurs des propriétés. Les expressions sont délimitées soit par
      <varname>\${</varname> et <varname>}</varname> (expression standard Maven
      comme par exemple <varname>\${project.groupId}</varname>) ou par
      <varname>@</varname> suivi de <varname>@</varname> (expression standard Ant
      comme par exemple <varname>@project.groupId@</varname>). Vous pouvez
      choisir la fin de ligne dans vos fichiers grâce à la balise
      <sgmltag>lineEnding</sgmltag> ; les valeurs autorisées pour la balise
      <sgmltag>lineEnding</sgmltag> sont :</para>

      <variablelist>
        <varlistentry>
          <term>keep</term>

          <listitem>
            <para>Conserve la fin de ligne des fihiers originaux. (C'est la
            valeur par défaut).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>unix</term>

          <listitem>
            <para>Fins de ligne de type Unix</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>lf</term>

          <listitem>
            <para>Juste un caractère de nouvelle la ligne</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>dos</term>

          <listitem>
            <para>Fins de ligne de type MS-DOS</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>crlf</term>

          <listitem>
            <para>Retour à la ligne suivi du caractère Nouvelle Ligne</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Enfin, si vous voulez vous assurez que tous les éléments de sélection
      de fichier sont utilisés, vous pouvez mettre la balise 
      <sgmltag>useStrictFiltering</sgmltag> à <sgmltag>true</sgmltag>
      (la valeur par défaut est <sgmltag>false</sgmltag>). Cela peut-être très utile
      si des patterns inutilisés indiquent des fichiers manquants dans un répertoire
      intermédiaire. Lorsque la balise <sgmltag>useStrictFiltering</sgmltag> est à
      <sgmltag>true</sgmltag>, le plugin Assembly échouera si un pattern d'inclusion
      n'est pas satisfait. En d'autres termes, si vous avez un pattern d'inclusion qui
      inclut un fichier d'un build et que ce fichier est absent alors, lorsque 
      la balise <sgmltag>useStrictFiltering</sgmltag> est à <sgmltag>true</sgmltag>
      Maven fera échouer le build sil ne trouve pas le fichier à inclure.</para>

      <!--TODO: JCasey, I had to take the statement about Ant Expressions out because I couldn't verify it.
I can add this back in later.  I didn't want to talk about it without an example.  - TIM-->
    </section>

    <section id="assemblies-sect-default-excludes">
      <title>Patterns d'exclusion par défaut pour la balise
      <sgmltag>fileSets</sgmltag></title>

      <para>Quand vous utilisez les patterns d'exclusion par défaut, le plugin Maven
      Assembly va ignorer d'autres fichiers que les répertoires <acronym>SVN</acronym>
      et <acronym>CVS</acronym>. Par défaut, les patterns d'exclusion sont la classe
       <ulink
      url="http://svn.codehaus.org/plexus/plexus-utils/trunk/src/main/java/org/codehaus/plexus/util/DirectoryScanner.java">DirectoryScanner</ulink>
      du projet <ulink
      url="http://plexus.codehaus.org/plexus-utils/">plexus-utils</ulink>
      hébergé chez Codehaus. La liste des patterns d'exclusion est définie sous la forme d'un
      tableau statique <classname>String</classname> appelé <varname>DEFAULTEXCLUDES</varname>
      dans <classname>DirectoryScanner</classname>. Le contenu de cette variable est présenté
      dans <xref linkend="ex-default-excludes" />.</para>

      <example id="ex-default-excludes">
        <title>Définitions des patterns d'exclu de Plexus Utils</title>

        <programlisting language="java">   public static final String[] DEFAULTEXCLUDES = {
        // Miscellaneous typical temporary files
        "**/*~",
        "**/#*#",
        "**/.#*",
        "**/%*%",
        "**/._*",

        // CVS
        "**/CVS",
        "**/CVS/**",
        "**/.cvsignore",

        // SCCS
        "**/SCCS",
        "**/SCCS/**",

        // Visual SourceSafe
        "**/vssver.scc",

        // Subversion
        "**/.svn",
        "**/.svn/**",

        // Arch
        "**/.arch-ids",
        "**/.arch-ids/**",

        //Bazaar
        "**/.bzr",
        "**/.bzr/**",

        //SurroundSCM
        "**/.MySCMServerInfo",

        // Mac
        "**/.DS_Store"
    };</programlisting>
      </example>

      <para>Ce tableau de patterns par défaut exclut les fichiers temporaire d'
      editeurs tels que <ulink url="http://www.gnu.org/software/emacs/">GNU
      Emacs</ulink>, les fichiers temporaires les plus classqies sous Mac et
      les fichiers des outils de gestion de configuration (même si
      Visual SourceSafe est plus une malédiction qu'un outil de gestion de
      configuration). Si vous avez besoin de redéfinir ces patterns d'exclusion
      par défaut, mettez <sgmltag>useDefaultExcludes</sgmltag> à
      <varname>false</varname> et définissez votre propre lsite de patterns
      d'exclusion dans votre descripteur d'assembly.</para>
    </section>

    <section id="assemblies-sect-output-algorithm">
      <title>Section <sgmltag>dependencySets</sgmltag></title>

      <para>Une des exigences les plus demandée pour les assemblies est l'ajout
      des dépendances d'un projet dans l'archive assembly. Les balises
      <sgmltag>files</sgmltag> et <sgmltag>fileSets</sgmltag> traitent les fichiers
      de votre projet, cependant une dépendance n'est pas un fichier qui se 
      trouve dans les répertoires de votre projet. Les artefacts dont dépend 
      votre projet sont résolus par Maven lors du build. Les artefacts de 
      dépendance sont une notion abstraite, il n'ont pas un chemin bien défini
      et sont résolus en utilisant un ensemble symbolique de coordonnées Maven.
      Puisque <sgmltag>file</sgmltag> et
      <sgmltag>fileSet</sgmltag> exigent un chemin réél, les dépendances seront incluses ou
      excluses d'un assembly par une combinaison de coordonnées Maven et de scope.</para>

      <para>La forme la plus simple de la balise <sgmltag>dependencySet</sgmltag> est
      une balise vide :</para>

      <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet/&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>

      <para>La balise <sgmltag>dependencySet</sgmltag> ci-dessus va rechercher
      toutes les dépedances d'exécution de votre projet (le scope runtime scope
      inclut le contenu du scope compile implicitement), et va ensuite les ajouter
      au répertoire racine de l'archive assembly. Elle va aussi copier l'artefact
      principal de votre projet, s'il existe, dans ce répertoire racine.</para>

      <note>
        <para>Une minute ? Je pensais que la balise <sgmltag>dependencySet</sgmltag>
        gérait l'inclusion des dépendances de mon projet, pas son archive principale ?
        Cet effet secondaire non-intuitif était un bug très utilisé de la version 
        2.1 du plugin Assembly plugin, et, comme Maven accorde une très grande importance
        à la compatibilité ascendante, ce comportement non-intuitif et incorrect a du
        être présevé pour la version 2.2. Vous pouvez interdire ce comportement
        en mettant à <varname>false</varname> la balise <sgmltag>useProjectArtifact</sgmltag>.</para>
      </note>

      <para>Même si l'ensemble des dépendances par défaut peut être très utile sans
      configuration supplémentaire, cette section du descripteur d'assembly supporte
      un de nombreuses options de configuration pour vous permettre d'adapter son
      comportement à vosdemandes spécifiques. Par exemple, la première chose que 
      vous pourriez vouloir faire par rapport à cette liste de dépendances est 
      d'exclure l'artefact du projet en mettant <sgmltag>useProjectArtifact</sgmltag> 
      à <varname>false</varname> (sa valeur par défaut est à
      <varname>true</varname> pour des raisons historiques). Cela vous permettra de
      gérer le résultat du build de votre projet indépendamment des fichiers des 
      dépendances. Aussi, vous pourriez choisir de décompresser les dépendances en 
      mettant la balise <sgmltag>unpack</sgmltag> à <varname>true</varname> (elle
      est à <varname>false</varname> par défaut). Lorsque l'option unpack est activée,
      le plugin Assembly va décompressé les contenus des dépnedances dans le répetoire
      racine de l'archive.</para>

      <para>A partir maintenant, vous pouvez faire plusieurs choses avec cet
      ensemble de dépendances. Les sections qui vont suivre présentent comment
      définir l'endroit où seront enregistées ces dépendances et comment inclure
      et exclure des dépendances selon leur scope. Enfin, nous nous étendrons
      sur cette fonctionnalité de décompression des dépendances en explorant
      certaines de ses options avancées.</para>

      <section id="assemblies-sect-output-location">
        <title>Configurer l'emplacement des dépendances</title>

        <para>C'est la combinaison de deux options de configuration qui détermine
        où va se retrouver un fichier de dépendance dans l'archive assembly : 
        <sgmltag>outputDirectory</sgmltag> et <sgmltag>outputFileNameMapping</sgmltag>.
        Vous pouvez configurer l'emplacement des dépendances dans votre assembly
        selon les propriétés des artefacts des dépendances. Disons que vous voulez
        mettre toutes vos dépendances dans des répertoires qui correspondent au
        <sgmltag>groupId</sgmltag> de l'artefact. Dans ce cas, vous pouvez utiliser
        la balise <sgmltag>outputDirectory</sgmltag> sous <sgmltag>dependencySet</sgmltag>
        et lui donner pour valeur :</para>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;outputDirectory&gt;\${artifact.groupId}&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>

        <para>Cela aura pour effet de mettre chaque dépendance  dans un
        répertoire dont le nom correspond au <sgmltag>groupId</sgmltag>
        de l'artefact de chacune d'entre elles.</para>

        <para>Si vous voulez aller plus loin dans la personnalisation et que 
        vous souhaitez retirer le numéro de version de toutes les dépendances.
        Il suffit de configurer le renommage de chaque dépendance grâce à la
        balise <sgmltag>outputFileNameMapping</sgmltag> comme suit :</para>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;outputDirectory&gt;\${artifact.groupId}&lt;/outputDirectory&gt;
      &lt;outputFileNameMapping&gt;
        \${artifact.artifactId}.\${artifact.extension} 
      &lt;/outputFileNameMapping&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>

        <para>Dans l'exemple précédent, une dépendance sur
        <varname>commons:commons-codec</varname> version 1.3, se retrouverait
        dans le fichier <filename>commons/commons-codec.jar</filename>.</para>
      </section>

      <section id="assemblies-sect-interpolate">
        <title>Interpolation de propriétés pour l'emplacement des dépendances</title>

        <para>Comme nous l'avons déjà mentionné dans la 
        <xref linkend="assemblies-sect-prop-refs" /> aucun de ces éléments
        n'est interpolé avec le reste du descritpeur d'assembly. En effet,
        leurs valeurs brutes doivent être traitées par des interpréteurs
        d'expression d'artefact spécifiques.</para>

        <para>Les expressions utilisables pour ces deux ééments sont légèrement
        différentes. Les expressions <varname>\${project.*}</varname>,
        <varname>\${pom.*}</varname> et <varname>\${*}</varname> qui sont
        disponibles dans le <acronym>POM</acronym> et dans le reste du descripteur
        le sont aussi dans ces deux cas. Pour la balise <sgmltag>outputFileNameMapping</sgmltag>
        le traitement suivant est appliqué pour résoudre les expressios :</para>

        <orderedlist>
          <listitem>
            <para>Si l'expression correspond au pattern 
            <varname>\${artifact.*}</varname> :</para>

            <orderedlist numeration="loweralpha">
              <listitem>
                <para>Recherche dans l'instance <classname>Artifact</classname>
                de la dépendance (résoud :
                <varname>groupId</varname>, <varname>artifactId</varname>,
                <varname>version</varname>, <varname>baseVersion</varname>,
                <varname>scope</varname>, <varname>classifier</varname> et
                <varname>file.*</varname>)</para>
              </listitem>

              <listitem>
                <para>Recherche dans l'instance <classname>ArtifactHandler</classname>
                de la dépednace (résoud : <varname>expression</varname>)</para>
              </listitem>

              <listitem>
                <para>Recherche dans l'instance du projet associé à l'artefact
                de la dépendance (résoud : principalement les propriétés du POM)</para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>Si l'expression correspond au pattern 
            <varname>\${pom.*}</varname> or
            <varname>\${project.*}</varname>:</para>

            <orderedlist numeration="loweralpha">
              <listitem>
                <para>Recherche dans l'instance du projet
                (<classname>MavenProject</classname>) du build en cours.</para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>Si l'expression correspond au pattern
            <varname>\${dashClassifier?}</varname> et que l'instance 
            <classname>Artifact</classname> de la dépendance a un classifier,
            résoud jusqu'au classfier précédé d'un tiret (-classifier).
            Sinon résoud comme étant une chaine vide.</para>
          </listitem>

          <listitem>
            <para>Essaye de résoudre l'expression avec l'instance du
            projet du build en cours.</para>
          </listitem>

          <listitem>
            <para>Essaye de résoudre l'expression avec les propriétés du
            POM du build en cours.</para>
          </listitem>

          <listitem>
            <para>Essaye de résoudre l'expression avec les propriétés
            système disponibles.</para>
          </listitem>

          <listitem>
            <para>Essaye de résoudre l'expression avec les variables
            d'environnement du système d'exploitation.</para>
          </listitem>
        </orderedlist>

        <para>La valeur de la balise <sgmltag>outputDirectory</sgmltag> est
        interpolée de manière assez proche, à la différence près qu'il n'y a
        pas dinformation du type <varname>\${artifact.*}</varname> disponible.
        Seules les instances <varname>\${project.*}</varname> des artefacts
        permettent de résoudre les expressions. Donc les expressions associées
        à ces patterns ne sont pas disponibles (il s'agit des éléments
        (1a, 1b, et 3 de la liste ci-dessus).</para>

        <para>Comment sait-on quand utiliser <sgmltag>outputDirectory</sgmltag>
        et <sgmltag>outputFileNameMapping</sgmltag> ? Quand les dépendances
        sont décompressées, seul l'<sgmltag>outputDirectory</sgmltag> est
        utilisé pour calculer l'emplacement final. Quand les dépendances sont gérées
        comme un tout (c'est à dire non décompressées), les deux éléments
        <sgmltag>outputDirectory</sgmltag> et <sgmltag>outputFileNameMapping</sgmltag>
        peuvent être utilisés ensemble. Quand ilsl le sont, le résultat est
        équivalent à :</para>

        <programlisting language="xml">&lt;archive-root-dir&gt;/&lt;outputDirectory&gt;/&lt;outputFileNameMapping&gt;</programlisting>

        <para>Quand l'<sgmltag>outputDirectory</sgmltag> est absent, il n'est pas
        utilisé. Quand c'est l'<sgmltag>outputFileNameMapping</sgmltag> qui est
        absent, on prend sa valeur par défaut qui est :
        <code>\${artifact.artifactId}-\${artifact.version}\${dashClassifier?}.\${artifact.extension}</code></para>
      </section>

      <section id="assemblies-sect-include-by-scope">
        <title>Inclusion et exclusion de dépendancs par scope</title>

        <para>Dans la <xref
        linkend="pom-relationships-sect-project-dependencies" />, nous avons
        noté que toutes les dépendances d'un projet ont un scope. Le scope
        détermine le moment où une dépendance sera utilisée au cours du 
        processus de build. Par exemple, les dépendances dans le scope 
        <varname>test</varname> ne font pas partie du classpath au moment
        de la compilation du code source du projet ; par contre elles font 
        partie du classpath de compilation des tests unitaires. Cela parce
        que le code source de votre projet ne devrait pas contenir du code
        spécifique pour les tests car tester n'est pas une des fonctions de
        votre projet (c'est une fonction du processus de build du projet).
        De même, les dépendances dans le scope <varname>provided</varname>
        doivent être présentes dans l'environnement où sera déployé le 
        projet. Cependant, si un projet dépend d'une dépendance
        <varname>provided</varname> particulière, il est possible qu'il ait
        besoin de celle-ci pour compiler. C'est pour cette raison que
        les dépendances du scope <varname>provided</varname> sont présentes
        dans le classpath de compilation mais qu'elles ne sont pas empaquetées
        avec l'artefact ou un assembly du projet.</para>

        <para>Dans cette même <xref
        linkend="pom-relationships-sect-project-dependencies" />, nous avions
        vu que les scopes de dépendances en induisent d'autres. Par exemple,
        le scope de dépendance <varname>runtime</varname> inclus les
        dépendances du scope <varname>compile</varname>, car toutes les
        dépendances utilisées au moment de la compilation (sauf celles du scope
        <varname>provided</varname>) seront nécessaires pour l'exécution du code.
        Les manières dont un scope d'une dépendance directe affecte le scope
        des dépendances transitives sont très complexes. Dans un descripteur
        d'assembly Maven, nous pouvons utiliser les scopes pour filtrer des
        ensemble de dépendances et leurs appliquer diffrents traitements.</para>

        <para>Par exemple, si nous projetons de packager une application web
        avec <ulink url="http://www.mortbay.org/jetty-6/">Jetty</ulink> pour
        créer une application autonome, nous allons devoir inclure toutes
        les dépendances du scope provided quelque par dans les répertoires
        du Jetty que nous incluons. Cela nous assurera que ces dépendances
        provided sont effectivement présentes dans l'environnement d'exécution.
        Les dépendances d'exécution qui ne font pas partie du scope
        <varname>provided</varname> continuent à aller dans le répertoire
        <filename>WEB-INF/lib</filename>, donc ces deux ensembles de dépendances
        doivent être traités distinctement. Ces blocs de dpéendances
        ressemblent au dcument XML qui suit.</para>

        <example>
          <title>Definition de blocs de dépendances par l'utilisation des scopes</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
      &lt;outputDirectory&gt;lib/\${project.artifactId}&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/\${webContextName}/WEB-INF/lib
      &lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Les dépendances du scope <varname>provided</varname> sont ajoutées
        au répertoire <filename>lib/</filename> à la racine de l'assembly, ce
        répertoire  va contenir l'ensemble des bibliothèques qui seront incluses 
        dans le classpath global d'exécution de Jetty. Nous utilisons un
        sous-répertoire dont le nom est l'<varname>artifactId</varname> du projet
        pour retrouver plus facilement d'où vient une bibliothèque particulière. Les
        dépendances d'exécution sont incluses dans le répertoire 
        <filename>WEB-INF/lib</filename> de l'application web, qui se trouve dans
        le sous-répertoire standard de Jetty <filename>webapps/</filename>
        et dont le nom est donné par une configuration de la propriété 
        <varname>webContextName</varname> du <acronym>POM</acronym>.
        Ce que nous venons de faire dans cet exemple est de séparer les
        dépendances spécifiques à l'application de celles qui sont
        présentes dans le classpath global d'un conteneur de servlets.</para>

        <para>Cependant, séparer en ne tenant compet que du scope peut s'avérer
        insuffisant, notamment dans le cas d'applications web. Il est
        tout à fait concevable qu'une ou plusieurs des dépendances pour
        l'exécution soient un assemblage de resurces standardisées et
        non-compilées qui seront utilisées par l'application web. Par
        exemple nous pourrions avoir un ensemble d'applications qui
        réutiliseraient le même ensemble de fichiers de Javascript,
        CSS, SWF et d'image. Pour faciliter la standardisation de ces ressources,
        une bonne pratique consiste à les mettre dans une archive et de les
        déployer sur un dépôt Maven. A partir de ce moment là, elles peuvent
        petre référencées comme une dépendance Maven standard - éventuellement
        avec une dépendance de type <varname>zip</varname> - normalement dans
        le scope  <varname>runtime</varname>. Souvenez-vous qu'il s'agit de
        ressources et non d'une dépendance  du code de l'application vers un
        binaire ; et donc il n'est pas approprié de les inclure dans le répertoire
        <filename>WEB-INF/lib</filename>. Ces archives de ressources doivent
        être séparées des dépendances binaires d'exécution et décompressées 
        à la racine de l'application web. Pour pouvoir effectuer ce type de
        séparation nous allons utiliser les patterns d'inclusion et d'exclusion
        qui se basent sur les coordonnées d'une dépendance.</para>

        <para>En d'autres termes, nous allons supposer que vous avez trois ou 
        quatre applications web qui réutilisent les mêmes ressources et que 
        vous voulez créer un  assembly qui met les dépendances du scope 
        <varname>provided</varname> dans le répertoire <filename>lib/</filename>,
        les dépendances du scope <varname>runtime</varname> dans
        <filename>webapps/&lt;contextName&gt;/WEB-INF/lib</filename>
        et enfin décompresse une dépendance d'exécution spécifique à la racine de votre
        application web. Vous pouvez faire tout ça car le plugin Assembly 
        vous permet de définir plusieurs patterns d'inclusion et d'exclusion
        pour un même élément <sgmltag>dependencySet</sgmltag>. Dans la prochaine section
        nous allons essayer de développer cette idée.</para>
      </section>

      <!-- ***************** Erwan > DEBUT DE MA PARTIE ******************** -->

      <section id="assemblies-sect-fine-tune">
        <title>Configuration fine : inclusion et exclusion de dépendances</title>

        <para>Une dépendance de ressources peut être une simple liste de ressources (CSS, Javascript, images ...) dans un projet
        qui a une assembly qui crée une archive <acronym>ZIP</acronym>.
        En fonction des particularités de votre application web,
        vous voudrez distinguer les dépendances de ressources des dépendances de binaires en fonction de leur type.
        La plupart des applications web vont dépendre d'autres dépendances de type <varname>jar</varname>, 
        du coup, il est possible de dire avec certitude que toutes les dépendances de type <varname>zip</varname> sont des dépendances de ressources.
        Ou, nous pourrions avoir une situation où les ressources sont conservées sous un format <varname>jar</varname> mais 
        que nous pouvons distinguer les ressources par un tag <varname>resources</varname>.
        Dans tous les cas, nous pouvons spécifier un pattern d'inclusion pour cibler ces dépendances de ressources
        et appliquer une logique différente que celle utilisée pour les binaires. 
        Nous pouvons effectue cette distinction par l'intermédiaire de balises <sgmltag>includes</sgmltag> et <sgmltag>excludes</sgmltag> 
        dans le <sgmltag>dependencySet</sgmltag>.</para>

        <para>Les balises <sgmltag>includes</sgmltag> et <sgmltag>excludes</sgmltag> sont des listes, 
        cela veut dire qu'elles acceptent des sous éléments du type <sgmltag>include</sgmltag> et <sgmltag>exclude</sgmltag>.
        Chaque balise <sgmltag>include</sgmltag> ou <sgmltag>exclude</sgmltag> contient une valeur sous forme de chaîne de caractère, celles-ci pouvant contenir des wildcards.
        Chaque valeur peut matcher des dépendances selon différents moyens.         
        Généralement, trois formats de pattern sont supportés :</para>

        <variablelist>
          <varlistentry>
            <term><varname>groupId:artifactId</varname> - sans la version</term>

            <listitem>
              <para>Utilisez ce pattern pour trouver des dépendances par <varname>groupId</varname> et <varname>artifactId</varname></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><varname>groupId:artifactId:type[:classifier]</varname> - id de conflit</term>

            <listitem>
              <para>Ce pattern vous permet de fournir un ensemble plus large de coordonnées pour créer des patterns include/exclude plus spécifiques.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><varname>groupId:artifactId:type[:classifier]:version</varname> - identité complète de l'artefact</term>

            <listitem>
              <para>Si vous avez un récupérer un artefact bien spécifique, vous pouvez renseigner l'intégralité des coordonnées.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Tous ces formats de patterns supportent l'utilisation de widcard ‘*’, 
        ils permettent de matcher n'importe quelle sous-section de l'identité et n'est pas limitée à une seule sous-section (sections entre ':').         
        En outre, notez que la section classificateur ci-dessus est facultative,
        le pattern matching des dépendances qui n'ont pas de classificateur ne prennent pas en compte la section 'classificateur' de ce pattern.</para>

        <para>Dans l'exemple donné ci-dessus, là où la distinction essentielle est l'artefact de type sip et qu'aucune des dépendances n'a de classificateur,
        le pattern suivant matcherait toutes les ressources de type <varname>zip</varname> :</para> 

        <programlisting>*:zip</programlisting>

        <para>Le pattern ci-dessus utilise la seconde identité de la dépendance : l'id de conflit.
        Maintenant que nous avons un pattern qui distingue les dépendances ressources des binaires, 
        nous pouvons modifier notre liste de dépendances pour gérer les archives différemment :</para>  

        <example id="ex-complex-dependencySet">
          <title>Utilisation des l'inclusion et d'exclusion de dépendances dans le <sgmltag>dependencySets</sgmltag></title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
      &lt;outputDirectory&gt;lib/\${project.artifactId}&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/\${webContextName}/WEB-INF/lib
      &lt;/outputDirectory&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;*:zip&lt;/exclude&gt;
      &lt;/excludes&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/\${webContextName}/resources
      &lt;/outputDirectory&gt;
      &lt;includes&gt;
        &lt;include&gt;*:zip&lt;/include&gt;
      &lt;/includes&gt;
      &lt;unpack&gt;true&lt;/unpack&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Dans l'<xref linkend="ex-complex-dependencySet" />, 
        la liste de dépendances scopée <varname>runtime</varname> de notre dernier exemple à été mis à jour pour exclure les dépendances de type ressource.
        Seules les dépendances de type binaire (les dépendances qui ne sont pas de ZIP) sont ajoutées dans le répertoire <filename>WEB-INF/lib</filename> de l'application. 
        Les dépendances de type ressource sont rassemblées dans une même liste,        
        celle-ci est configurée pour copier ses dépendances dans le répertoire ressource de l'application.
        La balise <sgmltag>includes</sgmltag> du dernier <sgmltag>dependencySet</sgmltag> annule les exclusions du <sgmltag>dependencySet</sgmltag> précédent.
        Ainsi, les dépendances ressources sont incluses en utilisant un seul pattern d'identité : <varname>*:zip</varname>.
        La dernière balise <sgmltag>dependencySet</sgmltag> fait référence à des ressources partagées et est configurée pour deziper celles-ci à la racine de l'application web.</para>

        <para>L'<xref linkend="ex-complex-dependencySet" /> présume que le projet contenant les ressources partagées a un type différent des autres dépendances. 
        Que se passerait-il si celle-ci avait le même type que celui des autres dépendances ?
        Comment différencieriez-vous cette dépendance ?
        Dans ce cas, si une dépendance de ressources partagées a été packagée comme un JAR avec le classificateur de type <varname>resources</varname>,  
        vous pouvez changer le pattern d'identité pour qu'il match ces dépendances :</para> 

        <programlisting>*:jar:resources</programlisting>

        <para>Au lieu de matcher les artefacts de type <varname>zip</varname> sans classificateur,
        nous matchons ici les artefacts de type <varname>jar</varname> qui possède un classificateur <varname>resources</varname>.</para>   

        <para>Comme pour la section <sgmltag>fileSets</sgmltag>, <sgmltag>dependencySets</sgmltag> supporte l'utilisation du flag <sgmltag>useStrictFiltering</sgmltag>. 
        Lorsque celui-ci est activé, n'importe quel pattern qui ne match pas une ou plusieurs dépendances causera l'échec de l'assembly, et donc par conséquent, du build.  
        Très pratique pour utiliser comment soupape de sécurité, pour vous assurer que les dépendances de votre projet et votre descripteur d'assembly soient correctement synchronisés.  
        Par défaut, ce flag est désactivé pour des raisons de rétrocompatibilité.</para> 
      </section>

      <section id="assemblies-sect-transitive">
        <title>Dépendances transitives, pièces jointes et artefacts de projet</title>

        <para>La section <sgmltag>dependencySet</sgmltag> vous propose deux autres mécanismes pour vous aider dans le choix de vos artefacts :  
        options de sélection transitive et options pour travailler avec des artefacts du projet.
        Ces deux fonctionnalités proviennent de la nécessité de supporter des configurations existantes qui utilisent une définition un peu plus libérale du mot «dépendance». 
        Comme premier exemple, examinons l'artefact principal du projet.
        Typiquement, dans la majorité des cas, il ne doit pas être considéré comme une dépendance.
        Pourtant, les plus anciennes versions du plugin Assembly l'utilisaient dans le calcul des dépendances.
        Pour fournir une rétrocompatibilité avec cette “fonctionnalité”,
        la version 2.2 du plugin Assembly dispose d'un flag à mettre dans le <sgmltag>dependencySet</sgmltag>, celui-ci est appelé <sgmltag>useProjectArtifact</sgmltag>,
        La valeur par défaut de ce flag est <varname>true</varname>. 
        Par défaut, le set de dépendances essayera d'inclure l'artefact du projet dans le calcul de ses dépendances.  
        Si vous préférez gérer l'artefact du projet séparément, affectez ce flag à <varname>false</varname>.</para>

        <tip>
          <para>Les auteurs de ce livre vous recommandent de toujours laisser le flag
          <sgmltag>useProjectArtifact</sgmltag> à <varname>false</varname>.</para>
        </tip>

        <para>Comme extension naturelle à l'inclusion d'un artefact projet, 
        les artefacts rattachés à un projet peuvent également être gérés par un  <sgmltag>dependencySet</sgmltag> en utilisant
        le flag <sgmltag>useProjectAttachments</sgmltag> (celui-ci est désactivé par défaut). 
        Activer ce flag permet aux patterns qui précisent des classificateurs et des types d'artefacts de matcher les artefacts rattachés.
        Ils partagent la même identité <varname>groupId</varname>/<varname>artifactId</varname>/<varname>version</varname>,
        mais diffèrent de <varname>type</varname> et de <varname>classifier</varname>.
        Cette fonctionnalité peut s'avérer utilise pour inclure les JARs de Javadoc ou de Source dans une assembly.</para>

        <para>En plus de traiter avec des artefacts du projet,
        il est également possible de configurer un set de dépendances en utilisant deux flags permettant d'activer la résolution transitive.
        Le premier, appelé <sgmltag>useTransitiveDependencies</sgmltag> (et activé par défaut), permet d'activer l'inclusion des dépendances transitives lors du matching.
        Comme exemple pour savoir comment il peut être utilisé, considérer ce qui arrive lorsque votre <acronym>POM</acronym> à une dépendance sur une autre assembly.
        Cette assembly aura (probablement) un classificateur qui le sépare de l'artefact principal du projet, ce qui en fait une pièce jointe.    
        Cependant, une particularité du processus de résolution des dépendances Maven que les informations des dépendances transitives pour l'artefact principal
        sont toujours utilisées pour résoudre l'artefact de l'assembly.
        Si l'assembly package ses dépendances à l'intérieur de lui-même, 
        dans ce cas, utiliser la résolution des dépendances transitives dupliquerait effectivement ces dépendances.         
        Pour éviter cela, nous pouvons simplement affecter le flag <sgmltag>useTransitiveDependencies</sgmltag> à <varname>false</varname>.</para>

        <para>L'autre flag permettant de résoudre les dépedances dépendances est plus subtil.
        Il est appelé <sgmltag>useTransitiveFiltering</sgmltag> et sa valeur par défaut est <varname>false</varname>.
        Pour comprendre ce que fait ce flag, nous devons d'abord comprendre quelles informations sont disponibles pour un artefact donné lors du processus de résolution des dépendances. 
        Quand un artefact est une dépendance d'un autre (qui est, retiré au moins un niveau à partir de votre <acronym>POM</acronym>),
        elle a ce que Maven appelle un "chemin de dépendances", laquelle est maintenue comme une liste de chaînes de caractère et correspond à l'identité complète de l'artefact 
        (<varname>groupId:artifactId:type:[classifier:]version</varname>)
        de toutes les dépendances entre votre <acronym>POM</acronym> et l'artefact a qui appartient ce chemin.
        Si vous vous rappelez des trois types d'identités des artefacts disponibles pour pattern matching,
        vous remarquerez que les entrées dans ce chemin de dépendances - l'identité complète de l'artefact  - correspond au troisième type.
        Lorsque le flag <sgmltag>useTransitiveFiltering</sgmltag> est affecté à <varname>true</varname>, 
        toutes les entrées du chemin de dépendances d'un artefact peuvent agir sur l'inclusion ou l'exclusion de cet artefact.</para>

        <para>Si vous considérez l'utisation de ce filtrage transitif, prennez garde !
        Un artefact peut être inclus à partie de nombreux emplacement dans un graphe de dépendance, mais dans Maven 2.0.9,
        seul le premier chemin de dépendances est utilisé pour ce type de matching.
        Cela peut conduire à des problèmes subtils dans la collecte des dépendances de votre projet.</para>

        <warning>
          <para>La plupart des assembly ne nécessitent ce niveau de contrôle sur les sets de dépendances,
          reflechissez attentivement pour savoir si la vôtre en a vraiment besoin. Astuce : ce n'est probablement pas le cas.</para>
        </warning>
      </section>

      <section id="assemblies-sect-unpack">
        <title>Options avancées de dépaquetage</title>

        <para>Comme discuté précédemment, certaines dépendances de projet ont besoin d'être dézippées pour créer une assembly.
        Dans les exemples ci-dessus, la décision de dézipper ou non était simple.
        Il ne tient pas compte de ce qui doit être dépaqueté, ou plus important, de ce qui ne doit pas être dépaqueté. 
        Pour obtenir plus de contrôle sur le processus de dépaquetage,
        vous pouvez configurer la balise <sgmltag>unpackOptions</sgmltag> dans votre <sgmltag>dependencySet</sgmltag>.
        Ainsi, vous avez la possibilité de choisir quels fichiers vous voulez inclure dans votre assembly,
        et quels fichiers doivent être filtrés pour résoudre des expressions à partir des informations du <acronym>POM</acronym>.
        En fait, les options disponibles pour dépaqueter vos sets de dépendances sont similaires à celles disponibles pour l'inclusion ou l'exclusion de fichier.</para>

        <para>Pour continuer notre exemple d'application web,
        supposons que certaines dépendances de ressources aient été zippées avec un fichier qui décrit les détails de leur licence de distribution.
        Dans le cas de notre application web,
        ces licences se présenteront sous la forme d'un fichier <filename>NOTICES</filename> inclu dans notre paquetage.
        Pour exclure ce fichier, ajoutons-le simplement aux options de dépaquetage dans le set des dépendances qui gère les artefacts de ressources :</para> 

        <example>
          <title>Exclusion de fichiers dans le dépaquetage d'une dépendance</title>

          <programlisting language="xml">&lt;asembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/\${webContextName}/resources
      &lt;/outputDirectory&gt;
      &lt;includes&gt;
        &lt;include&gt;*:zip&lt;/include&gt;
      &lt;/includes&gt;
      &lt;unpack&gt;true&lt;/unpack&gt;
      &lt;unpackOptions&gt;
        &lt;excludes&gt;
          &lt;exclude&gt;**/LICENSE*&lt;/exclude&gt;
        &lt;/excludes&gt;
      &lt;/unpackOptions&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Notez que le tag <sgmltag>exclude</sgmltag> que nous utilisons ressemble beaucoup à celui de la déclaration du <sgmltag>fileSet</sgmltag>.  
        Ici, nous interdisons les fichiers qui commencent par le mot <filename>LICENSE</filename> dans les répertoires de nos artefacts de ressources.
        Vous pouvez comparer la section des options de dépaquetage à un petit <sgmltag>fileSet</sgmltag> appliqué à chaque dépendance qui match ce set.
        En d'autres mots, il s'agit d'un <sgmltag>fileSet</sgmltag> utilisé pour le dépaquetage des dépendances.
        Tout comme nous avons spécifié un modèle d'exclusion pour les dossiers dans les dépendances de ressources afin de bloquer certains fichiers,
        vous pouvez également choisir un ensemble restreint de fichiers à inclure en utilisant la section <varname>includes</varname>.
        Le même code que celui du processus d'inclusion et d'exclusion des <sgmltag>fileSets</sgmltag> peut-être réutilisé pour le traitement des <sgmltag>unpackOptions</sgmltag>.</para>

        <para>En plus de mécanisme d'inclusion et d'exclusion,
        les options de dépaquetages sur un set de dépendances peuvent également fournir un flag <sgmltag>filtering</sgmltag>,
        par défaut sa valeur est <varname>false</varname>.
        Encore une fois, cela ressemble beaucoup au mécanisme proposé par les sets de fichiers discuté ci-dessus.
        Les expressions peuvent utiliser soit la syntaxe Maven d'une <varname>\${property}</varname>, soit la syntaxe Ant d'une <varname>@property@</varname>.
        Le filtrage des ressources est particulièrement intéressant pour les sets de dépendances.        
        Car elle permet de créer des templates ressources normalisés et versionnés qui peuvent être personnalisés pour chaque assembly dans lequel ils sont inclus.
        Une fois que vous maîtrisez la fonctionnalité de filtrage, que vous avez dépaqueté les dépendances qui sont stockées dans des ressources partagées,
        vous serez en mesure de commencer à abstraire certaines ressources répétées.</para>
      </section>

      <section id="assemblies-sect-summarizing">
        <title>Résumer les sets de dépendances</title>

        <para>Au final, il est important de mentionner que les sets de dépendances supportent les mêmes options de configuration <sgmltag>fileMode</sgmltag> et <sgmltag>directoryMode</sgmltag> que celles des sets de fichiers.
        Cependant, vous devrez vous rappeler que le <sgmltag>directoryMode</sgmltag> ne sera utilisé que si les dépendances sont dépaquetées.</para>
      </section>
    </section>

    <section id="assemblies-sect-modulesets">
      <title>Balise <sgmltag>moduleSets</sgmltag></title>

      <para>Les builds multimodule sont généralement rassemblés ensemble en utilisant les balises <varname>parent</varname> et <varname>modules</varname> dans les <acronym>POM</acronym>s. 
      Typiquement, les <acronym>POM</acronym>s parents spécifient leurs fils dans une section <sgmltag>modules</sgmltag>,
      qui, en temps normal, aura pour effet de les inclure dans la procédure de build du projet parent.   
      La relation entre ses deux projets, et comment elle a été contruite, peut avoir des implications importantes dans manière dont le plugin Assembly participe à ce processus, mais nous en discuterons plus tard.
      Pour l'instant, contentons-nous de garder à l'esprit la relation parent-module telle que nous l'avions vu dans la section <sgmltag>moduleSets</sgmltag>.</para>  

      <!--TODO: I think we need a simple example of how/why this would be used.-->

      <para>Les projets sont construits sous la forme d'un projet multimodule parce qu'ils font partie d'un système plus vaste.
      Ces projets sont conçus pour être utilisés ensemble, un module unique dans un grand build n'a peu de valeur en lui-même.
      De cette façon, la structure du build du projet est liée à la façon dont nous espérons que ce projet (et ses modules) soit utilisé.
      Si vous considérez le projet du point de vue de l'utilisateur, 
      il semble logique que l'objectif final de ce build soit de construire et distribuer un seul fichier que les utilisateurs pourront directement déployer sans trop de tracas. 
      Comme les builds multimodule Maven s'appuient habituellement sur une structure top-down,
      où des informations de dépendances, des configurations de plugin et bien d'autres informations sont hérités du projet parent à l'enfant,
      il semble naturel que la tâche de transformation de ces modules dans un fichier unique distribuable doive incomber au projet le plus haut dans la hiérarchie.
      Voilà où la balise <sgmltag>moduleSet</sgmltag> intervient.</para>

      <para>Les sets de modules permettent l'inclusion de ressources dans l'assembly final, celles-ci dépendent de chaque module dans la structure du projet. 
      Tout comme vous pouvez choisir un groupe de fichiers à inclure dans un assembly en utilisant les balises <sgmltag>fileSet</sgmltag> et <sgmltag>dependencySet</sgmltag>,
      vous pouvez inclure un set de fichier et de ressources en utilisant un <sgmltag>moduleSet</sgmltag> pour se référer aux modules d'un build multimodule.
      Cela est rendu possible grâce aux deux types d'inclusion spécifique aux modules : l'un basé sur les fichiers, l'autre sur les artefacts. 
      Avant d'entrer dans les particularités ces deux types d'inclusion de modules ressources dans une assembly,
      parlons un peu de comment sélectionner les modules à traiter.</para>

      <section id="assemblies-sect-module-selection">
        <title>Sélection des modules</title>

        <para>Maintenant, vous devriez commencer à maîtriser les patterns <sgmltag>includes</sgmltag>/<sgmltag>excludes</sgmltag>, ils sont également utilisés dans les descripteurs d'essembly pour filter les fichiers et les dépendances. 
        Dans un descripteur d'un assembly, lorsque vous faites référence à des modules, vous pouvez également utiliser ces patterns <sgmltag>includes</sgmltag>/<sgmltag>excludes</sgmltag> 
        pour définir les règles qui s'appliquent sur différents sets de modules. 
        La particularité des partterns <sgmltag>includes</sgmltag> et <sgmltag>excludes</sgmltag> d'un <sgmltag>moduleSet</sgmltag> est qu'ils ne permettent pas d'utiliser de wildcards. 
        (du moins dans Maven 2.2-beta-2, cette fonctionnalité n'a pas été beaucoup demandée, elle n'a donc pas été implémentée.)
        À la place de cela, chaque balise <varname>include</varname> et <varname>exclude</varname> correspond simplement au <varname>groupId</varname> et à l'<varname>artifactId</varname> du module, séparé par un caractère ':', comme ceci :</para>   

        <programlisting>groupId:artifactId</programlisting>

        <para>En plus des balises <sgmltag>includes</sgmltag> et <sgmltag>excludes</sgmltag>,
        le <sgmltag>moduleSet</sgmltag> propose d'autres outils de sélection : 
        le flag <sgmltag>includeSubModules</sgmltag> (dont la valeur par défaut est <varname>true</varname>).
        La relation parent-enfant d'une structure multimodule n'est pas limitée à deux tiers d'un projet. 
        En fait, vous pouvez inclure n'importe quel nombre de tiers, ou de couche, dans votre build. 
        Chaque projet qui est un module du module du projet courant est considéré comme un sous-module.
        Dans certains cas, vous souhaitez construire chaque module séparément (y compris les sous-modules).
        Pour cela, affectez simplement la valeur du flag <sgmltag>useSubModules</sgmltag> à <varname>true</varname>.</para>

        <para>Lorsque vous essayez d'inclure des fichiers dans une structure de répertoires de chaque module, 
        vous souhaitez déclarer cette structure de répertoire une seule fois. 
        Si votre structure de répertoire du projet reflète celle des relations du module parent qui sont inclus dans les <acronym>POM</acronym>s, 
        cette approche permet aux patterns de fichiers comme <varname>**/src/main/java</varname> de s'appliquer non seulement aux répertoires directs de ce module, 
        mais également pour les répertoires de ses propres modules.
        Dans le cas ou ne voudriez pas traiter les sous-modules directement 
        (ils seront traités à la place comme des sous-répertoires dans les modules de votre projet),
        affectez la valeur du flag <sgmltag>useSubModules</sgmltag> à <varname>false</varname>.</para>

        <para>Une fois que nous avons déterminé comment la sélection module doit s'exécuter sur l'ensemble des modules, 
        nous sommes prêts à choisir ce qu'ils doivent contenir.
        Comme mentionné ci-dessus, il est possible d'inclure des fichiers ou des artefacts provenant du module du projet.</para>
        
      </section>

      <section id="assemblies-sect-sources-section">
        <title>Balise <varname>sources</varname></title>

        <para>Supposez que vous désirez inclure les sources de tous les modules dans votre assembly, mais que vous voulez exclure un module en particulier.
        Peut-être avec vous un projet appelé <varname>secret-sauce</varname> qui contient du code secret et sensible que vous ne voulez pas distribuer dans votre projet.
        Le moyen le plus simple d'effectuer cela est d'utiliser la balise <sgmltag>moduleSet</sgmltag> qui inclus chaque répertoire d'un projet 
        dans <varname>\${module.basedir.name}</varname> et qui exclu le module <varname>secret-sauce</varname> de l'assembly.</para>

        <example id="ex-include-exclude-moduleSet">
          <title>Inclusion et exclusion de modules dans un <sgmltag>moduleSet</sgmltag></title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;includeSubModules&gt;false&lt;/includeSubModules&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;
          com.mycompany.application:secret-sauce
        &lt;/exclude&gt;
      &lt;/excludes&gt;
      &lt;sources&gt;
        &lt;outputDirectoryMapping&gt;
          \${module.basedir.name}
        &lt;/outputDirectoryMapping&gt;
        &lt;excludeSubModuleDirectories&gt;
          false
        &lt;/excludeSubModuleDirectories&gt;
        &lt;fileSets&gt;
          &lt;fileSet&gt;
            &lt;directory&gt;/&lt;/directory&gt;
            &lt;excludes&gt;
              &lt;exclude&gt;**/target&lt;/exclude&gt;
            &lt;/excludes&gt;
          &lt;/fileSet&gt;
        &lt;/fileSets&gt;
      &lt;/sources&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Dans l'<xref linkend="ex-include-exclude-moduleSet" />,
        puisque nous devons gérer les sources de chaque module,
        il est plus simple de traiter seulement les modules directs du projet en cours,
        en manipulant les sous-modules avec le widlcard chemin/fichier. 
        Renseignez l'élément <sgmltag>includeSubModules</sgmltag> à <varname>false</varname>.
        Ainsi, nous n'avons donc pas à nous soucier de sous-modules qui apparaissent dans le répertoire racine de l'archive d'assemblage.
        La balise <sgmltag>exclude</sgmltag> s'occupera d'exclure votre module secret <varname>secret-sauce</varname>.</para>

        <para>Normalement, les sources du module sont incluses dans l'assembly dans un sous-répertoire qui est nommé âpres <varname>artifactId</varname> du module.  
        Toutefois, comme Maven permet aux modules qui ne sont pas dans des répertoires nommés d'après l'<varname>artifactId</varname> du module du projet,
        il est souvent préférable d'utiliser une expression <varname>\${module.basedir.name}</varname> pour préserver le nom du répertoire du module courant.
        (<varname>\${module.basedir.name}</varname> revient au même que d'appeler la méthode  <methodname>MavenProject.getBasedir().getName()</methodname>).
        Il est important de se rappeler que les modules qui ne sont pas nécessairement des sous-répertoires du projet qui les déclare.
        Si votre projet possède une structure particulièrement étrange, 
        vous pouvez avoir besoin de recourir à la déclaration de balises <sgmltag>moduleSet</sgmltag> spéciales 
        qui sauront comprendre et tenir compte des particularités de votre projet.</para>    

        <warning>
          <para>Pour essayer de minimiser les particularités votre projet, comme Maven est flexible,
          si vous vous prenez à faire trop de configuration,c'est qu'il y a probablement un moyen plus facile d'y arriver.</para>
        </warning>

        <para>Continuons à parcourir l'<xref linkend="ex-include-exclude-moduleSet" />, 
        since we’re not processing sub-modules explicitly in this module set, 
        we need to make sure sub-module directories are not excluded from the source directories we consider for each direct module. 
        By setting the <sgmltag>excludeSubModuleDirectories</sgmltag> flag to <varname>false</varname>, 
        this allows us to apply the same file pattern to directory structures within a sub-module of the one we’re processing. 
        Finally in <xref linkend="ex-include-exclude-moduleSet" />, 
        we’re not interested in any output of the build process for this module set. We exclude the target/ directory from all modules.</para>

        <para>Ca vaut également le coup de mentionner que la balise <sgmltag>sources</sgmltag> supporte les éléments du type <sgmltag>fileSet</sgmltag> directement dans celle-ci ou dans ses sous-balises imbriquées.    
        Ces balises de configuration sont utilisées pour fournir une rétrocompatibilité avec les anciennes versions du plugin Assembly (versions 2.1 et précédentes)
        qui ne prenaient pas en charge plusieurs sets fichiers pour un même module sans créer de <varname>modulesSet</varname> séparés.
        Elles sont dépréciées, vous ne devez pas les utiliser.</para>

      </section>

      <section id="assemblies-sect-interpolate-modulesets">
        <title>Interpolation de l'<sgmltag>outputDirectoryMapping</sgmltag> dans les <sgmltag>moduleSets</sgmltag></title>

        <para>Dans l'<xref linkend="assemblies-sect-output-location" />, 
        nous avons utilisé la balise <sgmltag>outputDirectoryMapping</sgmltag> pour changer le nom du répertoire sous lequel est inclue chaque source des modules. 
        Les expressions contenues dans cette balise sont résolues exactement de la même manière que celles de la balise <sgmltag>outputFileNameMapping</sgmltag>,
        qui utilisait des sets de dépendances (référez-vous à l'explication de cet algorithme dans la section <xref linkend="assemblies-sect-output-algorithm" />).</para>

        <para>Dans l'<xref linkend="ex-include-exclude-moduleSet" />, vous avons utilisé l'expression <varname>\${module.basedir.name}</varname>. 
        Vous avez peut-être remarqué que le début de cette expression, <varname>module</varname>,
        n'est pas listé dans l'algorithme de résolution des mappings de la section <xref linkend="assemblies-sect-output-algorithm" />.
        Cet objet root est spécifique à la configuration des <sgmltag>moduleSets</sgmltag>.
        Il fonctionne de la même manière que les réléférences à <varname>\${artifact.*}</varname> disponible dans la balise <sgmltag>outputFileNameMapping</sgmltag>,
        à l'exception qu'il s'applique aux instances <classname>MavenProject</classname>, <classname>Artifact</classname> et <classname>ArtifactHandler</classname> du module
        au lieu de celles d'un artefact de dépendance.</para>
      </section>

      <section id="assemblies-sect-binaries">
        <title>Balise <varname>binaries</varname></title>

        <para>Tout comme la balise <sgmltag>sources</sgmltag> se charge de l'inclusion des sources d'un module,
        la balise <sgmltag>binaries</sgmltag> se charge d'inclure les sorties du build d'un module, ou ses artefacts. 
        Bien que cette section fonctionne essentiellement comme un moyen de spécifier un <sgmltag>dependencySets</sgmltag> à appliquer à chaque module de la série,
        quelques fonctionnalités propres aux artefacts des modules méritent d'être explorées : <sgmltag>attachmentClassifier</sgmltag> et <sgmltag>includeDependencies</sgmltag>. 
        En plus de cela, la balise <sgmltag>binaries</sgmltag> contient une option similaire à la balise <sgmltag>dependencySet</sgmltag>,
        qui a trait à la manipulation de l'artefact du module lui-même.
        Il s'agit : <sgmltag>unpack</sgmltag>, <sgmltag>outputFileNameMapping</sgmltag>, <sgmltag>outputDirectory</sgmltag>, <sgmltag>directoryMode</sgmltag> et <sgmltag>fileMode</sgmltag>. 
        Enfin, les binaires d'un module peuvent contenir une balise <sgmltag>dependencySets</sgmltag> pour spécifier comment les dépendances de chaque module doivent être incluses dans l'assembly. 
        D'abord, jetons un coup d'oeil à la façon dont ces options peuvent être utilisées pour gérer les artefacts propres au module.</para>

        <para>Supposons que nous voulons inclure JARs de Javadoc pour chacun de nos modules à l'intérieur de notre assembly.
        Dans ce cas, nous ne nous soucions pas de l'inclusion des dépendances, nous voulons simplement ajouter le JAR de la Javadoc.
        Toutefois, comme ce JAR un peu particulier est toujours présent en tant que pièce jointe de l'artefact principal, 
        nous devons spécifier le classificateur à utiliser pour le récupérer.
        Pour simplifier, nous ne couvrirons pas dépaquetage les JARs de Javadoc des modules, 
        puisque la configuration est exactement la même que celle utilisée pour les dépendances, comme nous l'avons abordé précédemment dans ce chapitre.
        Le <varname>moduleSet</varname> devrait ressembler à l'<xref linkend="ex-include-javadoc-moduleset" />.</para>

        <example id="ex-include-javadoc-moduleset">
          <title>Inclure la Javadoc des modules dans une Assembly</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;binaries&gt;
        &lt;attachmentClassifier&gt;javadoc&lt;/attachmentClassifier&gt;
        &lt;includeDependencies&gt;false&lt;/includeDependencies&gt;
        &lt;outputDirectory&gt;apidoc-jars&lt;/outputDirectory&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Dans l'<xref linkend="ex-include-javadoc-moduleset" />,
        vous ne spécifiez pas directement de valeur au flag <sgmltag>includeSubModules</sgmltag> flag, celui-ci est activé par défaut.
        Cependant, nous tenons absolument à traiter tous les modules - même les sous-modules - en utilisant ce <varname>moduleSet</varname> :
        nous n'utilisons aucune sorte de pattern de fichier qui pourrait correspondre à des structures de sous-répertoire à l'intérieur du module.
        Pour chaque module, la balise <sgmltag>attachmentClassifier</sgmltag> récupérer l'artefact qui lui est attaché grâce au classificateur Javadoc.
        La balise <sgmltag>includeDependencies</sgmltag> signale au plugin Assembly que l'on n'est pas intéressé par les dépendances des modules, nous récupérons juste les pièces jointes.  
        Enfin, la balise <sgmltag>outputDirectory</sgmltag> demande au plugin Assembly de mettre tous les JARs de JAvadoc dans un répertoire nommé 
        <filename>apidoc-jars/</filename> en dehors du répertoire de l'assembly.</para>

        <para>Bien que nous ne faisons rien de très compliqué dans cet exemple,
        il est important de noter que les mêmes changements de l'exécution de l'algorithme de résolution des expressions, 
        dont nous avions parlé à propos de la balise <sgmltag>outputDirectoryMapping</sgmltag> de la balise <varname>sources</varname>, s'appliquent également ici.
        Tout ce qui est accessible par <varname>\${artifact.*}</varname> dans la configuration de la balise <sgmltag>outputFileNameMapping</sgmltag> du <sgmltag>dependencySet</sgmltag> est également disponible dans <varname>\${module.*}</varname>.  
        La même chose s'applique pour toute balise <sgmltag>outputFileNameMapping</sgmltag> lorsqu'elle est utilisée directement dans une balise <sgmltag>binaries</sgmltag>.</para>

        <para>Enfin, examinons un exemple dans lequel nous voulons simplement traiter l'artefact du module et ses dépendances <varname>runtime</varname>.
        Dans ce cas, nous voulons séparer la configuration de l'artefact pour chaque module dans un set et une structure de répertoire séparés, 
        en fonction de l'<varname>artifactId</varname> et de la <varname>version</varname> des modules.
        Le <varname>moduleSet</varname> reste simple, il ressemble au code de l'<xref linkend="ex-the-big-include" /> :</para>

        <example id="ex-the-big-include">
          <title>Inclusion des artefacts d'un module et de ses dépendances dans une assembly</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;binaries&gt;
        &lt;outputDirectory&gt;
          \${module.artifactId}-\${module.version}
        &lt;/outputDirectory&gt;
        &lt;dependencySets&gt;
          &lt;dependencySet/&gt;
        &lt;/dependencySets&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Dans l'<xref linkend="ex-the-big-include" />, nous utilisons la balise <sgmltag>dependencySet</sgmltag> en la laissant vide.
        Comme vous devez inclure toutes les dépendances, par défaut, vous n'avez pas besoin d'effectuer de configuration. 
        Lorsque la balise <sgmltag>outputDirectory</sgmltag> est spécifiée dans la balise <varname>binaires</varname>,
        toutes les dépendances devraient être incluses aux côtés de l'artefact du module dans le même répertoire.
        Ainsi, nous n'avons pas besoin le configurer tout cela dans le <varname>dependencySet</varname>.</para>  

        <para>La plupart du temps, les binaires d'un module restent assez simples.
        Dans les deux parties
        - la partie principale, chargée de la manipulation de l'artefact du module lui-même, des ensembles de dépendances, et qui est chargé des dépendances du module -  
        les options de configuration restent très similaires à celles des sets de dépendances.
        Bien entendu, la balise <varname>binaires</varname> fournie également des options pour contrôler 
        quelles dépendances sont incluses et quel artefact principal de projet vous souhaitez utiliser.</para>

        <para>Comme pour la balise <varname>source</varname>, la balise <varname>binaries</varname> dispose d'options de configuration qui sont fournies uniquement pour des causes de rétrocompatibilité.
        Celles-ci devraient être dépréciées, comment l'utilisation des sous-sections <varname>includes</varname> et <varname>excludes</varname>.</para>
      </section>

      <section id="assemblies-sect-modulesets-parent-pom">
        <title><sgmltag>moduleSets</sgmltag>, <acronym>POM</acronym>s parents et balise <sgmltag>binaries</sgmltag></title>

        <para>Enfin, clôturons cette discussion avec un avertissement.
        En ce qui concerne les relations parents-module, il existe des interactions subtiles entre le fonctionnement interne de Maven et l'exécution d'un <varname>moduleSet</varname> dans une balise <varname>binaires</varname>.         
        Lorsqu'un <acronym>POM</acronym> déclare un parent, 
        ce parent doit être résolu d'une façon ou d'une autre avant que le <acronym>POM</acronym> en question puisse être construit.
        Si un parent est dans un dépôt Maven, pas de problème.
        Cependant, vous vous exposez à de gros problèmes si le parent dispose d'un <acronym>POM</acronym> de plus haut niveau dans le même build,
        en particulier si le <acronym>POM</acronym> parent utilise les binaires de ces modules.</para>

        <para>Maven 2.0.9 trie les projets d'un build multimodule en fonction de leurs dépendances, avec des dépendances d'un projet construit avant celui-ci.
        Le problème est que l'élément parent est considéré comme une dépendance, 
        ce qui signifie que le build du projet parent doit être effectué avant que le projet enfant soit construit.
        Si une partie du build de ce parent inclus la création d'une assembly qui utilise les binaires des modules, 
        ces binaires ne seront pas encore créés et ne pourront donc pas être inclus.
        Cela provoquera ainsi l'échec de la construction de l'assembly. 
        Il s'agit d'une question complexe et subtile.
        Elle limite sérieusement l'utilité de la section <varname>binaires</varname> module du descripteur d'assembly. 
        En fait, à ce sujet, un bug a été créé sur legestionnaire d'anomalie du plugin Assembly : <ulink
        url="http://jira.codehaus.org/browse/MASSEMBLY-97">http://jira.codehaus.org/browse/MASSEMBLY-97</ulink>.
        Il faut espérer que les futures versions de Maven vont trouver un moyen de réparer cette fonctionnalité, 
        puisque la relation parent-first n'est pas forcément nécessaire.</para>
      </section>
    </section>

    <section id="assemblies-sect-repositories">
      <title>Balise <varname>repositories</varname></title>

      <para>Dans le descripteur d'assembly, la balise <varname>repositories</varname> est un élément un peu plus exotiques,
      peu d'applications (autre que Maven) peuvent tirer pleinement parti de la structure de répertoires d'un dépôt Maven. 
      Pour cette raison, et parceque nombre de ces fonctionnalités ressemblent étroitement à la balise <sgmltag>dependencySets</sgmltag>,
      nous ne passerons que très rapidement sur la présentation de cette balise.  
      Dans la plupart des cas, les utilisateurs qui ont compris comment fonctionnent les <sgmltag>dependencySets</sgmltag> n'auront aucun souci à 
      utiliser la balise <varname>repositories</varname> par l'intermédiaire du plugin Assembly
      Nous n'allons donc pas illustrer cette balise par un cas d'utilisation.
      Nous allons simplement donner quelques mises en garde pour ceux d'entre vous qui ressentent le besoin d'utiliser la balise <sgmltag>repositories</sgmltag>.</para>

      <!--TODO: We probably need to motivate why you would ever want to do this.  Right now, this section
doesn't make sense to new users.-->

      <para>Cela dit, nous avons deux fonctionnalités à mentionner en particulier à propos des balises <varname>repositories</varname>.
      La première est le flag <sgmltag>includeMetadata</sgmltag>. 
      Lorsque activé ce flag, les métadatas sont inclus, comme la liste des versions réelles qui correspondent aux versions virtuelles <varname>-SNAPSHOT</varname>. 
      Par défaut ce flag est désactivé.
      À l'heure actuelle, seules les métadatas incluses lorsque ce flag est à <varname>true</varname> sont téléchargées comme informations à partir du dépôt centra Maven.</para> 

      <para>La seconde fonctionnalité est appelée <sgmltag>groupVersionAlignments</sgmltag>. 
      Ici encore, cette balise représente une liste de configurations individuelles <sgmltag>groupVersionAlignment</sgmltag>,
      dont le but est de normaliser tous les artefacts inclus pour un <varname>groupId</varname> particulier pour utiliser une seule <varname>version</varname>. 
      Chaque entrée se compose de deux éléments obligatoires : un <varname>id</varname> et une <varname>version</varname>,
      ainsi qu'une section optionnelle appelée <sgmltag>excludes</sgmltag> qui fournit une liste d'<varname>artifactId</varname> qui doivent être exclus de ce réalignement.
      Malheureusement, ce remaniement ne semble pas modifier les <acronym>POM</acronym>s impliqués dans le dépôt,
      ni ceux liés à des artefacts réaligner, ni ceux qui dépendent des artefacts réalignés.
      De ce fait, il est difficile d'imaginer un réel cas d'utilisation pour ce genre de réalignement.</para>

      <para>En général, le plus simple est d'utiliser les mêmes principes que ceux des <sgmltag>dependencySets</sgmltag> que vous ajoutez à votre descripteur d'assembly.
      Même si la balise <varname>repositories</varname> supporte d'autres options, 
      elles sont principalement fournies pour des raisons de rétrocompatibilité, et seront probablement dépréciées dans les prochaines releases.</para> 
    </section>

    <section id="assemblies-sect-managing-root">
      <title>Gestion du répertoire racine de l'assembly</title>

      <para>Maintenant que nous avons parcouru les principales fonctionnalités dy déscripteur d'assembly,
      nous pouvons clôturer la discussion du contenu de ce descripteur avec quelque chose de plus léger :
      nommer un répertoire racine et manipulation des répertoires de site.</para>

      <para>Il est souvent important d'avoir le contrôle sur le nom du répertoire racine de votre assembly, ou de savoir a minima où on se trouve celui-ci.
      Deux options de configurations sont disponibles dans le descripteur d'assembly pour vous permettre de gérer le répertoire racine de vos archives :
      <sgmltag>includeBaseDirectory</sgmltag> et <sgmltag>baseDirectory</sgmltag>.
      Dans le cas de JAR execuratables, vous n'avez pas besoin de répertoire racine. 
      Pour ceci, il vous suffit d'inclure la balise <sgmltag>includeBaseDirectory</sgmltag> à <varname>false</varname>
      (sa valeur par défaut est <varname>true</varname>). 
      Ainsi, vous obtiendrez une archive, qui une fois dépaquetée, peut contenir plusieurs répertoires. 
      Ce type d'archives est considéré comme invalide, vous devez les dépaqueter avant de les utiliser.</para>

      <para>Dans les autres cas, vous voudrez garantir le nom de votre répertoire racine de votre archive quelque soientt les informations contenues dans votre <acronym>POM</acronym> (comme la version par exemple).
      Par défaut, la balise <sgmltag>baseDirectory</sgmltag> à pour valeur <varname>\${project.artifactId}-\${project.version}</varname>.
      Cependant, vous pouvez modifier cette valeur aisemment avec n'importe quelle expression provenant du <acronym>POM</acronym>,
      par exemple : <varname>\${project.groupId}-\${project.artifactId}</varname>.    
      Cette fonctionnalité peut s'avèrer très pratique pour les équipes de documentation (tout le mond en a, n'est-ce pas ?).</para>

      <para>Continuons avec la présentation d'un autre flag de configuration : <sgmltag>includeSiteDirectory</sgmltag>.
      Par défaut, celui-ci a pour valeur <varname>false</varname>.  
      Si le build de votre projet construit répertoire racine pour un site en utilisant le cycle de vie ou les goals du plugin Maven Site,  
      la sortie de celui-ci peut être inclus à l'assembly en positionnant ce flag à <varname>false</varname>.       
      Cependant, celle fonctionnalité est un peu limitée,
      comme on se contente d'inclure le répertoire <sgmltag>outputDirectory</sgmltag> dans la section reporting du <acronym>POM</acronym> courant (par défaut, <filename>target/site</filename>)
      sans prendre en considération d'éventuels autres répertoires qui pourraient être disponibles dans d'autres modules.
      Utilisez cette option si vous le désirez, mais vous pouvez obtenir le même résultat en utilisant un <sgmltag>fileSet</sgmltag> ou un <sgmltag>moduleSet</sgmltag>.
      Il s'agit encore d'un autre exemple de configuration legacy supportée par le plugin Assembly pour assurer la rétrocompatibilité.       
      Vos besoins peuvent évoluer, si vous désirer inclure un site provenant de plusieurs modules, privilégiez l'utilisation des 
      <sgmltag>fileSet</sgmltag> ou des <sgmltag>moduleSet</sgmltag> à la place d'activer le flag  <sgmltag>includeSiteDirectory</sgmltag>.</para>

    </section>

    <section id="assemblies-sect-componentDescriptors">
      <title><sgmltag>componentDescriptors</sgmltag> et
      <sgmltag>containerDescriptorHandlers</sgmltag></title>

      <para>Terminons l'exploration du descripteur d'assembly avec la présentation de deux dernières balises :  
      <sgmltag>containerDescriptorHandlers</sgmltag> et <sgmltag>componentDescriptors</sgmltag>. 
      La balise <sgmltag>containerDescriptorHandlers</sgmltag> fait référence à des composants 
      qui vous permettent d'étendre les fonctionnalités du plugin Assembly.
      Précisément, ces composants personnalisés vous permettent de définir et de gérer certains types de fichiers
      qui peuvent être fusionnés à partir de constituants utilisés pour créer votre assembly.
      Par exemple, nous pouvons utiliser ce mécanisme pour construire un unique <filename>web.xml</filename> à partir de plusieurs fragments 
      pour l'intégrer à l'assembly.</para>

      <para>La balise <sgmltag>componentDescriptors</sgmltag> permet de référencer des des descripteurs d'assembly externes et de les inclure dans le decripteur courant.
      Les références des composants peuvent-être une des caractéristiques suivantes :</para>

      <orderedlist>
        <listitem>
          <para>Chemins relatifs :
          <filename>src/main/assembly/component.xml</filename></para>
        </listitem>

        <listitem>
          <para>Références d'artefact :
          <varname>groupId:artifactId:version[:type[:classifier]]</varname></para>
        </listitem>

        <listitem>
          <para>Ressources du classpath :
          <filename>/assemblies/component.xml</filename></para>
        </listitem>

        <listitem>
          <para>URLs : <ulink
          url="http://www.sonatype.com/component.xml">http://www.sonatype.com/component.xml</ulink></para>
        </listitem>
      </orderedlist>

      <para>Lors de la résolution d'un descripteur de composant, le plugin Assembly essaye ces différentes stratégies dans cet ordre précis.
      La première stratégie qui matche est utilisée.</para>

      <para>Les descripteurs de composant peuvent contenir plusieurs fois les mêmes sections disponibles dans le descripteur d'Assembly,
      à l'exception de la balise <sgmltag>moduleSets</sgmltag>.
      Celle-ci est considérée comme spécifique à chaque projet.
      La balise <sgmltag>containerDescriptorHandlers</sgmltag> est également incluse dans le descripteur de composant, nous venons de le présenter. 
      Les descripteurs de composants ne peuvent pas contenir de formats, d'id d'assembly ou toute autre configuration en rapport avec le répertoire racine de l'archive.
      Ils sont tous sont considérés comme propres à un descripteur d'assembly.
      Bien qu'il semble intéressant de permettre le partage de la balise <varname>formats</varname>, 
      cela n'a pas été fait jusqu'à ce jour (version 2.2-beta-2-release du plugin Assembly).</para>
    </section>
  </section>

  <section id="assemblies-sect-best-practices">
    <title>Best Practices</title>

    <para>Le plugin Assemly est assez flexible pour permettre de résoudre la plupart des problèmes par différents moyens.
    Si vous avez un besoin unique pour votre projet, 
    il ya de bonnes chances que vous puissiez utiliser directement l'une des méthodes documentées dans ce chapitre pour obtenir votre structure d'assembly désirée.
    Cette section décrit quelques-unes des bonnes pratiques qui, si elles sont respectées, rendront l'utilisation du plugin Assembly plus productive et moins pénible.</para>  

    <section id="assemblies-sect-standard-reusable">
      <title>Descripteurs d'assembly standards et réutilisables</title>

      <para>Jusqu'à présent, nous avons principalement parlé des différentes solutions pour construire certains types d'assembly.
      Mais que ferez-vous si vous avez des dizaines de projets qui ont tous besoin d'un type particulier d'assemblage ?
      En bref, comment pouvons-nous réutiliser les efforts investis sur plusieurs projets sans avoir à copier-coller notre descripteur d'assembly ?</para>

      <para>Le moyen le plus simple est de créer un artefact standardisé et versionné pour externaliser le descripteur d'assemblage, et de le déployer.
      Une fois cela fait, vous pouvez configurer le plugin Assembly dans votre <acronym>POM</acronym> pour inclure ce descripteur d'assembly comme une dépendance de plugin.
      À ce stade, vous pouvez utiliser ce descripteur de l'Assembly par l'intermédiaire de la balise de configuration <sgmltag>descriptorRefs</sgmltag> dans la déclaration du plugin Assembly.
      Pour illustrer ceci, voici, en exemple, ce descripteur d'assemblage :</para>

      <programlisting language="xml">&lt;assembly&gt;
  &lt;id&gt;war-fragment&lt;/id&gt;
  &lt;formats&gt;
    &lt;format&gt;zip&lt;/format&gt;
  &lt;/formats&gt;
 &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;outputDirectory&gt;WEB-INF/lib&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  &lt;fileSets&gt;
    &lt;fileSet&gt;
      &lt;directory&gt;src/main/webapp&lt;/directory&gt;
      &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;**/web.xml&lt;/exclude&gt;
      &lt;/excludes&gt;
    &lt;/fileSet&gt;
  &lt;/fileSets&gt;
&lt;/assembly&gt;</programlisting>

      <para>Inclus dans votre projet, 
      ce descripteur serait un bon moyen de packager le contenu afin qu'il puisse être décompressé directement dans une application Web existante pour s'ajouter à celui-ci
      (pour ajouter une fonctionnalité, par exemple). 
      Toutefois, si votre équipe construit plusieurs de ces projets "web-fragment", vous aurez probablement envie de réutiliser ce descripteur plutôt que de le dupliquer. 
      Pour déployer ce descripteur dans son propre artefact, nous allons le mettre dans son propre projet, dans le répertoire 
      <filename>src/main/resources/assemblies</filename>.</para>

      <para>La structure de projet de cet artefact <varname>assembly-descriptor</varname> devrait ressembler à cela :</para>

      <programlisting>|-- pom.xml
`-- src
    `-- main
        `-- resources
            `-- assemblies
                `-- web-fragment.xml
</programlisting>

      <para>Notez le chemin vers le fichier descripteur <varname>web-fragment</varname>.  
      Par défaut, Maven inclus les fichiers du répertoire <filename>src/main/resources</filename> dans le JAR final.
      Ainsi, notre descripteur d'assembly sera inclu sans aucune autre configuration de notre part. 
      Notez également, le préfixe de chemin <filename>assemblies/</filename>, le plugin Assembly        
      s'attend à ce préfixe de chemin pour tous les descripteurs fournis dans le classpath des plugins. 
      Il est important de mettre notre descripteur à l'emplacement relatif approprié. 
      Ainsi, il sera récupéré par le plugin Assembly lors de son exécution.</para>

      <para>Souvenez-vous, ce projet est maintenant séparé de votre projet <varname>web-fragment</varname>.
      Le descripteur d'assembly possède son propre artefact avec sa propre version et, peut-être, son propre cycle de release.
      Une fois que vous avez installé ce nouveau projet via Maven, vous pourrez le référencer dans vos projets <varname>web-fragment</varname>.  
      Pour plus de clarté, le processus devrait ressembler à ceci : </para>

      <screen>$ <command>mvn install</command>
(...)
[INFO] [install:install]
[INFO] Installing (...)/web-fragment-descriptor/target/\
                  web-fragment-descriptor-1.0-SNAPSHOT.jar 
       to /Users/~/.m2/repository/org/sonatype/mavenbook/assemblies/\
          web-fragment-descriptor/1.0-SNAPSHOT/\
          web-fragment-descriptor-1.0-SNAPSHOT.jar
[INFO] ---------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ---------------------------------------------------------------
[INFO] Total time: 5 seconds
(...)</screen>

      <para>Comme notre projet <varname>web-fragment-descriptor</varname> ne contient pas de sources, 
      le JAR résultant ne contiendra rien d'autre que notre descripteur d'assembly <varname>web-fragment</varname>.
      Maintenant, utilisons ce nouvel artefact :</para>

      <programlisting language="xml">&lt;project&gt;
  (...)
  &lt;artifactId&gt;my-web-fragment&lt;/artifactId&gt;
  (...)
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2-beta-2&lt;/version&gt;
        &lt;dependencies&gt;
          &lt;dependency&gt;
            &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
            &lt;artifactId&gt;web-fragment-descriptor&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;assemble&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;descriptorRefs&gt;
                &lt;descriptorRef&gt;web-fragment&lt;/descriptorRef&gt;
              &lt;/descriptorRefs&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
      (...)
    &lt;/plugins&gt;
  &lt;/build&gt;
  (...)
&lt;/project&gt;
</programlisting>

      <para>Deux choses sont particulières sur cette configuration du plugin Assembly :</para>

      <itemizedlist>
        <listitem>
          <para>Nous devons inclure la déclaration de la dépendance vers notre <varname>web-fragment-descriptor</varname>
          au niveau de la déclaration des plugins afin d'avoir accès au descripteur d'Assembly par l'intermédiaire de classpath du plugin.</para>
        </listitem>

        <listitem>
          <para>Comme nous utilisons des références par le classpath au lieu d'utiliser un fichier local,
          nous devons utiliser la balise <sgmltag>descriptorRefs</sgmltag> à la place de la balise <sgmltag>descriptor</sgmltag>.  
          Notez également, que même si le descripteur d'assembly est actuellement localisé dans le classpath des plugins dans <filename>assemblies/web-fragment.xml</filename>, 
          nous pouvons le référencer sans utiliser le préfixe <filename>assemblies/</filename>.
          Ceci est rendu possible car le plugin Assembly présume que les descripteurs d'assembly se trouvent effectivement à cet emplacement.</para>
        </listitem>
      </itemizedlist>

      <para>Maintenant, vous êtes libre de réutiliser la configuration du <acronym>POM</acronym> ci-dessus dans autant de projets que vous voulez, 
      avec l'assurance que la totalité des fragments-web de l'assembly seront pris en compte. 
      Si vous avez besoin de faire des ajustements sur le format de votre assembly - 
      peut-être pour d'inclure d'autres ressources, ou pour affiner les dépendances et <varname>fileSet</varname> - 
      vous pouvez tout simplement incrémenter la version du projet de votre descripteur d'assembly, et le redéployer à nouveau. 
      Les <acronym>POM</acronym>s référençant l'artefact <varname>assembly-descriptor</varname> peuvent ainsi adopter cette nouvelle version du descripteur s'ils en sont capables.</para>

      <para>Un dernier point concernant la réutilisation de l'<varname>assembly-descriptor</varname> : vous souhaiterez peut-être partager la configuration du plugin. 
      Pour cela, ajoutez la configuration ci-dessus à la section <varname>pluginManagement</varname> de votre <acronym>POM</acronym> parent, 
      puis référencez la configuration de votre plugin dans votre <acronym>POM</acronym> comme ceci :</para>

      <programlisting language="xml">(...)
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
      &lt;/plugin&gt;
(...)</programlisting>

      <para>Si vous avez ajouté le reste de la configuration du plugin - comme décrit dans l'exemple précédent - 
      dans la section <varname>pluginManagement</varname> du <varname>POM</varname> parent de votre projet, 
      chaque projet d'héritant de celui-ci peut ajouter une entrée minimaliste comme celle-ci et profiter 
      du format d'assemblage avancé dans leurs propres builds.</para>
    </section>

    <section id="assemblies-set-dist-assemblies">
      <title>Assembly de distribution (agrégation)</title>

      <para>Comme mentionné ci-dessus, le plugin Assembly fournit plusieurs façons de créer de nombreux formats d'archives. 
      Les Assembly de distribution sont généralement de très bons exemples, 
      car ils combinent souvent des modules à partir d'un build multimodule, avec leurs dépendances et, éventuellement, d'autres fichiers en plus de ces artefacts. 
      La distribution vise à inclure ces différentes sources en une seule archive que l'utilisateur pourra télécharger, décompresser, et exécuter. 
      Toutefois, nous avons également parcouru un certain nombre d'inconvénients potentiels pouvant être provoqués par l'utilisation de la balise <sgmltag>moduleSets</sgmltag> du descripteur d'assembly - 
      les relations parent-enfant entre les <acronym>POM</acronym>s d'un build peuvent, dans certains cas, 
      rendre indisponlibe les artefacts des modules.</para>
      
      <para>Plus précisément, si les <acronym>POM</acronym>s des modules référencent comme leur parent le <acronym>POM</acronym> qui contient la configuration du plugin-assembly, 
      le projet parent devra être construit avant les projets modules lors de l'exécution du build. 
      Or, l'assembly du parent s'attend à trouver les artefacts de ses modules, 
      mais ces projets attendent également la fin de la construction de leur parent.
      On arrive donc à une situation de lock empêchant la construction du build parent. 
      En d'autres termes, le projet enfant dépend du projet parent et le projet parent dépend à son tour du projet enfant.</para>

      <para>À titre d'exemple, considérons le descripteur d'assembly ci-dessous. 
      Il est conçu pour être utilisé à partir du projet de plus haut niveau de la hiérarchie multimodule :</para>

      <programlisting language="xml">&lt;assembly&gt;
  &lt;id&gt;distribution&lt;/id&gt;
  &lt;formats&gt;
    &lt;format&gt;zip&lt;/format&gt;
    &lt;format&gt;tar.gz&lt;/format&gt;
    &lt;format&gt;tar.bz2&lt;/format&gt;
  &lt;/formats&gt;
  
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;includes&gt;
        &lt;include&gt;*-web&lt;/include&gt;
      &lt;/includes&gt;
      &lt;binaries&gt;
        &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
        &lt;unpack&gt;true&lt;/unpack&gt;
        &lt;includeDependencies&gt;true&lt;/includeDependencies&gt;
        &lt;dependencySets&gt;
          &lt;dependencySet&gt;
            &lt;outputDirectory&gt;/WEB-INF/lib&lt;/outputDirectory&gt;
          &lt;/dependencySet&gt;
        &lt;/dependencySets&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
    &lt;moduleSet&gt;
      &lt;includes&gt;
        &lt;include&gt;*-addons&lt;/include&gt;
      &lt;/includes&gt;
      &lt;binaries&gt;
        &lt;outputDirectory&gt;/WEB-INF/lib&lt;/outputDirectory&gt;
        &lt;includeDependencies&gt;true&lt;/includeDependencies&gt;
        &lt;dependencySets&gt;
          &lt;dependencySet/&gt;
        &lt;/dependencySets&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
&lt;/assembly&gt;</programlisting>

      <para>Pour un projet parent donnée - appelé <varname>app-parent</varname> - contenant trois modules :
      <varname>app-core</varname>, <varname>app-web</varname> et <varname>app-addons</varname>,
      notez ce qui se passe lorsque nous essayons d'exécuter ce build multimodule :</para> 

      <screen>$ <command>mvn package</command>
[INFO] Reactor build order: 
[INFO]   app-parent &lt;----- PARENT BUILDS FIRST
[INFO]   app-core
[INFO]   app-web
[INFO]   app-addons
[INFO] ---------------------------------------------------------------
[INFO] Building app-parent
[INFO]    task-segment: [package]
[INFO] ---------------------------------------------------------------
[INFO] [site:attach-descriptor]
[INFO] [assembly:single {execution: distro}]
[INFO] Reading assembly descriptor: src/main/assembly/distro.xml
[INFO] ---------------------------------------------------------------
[ERROR] BUILD ERROR
[INFO] ---------------------------------------------------------------
[INFO] Failed to create assembly: Artifact:
org.sonatype.mavenbook.assemblies:app-web:jar:1.0-SNAPSHOT (included by module) 
does not have an artifact with a file. Please ensure the package phase is 
run before the assembly is generated.
...</screen>

      <para>Le projet parent - <varname>app-parent</varname> - est le premier à être construit.
      C'est parce que chacun des autres projets désigne ce <acronym>POM</acronym> comme leur parent, forçant ainsi la construction dans cet ordre.
      Le module <varname>app-web</varname>, qui est le premier module désigné dans le descripteur d'assembly, n'a pas encore été construit. 
      Par conséquent, il ne dispose d'aucun des artefacts qui lui sont associés, la construction de l'assembly ne peut réussir.</para>

      <para>Une solution de contournement consiste à supprimer la balise <varname>executions</varname> de la déclaration du plugin Assembly. 
      Celle-ci lie le plugin à la phase <varname>package</varname> du cycle de vie dans le fichier <acronym>POM</acronym> parent. 
      Une fois cette suppression effectuée, exécutez ces deux tâches Maven : 
      la première, <varname>package</varname>, permet de construire un projet multimodule ; 
      et un second, <varname>assembly:assembly</varname>, pour invoquer directement le plugin assembly 
      et consommer les artefacts construits lors de l'exécution précédente, et créer l'assemblage de distribution. 
      Pour effectuer cela, utilisez la ligne de commande suivante :</para>
      
      <screen>$ <command>mvn package assembly:assembly</command></screen>

      <para>Cependant, cette approche présente plusieurs inconvénients. 
      Premièrement, elle rend le processus d'assemblage plus complexe en lui rajoutant une tâche manuelle qui peut accroître les risques d'erreur. 
      En outre, cela pourrait signifier que les artefacts joints - 
      qui sont associés en mémoire lors de l'exécution de la construction du projet - 
      ne seront pas accessibles au second passage sans recourir à des fichiers système de référence.</para>

      <para>Au lieu d'utiliser la balise <sgmltag>moduleSet</sgmltag> pour lister les artefacts du projet multimodule,
      il est souvent préférable d'utiliser une approche moins technique :
      à l'aide d'un module dédié à la distribution et aux dépendances inter-projet.
      Avec cette approche, vous créez un nouveau module dans votre build dont le seul but est d'effectuer l'assemblage.
      Le <acronym>POM</acronym> de ce module contient des références aux dépendances des autres modules, 
      et il configure le plugin Assembly pour qu'il soit rattaché à la phase <varname>package</varname> de son cycle de vie. 
      Le descripteur d'assembly lui-même utilise une section <sgmltag>dependencySets</sgmltag> à la place d'un <sgmltag>moduleSets</sgmltag> 
      pour lister les artefacts et déterminer où les inclure dans l'archive résultante.  
      Cette approche évite les inconvénients liés à la relation parent-enfant mentionnés plus haut, 
      et offre l'avantage d'utiliser une section de configuration plus simple dans le descripteur de l'assembly.</para>
      
      <para>Pour cela, nous pouvons créer une nouvelle structure de projet qui est ressemble étroitement à celle utilisée par l'approche module-set présentée précédemment. 
      En plus de ce nouveau projet de distribution, vous devriez avoir cinq <acronym>POM</acronym>s au total : 
      <varname>app-parent</varname>, <varname>app-core</varname>, <varname>app-web</varname>,
      <varname>app-addons</varname> et <varname>app-distribution</varname>.
      Le nouveau <acronym>POM</acronym> <varname>app-distribution</varname> devrait ressembler à cela :</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;artifactId&gt;app-parent&lt;/artifactId&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;artifactId&gt;app-distribution&lt;/artifactId&gt;
  &lt;name&gt;app-distribution&lt;/name&gt;
  
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;artifactId&gt;app-web&lt;/artifactId&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;war&lt;/type&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;artifactId&gt;app-addons&lt;/artifactId&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- Not necessary since it's brought in via app-web.
    &lt;dependency&gt; [2]
      &lt;artifactId&gt;app-core&lt;/artifactId&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    --&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>

      <para>Notez que nous avons à inclure les dépendances pour les autres modules dans la structure du projet, 
      puisque nous n'avons pas de section <varname>modules</varname> dans ce POM. 
      Aussi, notez que nous n'utilisons pas de dépendance explicite sur <varname>app-core</varname>. 
      Puisqu'il s'agit également d'une dépendance du <varname>app-web</varname>, 
      nous n'avons pas besoin de le traiter (ou, d'éviter de le traiter) à deux reprises.</para>

      <para>Ensuite, lorsque vous déplacerez le descripteur d'assembly <filename>distro.xml</filename> dans le projet <varname>app-distribution</varname>,
      nous devons également modifier l'utilisation de la section <sgmltag>dependencySets</sgmltag> :</para>  

      <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;includes&gt;
        &lt;include&gt;*-web&lt;/include&gt;
      &lt;/includes&gt;
      &lt;useTransitiveDependencies&gt;false&lt;/useTransitiveDependencies&gt;
      &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
      &lt;unpack&gt;true&lt;/unpack&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;*-web&lt;/exclude&gt;
      &lt;/excludes&gt;
      &lt;useProjectArtifact&gt;false&lt;/useProjectArtifact&gt;
      &lt;outputDirectory&gt;/WEB-INF/lib&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;
</programlisting>

      <para>Cette fois, si nous lançons la construction à partir du répertoire de plus haut niveau du projet, nous obtiendrons de meilleurs résultats :</para>

      <screen>$ <command>mvn package</command>
(...)
[INFO] ---------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] ---------------------------------------------------------------
[INFO] module-set-distro-parent ...............SUCCESS [3.070s]
[INFO] app-core .............................. SUCCESS [2.970s]
[INFO] app-web ............................... SUCCESS [1.424s]
[INFO] app-addons ............................ SUCCESS [0.543s]
[INFO] app-distribution ...................... SUCCESS [2.603s]
[INFO] ---------------------------------------------------------------
[INFO] ---------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ---------------------------------------------------------------
[INFO] Total time: 10 seconds
[INFO] Finished at: Thu May 01 18:00:09 EDT 2008
[INFO] Final Memory: 16M/29M
[INFO] ---------------------------------------------------------------</screen>

      <para>Comme vous pouvez le voir, l'approche par dependency-set est beaucoup plus stable et - 
      aussi longtemps que la logique interne de tri dans Maven ne prenne pas compte des fonctionnalités du plugin Assembly - 
      offre moins de possibilités de se tromper lors de l'exécution d'un build.</para>
    </section>
  </section>

  <section id="assemblies-sect-summary">
    <title>Récapitulatif</title>

    <para>Comme nous l'avons vu dans ce chapitre, le plugin Maven Assembly permet de la création de formats d'archives personnalisées. 
    Bien que les détails de ces archives peuvent être complexes,ils ne le sont pas nécessairement dans tous les cas - 
    comme nous l'avons vu avec les descripteurs d'assembly built-in. 
    Même si votre but est d'inclure les dépendances de votre projet et certains fichiers sélectionnés dans une structure de répertoires uniques et archivés, 
    l'écriture d'un descripteur d'assembly ne doit pas être trop complexe.</para>

    <para>Les assembly sont utiles pour un large éventail de cas d'utilisation. 
    Elles sont le plus couramment utilisées comme application de distribution. 
    Même s'il existe de nombreuses manières différentes d'utiliser le plugin Assembly,
    les deux façons les plus conseillées pour vous éviter des problèmes est d'utiliser
    des descripteurs d'assemblage standardisés et d'éviter l'utilisation des <varname>moduleSets</varname> lors de la création des distributions.</para>
  </section>
</chapter>
