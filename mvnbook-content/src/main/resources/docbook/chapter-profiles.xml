<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="profiles" lang="fr">
  <title>Profils de Build</title>

  <section id="profiles-sect-what">
    <title>À quoi servent-ils ?</title>

    <para>Les profils permettent d'adapter un build à l'environnement, ils assurent la portabilité entre différents
    environnements de build.</para>

    <para>Qu'entendons-nous par différents environnements de build ? La production et le développement sont deux
    environnements typiques. Quand vous travaillez dans l'environnement de développement, votre système est certainement
    configuré pour travailler sur une base de donnée de développement installée sur le poste local tandis qu'en
    production, votre système est configuré pour accèder à la base de donnée de production. Maven permet de définir un
    différents environnements de build (profils de build) qui peuvent remplacer n'importe quel paramètre dans le
    <filename>pom.xml</filename>. Vous pourriez configurer votre application pour lire dans votre base de donnée de
    développement locale dans un profil "development", et la configurer pour lire dans la base de donnée de production
    dans le profil "production". Les profils peuvent également être activés en fonction de l'environnement et de la
    plateforme, vous pouvez personnaliser un build pour s'exécuter différemment en fonction du système d'exploitation ou
    de la version du <acronym>JDK</acronym> installé. Avant que nous parlions de l'utilisation et la configuration des
    profils Maven, nous devons définir le concept de Portabilité du Build.</para>

    <section id="profiles-sect-portability">
      <title>Qu'est ce que la Portabilité du Build ?</title>

      <para>La "portabilité" du build est la mesure de la facilité avec laquelle on peut prendre un projet particulier
      et le construire sur différents environnements. Un build qui fonctionne sans aucune configuration particulière ni
      personnalisation des fichiers properties est plus portable qu'un build qui nécessite une quantité de travail pour
      construire un projet depuis 0. Les projets les plus portables sont bien souvent des projets open source très
      utilisés comme Apache Commons ou Apache Velocity qui fonctionnent avec Maven sans personnalisation ou presque.
      Pour faire simple, les builds les plus portables fonctionnent, et les moins portables vous demander de jongler et
      configurer les chemins vers les outils de build en fonction des plateformes. Avant que nousvous dévoilions comment
      obtenir un build portable, étudions les différents types de portabilité dont nous allons parler.</para>

      <section id="profiles-sect-non-portable">
        <title>Builds non portables</title>

        <para>Le manque de portabilité est exactement ce que les outils de build essayent d'éviter - cependant,
        n'importe quel outil peut être configuré pour être non-portable (même Maven). Un projet n'est pas portable
        lorsqu'il ne peut être construit que dans certaines circonstances spécifiques (ex : votre machine locale). A
        moins que vous travailliez seul et que vous n'envisagiez pas de déployer votre application sur une autre
        machine, il vaut mieux éviter complètement la non-portabilité. Un build non-portable fonctionne seulement sur
        une machine, c'est un build "à usage unique". Maven est conçu pour décourager les buids non-portables en offrant
        la possibilité de personnaliser les builds grâce aux profils.</para>

        <para>Quand un développeur récupère le code source d'un projet non-portable, il n'est pas en mesure de
        construire le projet sans remanier une grosse partie du script de build.</para>
      </section>

      <section id="profiles-sect-environment-portability">
        <title>Portabilité sur l'environnement</title>

        <para>Un build est qualifié de portable d'un environnement à l'autre s'il possède un mécanisme pour
        personnaliser le comportement et la configuration en fonction de l'environnement. Un projet qui contient une
        référence à une base de donnée de test dans un environnement de test, par exemple, et à une base de donnée de
        production dans un environnement de production, est portable sur ces environnements. Il est probable que ce
        build ait différentes propriétés pour chaque environnement. Quand vous changez pour un environnement pour qui
        n'est pas défini et qui ne possède pas de profile associé, le projet ne fonctionnera pas. Donc un projet n'est
        portable que sur des environnements bien définis.</para>

        <para>Quand un nouveau développeur récupère le code source d'un projet dépendant de l'environnement, il devra
        exécuter le build dans cet environnement ou créer un environnement adequat pour réussir à construire le
        projet.</para>
      </section>

      <section id="profiles-sect-org-portability">
        <title>Portabilité interne à une organisation</title>

        <para>Le point clef de cet environnement est que seuls quelques uns ont accès à des ressources internes comme le
        gestionnaire de configuration ou le dépôt interne Maven. Un projet dans une grande entreprise peut dépendre de
        la présence d'une base de données accessibls uniqument pour les développeurs internes. Un projet libre peut
        exiger un certain niveau de droits pour pouvoir publier le site web et les artefacts produits sur un dépôt
        publique.</para>

        <para>Si vous essayez de construire un projet interne hors du réseau interne de l'entreprise (par exemple de
        l'autre coté du firewall), le build va échouer. Il se peut que celà vienne de plugins propres à l'entreprise qui
        ne sont pas disponibles ou des dépendances du projet qui ne peuvent être trouvées car vous n'avez pas les droits
        nécessaires pour accéder au dépôt distant d'entreprise. Un tel projet n'est portable que sur les environnements
        au sein d'une organisation.</para>
      </section>

      <section id="profiles-sect-wide-portability">
        <title>(Universelle) Véritable Portabilité</title>

        <para>Tout le monde peut télécharger le code source d'un projet véritablement portable, le compiler et
        l'installer sans avoir à configurer le build pour son environnement spécifique. C'est le plus haut niveau de
        portabilité ; aucun travail supplémentaire n'est nécessaire pour construire ce projet. Ce niveau de portabilité
        est important surtout pour les projets libres qui dépendent de la facilité avec laquelle les contributeurs
        potentiels vont pouvoir construire le projet à partir du code source téléchargé.</para>

        <para>N'importe quel développeur peut télécharger le code source d'un projet véritablement portable.</para>
      </section>
    </section>

    <section id="profiles-sect-select-level">
      <title>Choisir le bon niveau de portabilité</title>

      <para>Evidemment, vous voulez éviter le pire cas : le build non-portable. Vous avez peut-être connu le malheur de
      travailler ou d'étudier pour une organisation dont les applications critiques ont des builds non-portables. Dans
      une organisation comme celle-là, impossible de déployer une application sans une personne bien spécifique sur une
      machine bien spécifique aussi. Avec une telle organisation, il est très difficile d'introduire de nouvelles
      dépendances ou des changements sans se coordonner avec la personne qui gère ce build non-portable. Ces builds
      non-portables ont tendances à se développer dans des environnements très politiques où une personne ou un groupe
      veut contrôler quand et comment un projet est construit et déployé. "Comment construit-on le système ? Oh, nous
      devons appeler Jack et lui demander de nous le construire, personne d'autre ne peut déployer en production". C'est
      une situation périlleuse qui est beaucoup plus fréquente qu'on ne le pense. Si vous travaillez dans cette
      organisation, Maven et les profils Maven sont votre porte de sortie.</para>

      <para>A l'autre bout du spectre de la portabilité se trouvent les builds très portables. Ces builds sont des
      builds très difficiles à atteindre. Ils restreignent vos dépendances aux projets et aux outils qui sont librement
      distribuables et facilement accessibles. De nombreux packages commerciaux doivent être exclus des builds les plus
      portables car ils ne peuvent être téléchargés sans que vous n'ayez à accepter une license spécifique. Cette large
      portabilité va aussi restreindre les dépendances aux logiciels qui sont distribués sous la forme d'artefacts
      Maven. Par exemple, si vous dépendez des pilotes JDBC d'Oracle, vos utilisateurs devront les télécharger et les
      installer manuellement ; ce n'est pas très portable car vous devrez fournir les intructions nécessaires pour
      configurer l'environnement afin que les personnes itéressées puissent construire votre application. D'un autre
      côté, vous pourriez utiliser un pilote JDBC disponible sur le dépôt publique de Maven comme MySQL ou
      HSQLDB.</para>

      <para>Comme nous l'avons vu précédemment, les projets libres bénéficient d'avoir des builds le plus portable
      possible. Les builds très portables réduisent le coût de contribution à un projet. Dans un projet libre (comme
      Maven) on trouve deux groupes très distincts : les développeurs et les utilisateurs finaux. Quand un utilisateur
      final utilise Maven et qu'il décide de contribuer en proposant un patch de Maven, il doit passer de l'utilisation
      de l'artefact résultat d'un build à produire cet artefact. Il doit donc tout d'abord se transformer en
      développeur, et si apprendre à construire ce projet est trop compliqué, alors cet utilisateur perdra de sa
      motivation à contribuer au projet. Avec un projet très portable, un utilisateur n'a pas à connaitre les arcanes du
      projet pour se tranformer en développeur, il peut télécharger le code source, le modifier, construire son artefact
      et proposer sa contribution sans avoir à demander de l'aide pour configurer son environnement. Plus le coût
      d'entrée pour contribuer à un projet libre est bas et plus le nombre de contributions augmente, surtout dans ces
      petites contributions qui font la différence pour la réussite d'un projet. Une des conséquences de l'adoption de
      Maven par un grand nombre de projets libres est que contribuer à ces projets est devenu beaucoup plus
      facile.</para>
    </section>
  </section>

  <section id="profiles-sect-maven-profiles">
    <title>Portabilité grâce aux profiles Maven</title>

    <para>Un profil dans Maven est un ensemble alternatif de valeurs qui définissent ou écrasent les valeurs par défaut.
    En utilisant un profil, vous pouvez personnaliser un build pour différents environnements. Les profils sont
    configurés dans le <filename>pom.xml</filename> et possèdent un identifiant. Vous pouez ensuite exécuter Maven en
    précisant dans la ligne de commande le profil à utiliser. Le <filename>pom.xml</filename> suivant utilise un profil
    <literal>production</literal> pour écraser les paramètres par défaut du plugin Compiler.</para>

    <example>
      <title>Utilisation d'un profil Maven pour écraser les paramètres du compilateur pour la production</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;simple&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;name&gt;simple&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;profiles&gt; <co id="coDef-profiles-compile-1" linkends="coRef-profiles-compile-1" />&lt;profile&gt; &lt;id&gt;production&lt;/id&gt; <co
          id="coDef-profiles-compile-2" linkends="coRef-profiles-compile-2" />&lt;build&gt; <co
          id="coDef-profiles-compile-3" linkends="coDef-profiles-compile-3" />&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;debug&gt;false&lt;/debug&gt; <co
          id="coDef-profiles-compile-4" linkends="coDef-profiles-compile-4" />&lt;optimize&gt;true&lt;/optimize&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt; &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>Dans cet exemple, nous avons ajouté un profil nommé <literal>production</literal> pour écraser la
    configuration par défaut du plugin Maven. Examinons la syntaxe de ce profil en détail.</para>

    <calloutlist>
      <callout arearefs="coDef-profiles-compile-1" id="coRef-profiles-compile-1">
        <para>L'élément <sgmltag>profiles</sgmltag> est dans le <filename>pom.xml</filename>, il contient un ou
        plusieurs éléments <sgmltag>profile</sgmltag>. Puisque les profils écrasent les paramètres par défaut dans le
        <filename>pom.xml</filename>, l'élément <sgmltag>profiles</sgmltag> est habituellement positionné en fin de
        <filename>pom.xml</filename>.</para>
      </callout>

      <callout arearefs="coDef-profiles-compile-2" id="coRef-profiles-compile-2">
        <para>Chaque profil doit avoir un élément <sgmltag>id</sgmltag>. Cet element <sgmltag>id</sgmltag> contient le
        nom qui est utilisé pour invoquer ce profil sur la ligne de commande. Un profil est invoqué en passant
        l'argument <command>-P&lt;profile_id&gt;</command> à la ligne de commande Maven.</para>
      </callout>

      <callout arearefs="coDef-profiles-compile-3" id="coRef-profiles-compile-3">
        <para>Un élément <sgmltag>profile</sgmltag> peut contenir de nombreux éléments contenus dans l'élément
        <sgmltag>project</sgmltag> d'un POM. Dans cet exemple, nous écrasons le comportement du plugin Compiler et nous
        devons écraser la configuration du plugin qui se trouve normalement dans l'élément
        <sgmltag>build</sgmltag>/<sgmltag>plugins</sgmltag>.</para>
      </callout>

      <callout arearefs="coDef-profiles-compile-4" id="coRef-profiles-compile-4">
        <para>Nous surchargeons la configuration du plugin Maven Compiler. Nous nous assurons que le bytecode produit
        par le profil de production ne contient pas les informtions de deboggage et qu'il a été optimisé par le
        compilateur.</para>
      </callout>
    </calloutlist>

    <para>Pour exécuter la commande <command>mvn install</command> avec le profil de <literal>production</literal> vous
    devez passer l'argument <command>-Pproduction</command> sur la ligne de commande. Pour vérifier que le profil de
    <literal>production</literal> surcharge la configuation par défaut du plugin Compiler, exécutez Maven avec les
    options de debug (<command>-X</command>) activées ainsi :</para>

    <screen>~/examples/profile $ <command>mvn clean install -Pproduction -X</command>
... (omitting debugging output) ...
[DEBUG] Configuring mojo 'o.a.m.plugins:maven-compiler-plugin:2.0.2:testCompile'
[DEBUG]   (f) basedir = ~\examples\profile
[DEBUG]   (f) buildDirectory = ~\examples\profile\target
...
[DEBUG]   (f) compilerId = javac
[DEBUG]   (f) <emphasis>debug = false</emphasis>
[DEBUG]   (f) failOnError = true
[DEBUG]   (f) fork = false
[DEBUG]   (f) <emphasis>optimize = true</emphasis>
[DEBUG]   (f) outputDirectory = \
          ~\svnw\sonatype\examples\profile\target\test-classes
[DEBUG]   (f) outputFileName = simple-1.0-SNAPSHOT
[DEBUG]   (f) showDeprecation = false
[DEBUG]   (f) showWarnings = false
[DEBUG]   (f) staleMillis = 0
[DEBUG]   (f) verbose = false
[DEBUG] -- end configuration --
... (omitting debugging output) ...
</screen>

    <para>Cet extrait de la sortie en mode debug de Maven nous montre la configuration du plugin Compiler avec le profil
    de production. Comme nous pouvons le voir, la variable <varname>debug</varname> est à faux et la variable
    <varname>optimize</varname> est à vrai.</para>

    <section id="profiles-sect-overriding-pom">
      <title>Surcharger un POM</title>

      <para>L'exemple précédent vous a montré comment surcharger la configuration par défaut d'un unique plugin Maven,
      mais vous ne savez toujours pas ce qu'il est possible de faire avec un profil Maven. Pour faire court, un profil
      Maven peut surcharger presque tout ce que vous pouvez trouver dans un fichier <filename>pom.xml</filename>. Le
      <acronym>POM</acronym> Maven possède une balise appelée <sgmltag>profiles</sgmltag> qui contient les différentes
      configurations d'un projet, et dans cette balise se trouve une balise profile qui définit chacun d'entre eux.
      Chaque profil doit avoir une balise <sgmltag>id</sgmltag>, et à part celà elle peut contenir presque toutes les
      balises que l'on peut trouver dans la balise <sgmltag>project</sgmltag>. Le document <acronym>XML</acronym> qui
      suit nous montre toutes les balsies qu'un profile peut surcharger.</para>

      <para><example>
          <title>Balises autorisées dans un profil</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;build&gt;
        &lt;defaultGoal&gt;...&lt;/defaultGoal&gt;
        &lt;finalName&gt;...&lt;/finalName&gt;
        &lt;resources&gt;...&lt;/resources&gt;
        &lt;testResources&gt;...&lt;/testResources&gt;
        &lt;plugins&gt;...&lt;/plugins&gt;
      &lt;/build&gt;
      &lt;reporting&gt;...&lt;/reporting&gt;
      &lt;modules&gt;...&lt;/modules&gt;
      &lt;dependencies&gt;...&lt;/dependencies&gt;
      &lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt;
      &lt;distributionManagement&gt;...&lt;/distributionManagement&gt;
      &lt;repositories&gt;...&lt;/repositories&gt;
      &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt;
      &lt;properties&gt;...&lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>Un profil peut donc redéfinir les éléments entourés par une ellipse. Un profil peut redéfinir le nom de
      l'artefact final, les dépendances et le build d'un projet via la en surchargeant la configuration de plugins. Un
      profil peut aussi redéfinir les paramètres de distribution ; par exemple, si pour une étape de validation vous
      devez publier vos artefacts sur un serveur de pré-production vous allez créer un profil de validation qui va
      surcharger la balise <sgmltag>distributionManagement</sgmltag>.</para>
    </section>
  </section>

  <section id="profiles-sect-activation">
    <title>Activation de profil</title>

    <para>Dans la section précédente nous vous avons présenté comment créer un profil qui redéfinit le comportement par
    défaut selon un environnement cible spécifique. Le build précédent était configuré par défaut pour le développement,
    et le profil <literal>production</literal> existe pour apporter les éléments de configuration propres à
    l'environnement de production. Que se passe t'il si vous devez adapter votre build selon le système d'exploitation
    ou la version du <acronym>JDK</acronym> ? Maven fournit un mécanisme pour "activer" un profil selon différents
    paramètres liés à l'environnement, c'est ce qe l'on appelle l'activation de profil.</para>

    <para>Prenons l'exemple suivant, supposons que nous avons une bibliothèque Java dont certaines fonctions ne sont
    disponibles que pour Java 6 : le moteur de scripts défini dans la <ulink
    url="http://jcp.org/en/jsr/detail?id=223">JSR-223</ulink>. Une fois que vous avez séparé le bloc de code qui utilise
    le moteur de scripts dans un projet Maven à part, vous voulez que les personnes qui utilisent Java 5 puissent
    construire votre projet sans essayer de construire l'extension spécifique Java 6. Vous pouvez faire celà au moyen
    d'un profil Maven qui ajoute le module de gestion des scripts uniquement lorsque le build se fait sur un
    <acronym>JDK</acronym> Java 6. Tout d'abord, jettons un oeil à la structure des répertoires de notre projet et
    comment nous souhaitons que les développeurs construisent notre système.</para>

    <para>When someone runs <command>mvn install</command> with a Java 6 <acronym>JDK</acronym>, you want the build to
    include the <literal>simple-script</literal> project's build, when they are running in Java 5, you would like to
    skip the <literal>simple-script</literal> project build. If you failed to skip the <literal>simple-script</literal>
    project build in Java 5, your build would fail because Java 5 does not have the <classname>ScriptEngine</classname>
    on the classpath. Let's take a look at the library project's <filename>pom.xml</filename>:</para>

    <example>
      <title>Dynamic Inclusion of Submodules Using Profile Activation</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                             http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;simple&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;name&gt;simple&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;jdk16&lt;/id&gt;
      &lt;activation&gt; <co id="coDef-profiles-active-1" linkends="coRef-profiles-active-1" />&lt;jdk&gt;1.6&lt;/jdk&gt; &lt;/activation&gt; &lt;modules&gt; <co
          id="coDef-profiles-active-2" lang="" linkends="coRef-profiles-active-2" />&lt;module&gt;simple-script&lt;/module&gt; &lt;/modules&gt; &lt;/profile&gt; &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>If you run <command>mvn install</command> under Java 1.6, you will see Maven descending into the
    <filename>simple-script</filename> subdirectory to build the <literal>simple-script</literal> project. If you are
    running <command>mvn install</command> in Java 1.5, the build will not try to build the
    <literal>simple-script</literal> submodule. Exploring this activation configuration in more detail:</para>

    <calloutlist>
      <callout arearefs="coDef-profiles-active-1" id="coRef-profiles-active-1">
        <para>The <sgmltag>activation</sgmltag> element lists the conditions for profile activation. In this example,
        we've specified that this profile will be activated by Java versions that begin with "1.6". This would include
        "1.6.0_03", "1.6.0_02", or any other string that began with "1.6". Activation parameters are not limited to Java
        version, for a full list of activation parameters, see <xref linkend="profiles-sect-activation-config"
        xrefstyle="select:title" />.</para>
      </callout>

      <callout arch="" arearefs="coDef-profiles-active-2" id="coRef-profiles-active-2">
        <para>In this profile we are adding the module <literal>simple-script</literal>. Adding this module will cause
        Maven to look in the <filename>simple-script/</filename> subdirectory for a <filename>pom.xml</filename>.</para>
      </callout>
    </calloutlist>

    <section id="profiles-sect-activation-config">
      <title>Activation Configuration</title>

      <para>Activations can contain one of more selectors including JDK versions, Operating System parameters, files,
      and properties. A profile is activated when all activation criteria has been satisfied. For example, a profile
      could list an Operating System family of Windows, and a JDK version of 1.4, this profile will only be activated
      when the build is executed on a Windows machine running Java 1.4. If the profile is active then all elements
      override the corresponding project-level elements as if the profile were included with the <command>-P</command>
      command-line argument. The following example, lists a profile which is activated by a very specific combination of
      operating system parameters, properties, and a JDK version.</para>

      <para><example>
          <title>Profile Activation Parameters: JDK Version, OS Parameters, and Properties</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;dev&lt;/id&gt;
      &lt;activation&gt;
        &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; <co id="coDef-profiles-active2-1"
              linkends="coRef-profiles-active2-1" />&lt;jdk&gt;1.5&lt;/jdk&gt; <co id="coDef-profiles-active2-2"
              linkends="coRef-profiles-active2-2" />&lt;os&gt; &lt;name&gt;Windows XP&lt;/name&gt; <co
              id="coDef-profiles-active2-3" linkends="coRef-profiles-active2-3" />&lt;family&gt;Windows&lt;/family&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;property&gt; &lt;name&gt;mavenVersion&lt;/name&gt; <co
              id="coDef-profiles-active2-4" linkends="coRef-profiles-active2-4" />&lt;value&gt;2.0.5&lt;/value&gt; &lt;/property&gt; &lt;file&gt; &lt;exists&gt;file2.properties&lt;/exists&gt; <co
              id="coDef-profiles-active2-5" linkends="coRef-profiles-active2-5" />&lt;missing&gt;file1.properties&lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; ... &lt;/profile&gt; &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>This previous example defines a very narrow set of activation parameters. Let's examine each activation
      criterion in detail:</para>

      <calloutlist>
        <callout arearefs="coDef-profiles-active2-1" id="coRef-profiles-active2-1">
          <para>The <sgmltag>activeByDefault</sgmltag> element controls whether this profile is considered active by
          default.</para>
        </callout>

        <callout arearefs="coDef-profiles-active2-2" id="coRef-profiles-active2-2">
          <para>This profile will only be active for JDK versions that begin with "1.5". This includes "1.5.0_01",
          "1.5.1".</para>
        </callout>

        <callout arearefs="coDef-profiles-active2-3" id="coRef-profiles-active2-3">
          <para>This profile targets a very specific version of Windows XP, version 5.1.2600 on a 32-bit platform. If
          your project uses the native plugin to build a C program, you might find yourself writing projects for
          specific platforms.</para>
        </callout>

        <callout arearefs="coDef-profiles-active2-4" id="coRef-profiles-active2-4">
          <para>The <sgmltag>property</sgmltag> element tells Maven to activate this profile if the property
          <varname>mavenVersion</varname> is set to the value <literal>2.0.5</literal>. <varname>mavenVersion</varname>
          is an implicit property that is available to all Maven builds.</para>
        </callout>

        <callout arearefs="coDef-profiles-active2-5" id="coRef-profiles-active2-5">
          <para>The <sgmltag>file</sgmltag> element allows us to activate a profile based on the presence (or absence)
          of files. The <literal>dev</literal> profile will be activated if a file named
          <filename>file2.properties</filename> exists in the base directory of the project. The <literal>dev</literal>
          profile will only be activated if there is no file named <filename>file1.properties</filename> file in the
          base directory of the project.</para>
        </callout>
      </calloutlist>
    </section>

    <section id="profiles-sect-activation-by-absence">
      <title>Activation by the Absence of a Property</title>

      <para>You can activate a profile based on the value of a property like
      <varname>environment.</varname><varname>type</varname>. You can activate a <literal>development</literal> profile
      if <varname>environment.</varname><varname>type</varname> equals <literal>dev</literal>, or a
      <literal>production</literal> profile if <varname>environment.</varname><varname>type</varname> equals
      <literal>prod</literal>. You can also activate a profile in the absence of a property. The following configuration
      activates a profile if the property <varname>environment.</varname><varname>type</varname> is not present during
      Maven execution.</para>

      <para><example>
          <title>Activating Profiles in the Absence of a Property</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;development&lt;/id&gt;
      &lt;activation&gt;
        &lt;property&gt;
          &lt;name&gt;!environment.type&lt;/name&gt;
        &lt;/property&gt;
      &lt;/activation&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>Note the exclamation point prefixing the property name. The exclamation point is often referred to as the
      "bang" character and signifies "not". This profile is activated when no
      <varname>\${environment.</varname><varname>type}</varname> property is set.</para>
    </section>
  </section>

  <section id="profiles-sect-listing-active-profiles">
    <title>Listing Active Profiles</title>

    <para>Maven profiles can be defined in either <filename>pom.xml</filename>, <filename>profiles.xml</filename>,
    <filename>~/.m2/settings.xml</filename>, or <filename>\${M2_HOME}/conf/settings.xml</filename>. With these four
    levels, there's no good way of keeping track of profiles available to a particular project without remembering which
    profiles are defined in these four files. To make it easier to keep track of which profiles are available, and where
    they have been defined, the Maven Help plugin defines a goal, <literal>active-profiles</literal>, which lists all
    the active profiles and where they have been defined. You can run the <literal>active-profiles</literal> goal, as
    follows:</para>

    <screen>$ <command>mvn help:active-profiles</command>
Active Profiles for Project 'My Project':

The following profiles are active:

 - my-settings-profile (source: settings.xml)
 - my-external-profile (source: profiles.xml)
 - my-internal-profile (source: pom.xml)</screen>
  </section>

  <section id="profiles-sect-tips-tricks">
    <title>Tips and Tricks</title>

    <para>Profiles can encourage build portability. If your build needs subtle customizations to work on different
    platforms or if you need your build to produce different results for different target platforms, project profiles
    increase build portability. Settings profiles generally decrease build portability by adding extra-project
    information that must be communicated from developer to developer. The following sections provide some guidelines
    and some ideas for applying Maven profiles to your project.</para>

    <section id="profiles-sect-common-envs">
      <title>Common Environments</title>

      <para>One of the core motivations for Maven project profiles was to provide for environment-specific configuration
      settings. In a development environment, you might want to produce bytecode with debug information and you might
      want to configure your system to use a development database instance. In a production environment you might want
      to produce a signed JAR and configure the system to use a production database. In this chapter, we defined a
      number of environments with identifiers like <literal>dev</literal> and <literal>prod</literal>. A simpler way to
      do this would be to define profiles that are activated by environment properties and to use these common
      environment properties across all of your projects. For example, if every project had a
      <literal>development</literal> profile activated by a property named
      <varname>environment.</varname><varname>type</varname> having a value of <literal>dev</literal>, and if those same
      projects had a <literal>production</literal> profile activated by a property named
      <varname>environment.</varname><varname>type</varname> having a value of <literal>prod</literal>, you could create
      a default profile in your <filename>settings.xml</filename> that always set
      <varname>environment.</varname><varname>type</varname> to <literal>dev</literal> on your development machine. This
      way, each project defines a <literal>dev</literal> profile activated by the same environment variable. Let's see
      how this is done, the following <filename>settings.xml</filename> defines a profile in
      <filename>~/.m2/settings.xml</filename> which sets the <varname>environment.</varname><varname>type</varname>
      property to <literal>dev</literal>.</para>

      <para><example>
          <title>~/.m2/settings.xml defines a default profile setting environment.type</title>

          <programlisting language="xml">&lt;settings&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;activation&gt;
        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;environment.type&gt;dev&lt;/environment.type&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/settings&gt;
</programlisting>
        </example></para>

      <para>This means that every time you run Maven on your machine, this profile will be activated and the property
      <varname>environment.</varname><varname>type</varname> will have the value <literal>dev</literal>. You can then
      use this property to activate profiles defined in a project's <filename>pom.xml</filename> as follows. Let's take
      a look at how a project's <filename>pom.xml</filename> would define a profile activated by
      <varname>environment.</varname><varname>type</varname> having the value <literal>dev</literal>.</para>

      <para><example id="ex-profile-envtype-pom">
          <title>Project Profile Activated by environment.type equalling 'dev'</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;development&lt;/id&gt;
      &lt;activation&gt;
        &lt;property&gt;
          &lt;name&gt;environment.type&lt;/name&gt;
          &lt;value&gt;dev&lt;/value&gt;
        &lt;/property&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;database.driverClassName&gt;com.mysql.jdbc.Driver&lt;/database.driverClassName&gt;
        &lt;database.url&gt;
          jdbc:mysql://localhost:3306/app_dev
        &lt;/database.url&gt;
        &lt;database.user&gt;development_user&lt;/database.user&gt;
        &lt;database.password&gt;development_password&lt;/database.password&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
    &lt;profile&gt;
      &lt;id&gt;production&lt;/id&gt;
      &lt;activation&gt;
        &lt;property&gt;
          &lt;name&gt;environment.type&lt;/name&gt;
          &lt;value&gt;prod&lt;/value&gt;
        &lt;/property&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;database.driverClassName&gt;com.mysql.jdbc.Driver&lt;/database.driverClassName&gt;
        &lt;database.url&gt;jdbc:mysql://master01:3306,slave01:3306/app_prod&lt;/database.url&gt;
        &lt;database.user&gt;prod_user&lt;/database.user&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>This project defines some properties like <varname>database.</varname><varname>url</varname> and
      <varname>database.user</varname> which might be used to configure another Maven plugin configured in the
      <filename>pom.xml</filename>. There are plugins available that can manipulate the database, run SQL, and plugins
      like the Maven Hibernate3 plugin which can generate annotated model objects for use in persistence frameworks. A
      few of these plugins, can be configured in a <filename>pom.xml</filename> using these properties. These properties
      could also be used to filter resources. In this example, because we've defined a profile in
      <filename>~/.m2/settings.xml</filename> which sets <varname>environment.</varname><varname>type</varname> to
      <literal>dev</literal>, the development profile will always be activated when we run Maven on our development
      machine. Alternatively, if we wanted to override this default, we could set a property on the command-line. If we
      need to activate the production profile, we could always run Maven with:</para>

      <screen>~/examples/profiles $ <command>mvn install -Denvironment.type=prod</command></screen>

      <para>Setting a property on the command-line would override the default property set in
      <filename>~/.m2/settings.xml</filename>. We could have just defined a profile with an <sgmltag>id</sgmltag> of
      "dev" and invoked it directly with the <command>-P</command> command-line argument, but using this
      <varname>environment.</varname><varname>type</varname> property allows us to code other project
      <filename>pom.xml</filename> files to this standard. Every project in your codebase could have a profile which is
      activated by the same <varname>environment.</varname><varname>type</varname> property set in every user's
      <filename>~/.m2/settings.xml</filename>. In this way, developers can share common configuration for development
      without defining this configuration in non-portable <filename>settings.xml</filename> files.</para>
    </section>

    <section id="profiles-sect-protecting-secrets">
      <title>Protecting Secrets</title>

      <para>This best practice builds upon the previous section. In <xref linkend="ex-profile-envtype-pom"
      xrefstyle="select:title" />, the production profile does not contain the <varname>database.password</varname>
      property. I've done this on purpose to illustrate the concept of putting secrets in you user-specific
      <filename>settings.xml</filename>. If you were developing an application at a large organization which values
      security, it is likely that the majority of the development group will not know the password to the production
      database. In an organization that draws a bold line between the development group and the operations group, this
      will be the norm. Developers may have access to a development and a staging environment, but they might not have
      (or want to have) access to the production database. There are a number of reasons why this makes sense,
      particularly if an organization is dealing with extremely sensitive financial, intelligence, or medical
      information. In this scenario, the production environment build may only be carried out by a lead developer or by
      a member of the production operations group. When they run this build using the <literal>prod</literal>
      <varname>environment.</varname><varname>type</varname>, they will need to define this variable in their
      <filename>settings.xml</filename> as follows:</para>

      <example>
        <title>Storing Secrets in a User-specific Settings Profile</title>

        <programlisting language="xml">&lt;settings&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
      &lt;properties&gt;
        &lt;environment.type&gt;prod&lt;/environment.type&gt;
        &lt;database.password&gt;m1ss10nimp0ss1bl3&lt;/database.password&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/settings&gt;
</programlisting>
      </example>

      <para>This user has defined a default profile which sets the
      <varname>environment.</varname><varname>type</varname> to <literal>prod</literal> and which also sets the
      production password. When the project is executed, the production profile is activated by the
      <varname>environment.</varname><varname>type</varname> property and the <varname>database.password</varname>
      property is populated. This way, you can put all of the production-specific configuration into a project's
      <filename>pom.xml</filename> and leave out only the single secret necessary to access the production
      database.</para>

      <note>
        <para>Secrets usually conflict with wide portability, but this makes sense. You wouldn't want to share your
        secrets openly.</para>
      </note>
    </section>

    <section id="profiles-sect-platform-classifier">
      <title>Platform Classifiers</title>

      <para>Let's assume that you have a library or a project that produces platform-specific customizations. Even
      though Java is platform-neutral, there are times when you might need to write some code that invokes
      platform-specific native code. Another possibility is that you've written some C code which is compiled by the
      Maven Native plugin and you want to produce a qualified artifact depending on the build platform. You can set a
      classifier with the Maven Assembly plugin or with the Maven Jar plugin. The following <filename>pom.xml</filename>
      produces a qualified artifact using profiles which are activated by Operation System parameters. For more
      information about the Maven Assembly plugin, see <xref linkend="assemblies" />.</para>

      <para><example>
          <title>Qualifying Artifacts with Platform Activated Project Profiles</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;windows&lt;/id&gt;
      &lt;activation&gt;
        &lt;os&gt;
          &lt;family&gt;windows&lt;/family&gt;
        &lt;/os&gt;
      &lt;/activation&gt;
      &lt;build&gt;
        &lt;plugins&gt;
          &lt;plugin
            &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
              &lt;classifier&gt;win&lt;/classifier&gt;
            &lt;/configuration&gt;
          &lt;/plugin&gt;
        &lt;/plugins&gt;
      &lt;/build&gt;
    &lt;/profile&gt;
    &lt;profile&gt;
      &lt;id&gt;linux&lt;/id&gt;
      &lt;activation&gt;
        &lt;os&gt;
          &lt;family&gt;unix&lt;/family&gt;
        &lt;/os&gt;
      &lt;/activation&gt;
      &lt;build&gt;
        &lt;plugins&gt;
          &lt;plugin&gt;
            &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
              &lt;classifier&gt;linux&lt;/classifier&gt;
            &lt;/configuration&gt;
          &lt;/plugin&gt;
        &lt;/plugins&gt;
      &lt;/build&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>If the Operating System is in the Windows family, this <filename>pom.xml</filename> qualifies the JAR
      artifact with "-win". If the Operating System is in the Unix family, the artifact is qualified with "-linux". This
      <filename>pom.xml</filename> successfully adds the qualifiers to the artifacts, but it is more verbose than it
      need to be due to the redundant configuration of the Maven Jar plugin in both profiles. This example could be
      rewritten to use variable substitution to minimize redundancy as follows:</para>

      <para><example>
          <title>Qualifying Artifacts with Platform Activated Project Profiles and Variable Substitution</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;classifier&gt;\${envClassifier}&lt;/classifier&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;windows&lt;/id&gt;
      &lt;activation&gt;
        &lt;os&gt;
          &lt;family&gt;windows&lt;/family&gt;
        &lt;/os&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;envClassifier&gt;win&lt;/envClassifier&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
    &lt;profile&gt;
      &lt;id&gt;linux&lt;/id&gt;
      &lt;activation&gt;
        &lt;os&gt;
          &lt;family&gt;unix&lt;/family&gt;
        &lt;/os&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;envClassifier&gt;linux&lt;/envClassifier&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>In this <filename>pom.xml</filename>, each profile doesn't need to include a <sgmltag>build</sgmltag>
      element to configure the Jar plugin. Instead, each profile is activated by the Operating System family and sets
      the <varname>envClassifier</varname> property to either <literal>win</literal> or <literal>linux</literal>. This
      <varname>envClassifier</varname> is then referenced in the default <filename>pom.xml</filename>
      <sgmltag>build</sgmltag> element to add a classifier to the project's JAR artifact. The JAR artifact will be named
      <code>\${finalName}-\${envClassifier}.jar </code>and included as a dependency using the following dependency
      syntax:</para>

      <para><example>
          <title>Depending on a Qualified Artifact</title>

          <programlisting language="xml">&lt;dependency&gt;
      &lt;groupId&gt;com.mycompany&lt;/groupId&gt;
      &lt;artifactId&gt;my-project&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;classifier&gt;linux&lt;/classifier&gt;
    &lt;/dependency&gt;
</programlisting>
        </example></para>
    </section>
  </section>

  <section id="profiles-sect-summary">
    <title>Summary</title>

    <para>When used judiciously, profiles can make it very easy to customize a build for different platforms. If
    something in your build needs to define a platform-specific path for something like an application server, you can
    put these configuration points in a profile which is activated by an operating system parameter. If you have a
    project which needs to produce different artifacts for different environments, you can customize the build behavior
    for different environments and platforms via profile-specific plugin behavior. Using profiles, builds can become
    portable, there is no need to rewrite your build logic to support a new environment, just override the configuration
    that needs to change and share the configuration points which can be shared.</para>
  </section>
</chapter>
