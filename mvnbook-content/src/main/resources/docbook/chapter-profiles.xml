<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="profiles" lang="fr">
  <title>Profils de Build</title>

  <section id="profiles-sect-what">
    <title>À quoi servent-ils ?</title>

    <para>Les profils permettent de personnaliser un build particulier pour un environnement particulietr; les profils assurent la portabilité entre différents environnements de build.</para>

    <para>Qu'entendons-nous par différents environnements de build ? La production et le développement sont deux environnements typiques. 
Quand vous travaillez dans l'environnement de développement, votre système est certainement configuré pour travailler sur une base de donnée de développement installée sur le poste local tandis qu'en production, votre système est configuré pour lire dans une base de donnée de production. 
Maven permet de définir un nombre quelconque d'environnements de build (profils de build) qui peuvent remplacer n'importe quel paramètre dans le <filename>pom.xml</filename>. Vous pourriez configurer votre application pour lire dans votre base de donnée de développement locale dans un profil "development", 
et la configurer pour lire dans la base de donnée de production dans le profil "production". 
Les profils peuvent également être activés en fonction de l'environnement et de la plateforme, vous pouvez personnaliser un build pour s'exécuter différemment en fonction du système d'exploitation ou de la version du <acronym>JDK</acronym> installé. 
Avant que nous parlions de l'utilisation et la configuration des profils Maven, nous devons définir le concept de Portabilité du Buidl.</para>

    <section id="profiles-sect-portability">
      <title>Qu'est ce que la Portabilité du Build ?</title>

      <para>La "portabilité" du build est la mesure de la facilité avec laquelle on peut prendre un projet particulier et le construire sur différents environnements. 
Un build qui fonctionne sans aucune configuration particulière ni personnalisation des fichiers properties est plus portable qu'un build qui nécessite une quantité de travail pour construire un projet depuis 0. Les projets les plus portables sont bien souvent des projets open source très utilisés comme Apache Commons ou Apache Velocity qui fonctionnent avec Maven sans personnalisation ou presque. 
Pour faire simple, les builds les plus portables fonctionnent, et les moins portables vous demander de jongler et configurer les chemins vers les outils de build en fonction des plateformes. 
Avant que nousvous dévoilions comment obtenir un build portable, étudions les différents types de portabilité dont nous allons parler.</para>

      <section id="profiles-sect-non-portable">
        <title>Builds non portables</title>

        <para>Le manque de portabilité est exactement ce que les outils de build essayent d'éviter - cependant, n'importe quel outil peut être configuré pour être non-portable
        (même Maven). Un projet non-portable peut être construit seulement dans certaines circonstances spécifiques (ex : votre machine locale).
        A moins que vous travailliez seul et que vous n'envisagiez pas de déployer votre application sur une autre machine, il vaut mieux éviter complètement la non-portabilité.
        Un build non-portable fonctionne seulement sur une machine, c'est un build "à usage unique". Maven est conçu pour décourager les buids non-portable en offrant la possibilité de personnaliser les builds en utilisant les profils.</para>
        <para>Quand un développeur récupère le code source d'un projet non-portable,
        il ne sera pas en mesure de construire le projet sans remanier une grosse partie du script de build.</para>
      </section>

      <section id="profiles-sect-environment-portability">
        <title>Portabilité sur l'environnement</title>

        <para>Un build est qualifié de portable d'un environnement à l'autre s'il possède un mécanisme pour personnaliser le comportement et la configuration en fonction de l'environnement.
Un projet qui contient une référence à une base de donnée de test dans un environnement de test, par exemple, et à une base de donnée de production dans un environnement de production, est portable sur des environnements. 
Il est probable que ce build ait différentes propriétés pour chaque environnement.
Quand vous changez d'environnement, un qui n'est pas défini et qui ne possède pas de profile associé, le projet ne fonctionnera pas. Donc ce n'est portable que sur des environnements bien définis.</para>

        <para>Quand un nouveau développeur récupère le code source d'un projet dépendant de l'environnement, il devra exécuter le build dans cet environnement ou créer un environnement adequat pour pouvoir construire le projet avec succès.</para>
      </section>

      <section id="profiles-sect-org-portability">
        <title>Portabilité interne à une organisation</title>

        <para>The center of this level of portability is a project's
        requirement that only a select few may access internal resources such
        as source control or an internally-maintained Maven repository. A
        project at a large corporation may depend on a database available only
        to in-house developers, or an open source project might require a
        specific level of credentials to publish a web site and deploy the
        products of a build to a public repository.</para>

        <para>If you attempt to build an in-house project from scratch outside
        of the in-house network (for example, outside of a corporate
        firewall), the build will fail. It may fail because certain required
        custom plugins are unavailable, or project dependencies cannot be
        found because you don't have the appropriate credentials to retrieve
        dependencies from a custom remote repository. Such a project is
        portable only across environments in a single organization.</para>
      </section>

      <section id="profiles-sect-wide-portability">
        <title>Wide (Universal) Portability</title>

        <para>Anyone may download a widely portable project's source, compile,
        and install it without customizing a build for a specific environment.
        This is the highest level of portability; anything less requires extra
        work for those who wish to build your project. This level of
        portability is especially important for open source projects, which
        depend on the ability for would-be contributors to easily download and
        build from source.</para>

        <para>Any developer could download the source for a widely portable
        project.</para>
      </section>
    </section>

    <section id="profiles-sect-select-level">
      <title>Selecting an Appropriate Level of Portability</title>

      <para>Clearly, you'll want to avoid creating the worst-case scenario:
      the non-portable build. You may have had the misfortune to work or study
      at an organization that had critical applications with non-portable
      builds. In such organizations, you cannot deploy an application without
      the help of a specific individual on a specific machine. In such an
      organization, it is also very difficult to introduce new project
      dependencies or changes without coordinating the change with the single
      person who maintains such a non-portable build. Non-portable builds tend
      to grow in highly political environments when one individual or group
      needs to exert control over how and when a project is built and
      deployed. "How do we build the system? Oh, we've got to call Jack and
      ask him to build it for us, no one else deploys to production." That is
      a dangerous situation which is more common that you would think. If you
      work for this organization, Maven and Maven profiles provide a way out
      of this mess.</para>

      <para>On the opposite end of the portability spectrum are widely
      portable builds. Widely portable builds are generally the most difficult
      build systems to attain. These builds restrict your dependencies to
      those projects and tools that may be freely distributed and are publicly
      available. Many commercial software packages might be excluded from the
      most-portable builds because they cannot be downloaded before you have
      accepted a certain license. Wide portability also restricts dependencies
      to those pieces of software that may be distributed as Maven artifacts.
      For example, if you depend upon Oracle JDBC drivers, your users will
      have to download and install them manually; this is not widely portable
      as you will have to distribute a set of environment setup instructions
      for people interested in building your application. On the other hand,
      you could use a JDBC driver which is available from the public Maven
      repositories like MySQL or HSQLDB.</para>

      <para>As stated previously, open source projects benefit from having the
      most widely portable build possible. Widely portable builds reduce the
      inefficiencies associated with contributing to a project. In an open
      source project (such as Maven) there are two distinct groups: end-users
      and developers. When an end-user uses a project like Maven and decides
      to contribute a patch to Maven, they have to make the transition from
      using the output of a build to running a build. They have to first
      become a developer, and if it is difficult to learn how to build a
      project, this end-user has a disincentive to take the time to contribute
      to a project. In a widely portable project, an end-user doesn't have to
      follow a set or arcane build instructions to start becoming a developer,
      they can download the source, modify the source, build, and submit a
      contribution without asking someone to help them set up a build
      environment. When the cost of contributing source back to an open-source
      project is lower, you'll see an increase in source code contributions,
      especially casual contributions which can make the difference between a
      project's success and a project's failure. One side-effect of Maven's
      adoption across a wide group of open source projects is that it has made
      it easier for developers to contribute code to various open source
      projects.</para>
    </section>
  </section>

  <section id="profiles-sect-maven-profiles">
    <title>Portability through Maven Profiles</title>

    <para>Un profil dans Maven est un ensemble alternatif de valeurs qui définissent ou écrasent les valeurs par défaut.
    En utilisant un profil, vous pouvez personnaliser un build pour différents environnements. Les profils sont configurés dans le
    <filename>pom.xml</filename> et possèdent un identifiant. Vous pouez ensuite exécuter Maven en précisant dans la ligne de commande le profil à utiliser.
Le <filename>pom.xml</filename> suivant utilise un profil <literal>production</literal> pour écraser les paramètres par défaut du plugin Compiler.</para>

    <example>
      <title>Utilisation d'un profil Maven pour écraser les paramètres du compilateur pour la production</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;simple&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;name&gt;simple&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;profiles&gt;<co id="coDef-profiles-compile-1"
          linkends="coRef-profiles-compile-1" />
    &lt;profile&gt;
      &lt;id&gt;production&lt;/id&gt;<co id="coDef-profiles-compile-2"
          linkends="coRef-profiles-compile-2" />
      &lt;build&gt;<co id="coDef-profiles-compile-3"
          linkends="coDef-profiles-compile-3" />
        &lt;plugins&gt;
          &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
              &lt;debug&gt;false&lt;/debug&gt;<co
          id="coDef-profiles-compile-4" linkends="coDef-profiles-compile-4" />
              &lt;optimize&gt;true&lt;/optimize&gt;
            &lt;/configuration&gt;
          &lt;/plugin&gt;
        &lt;/plugins&gt;
      &lt;/build&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>Dans cet exemple, nous avons ajouté un profil nommé <literal>production</literal> 
pour écraser la configuration par défaut du plugin Maven. Examinons la syntaxe de ce profil en détail.</para>

    <calloutlist>
      <callout arearefs="coDef-profiles-compile-1"
               id="coRef-profiles-compile-1">
        <para>L'élément <sgmltag>profiles</sgmltag> est dans le 
        <filename>pom.xml</filename>, il contient un ou plusieurs éléments
        <sgmltag>profile</sgmltag>. Puisque les profils écrasent les paramètres par défaut dans le <filename>pom.xml</filename>, l'élément
        <sgmltag>profiles</sgmltag> est habituellement positionné en fin de <filename>pom.xml</filename>.</para>
      </callout>

      <callout arearefs="coDef-profiles-compile-2"
               id="coRef-profiles-compile-2">
        <para>Chaque profil doit avoir un élément <sgmltag>id</sgmltag>. Cet element
        <sgmltag>id</sgmltag> contient le nom qui est utilisé pour invoquer ce profil sur la ligne de commande.
Un profil est invoqué en passant l'argument <command>-P&lt;profile_id&gt;</command> à la ligne de commande Maven.</para>
      </callout>

      <callout arearefs="coDef-profiles-compile-3"
               id="coRef-profiles-compile-3">
        <para>Un élément <sgmltag>profile</sgmltag> peut contenir de nombreux éléments contenus dans l'élément <sgmltag>project</sgmltag>
        d'un POM. Dans cet exemple, nous écrasons le comportement du plugin Compiler et nous devons écraser la configuration du plugin qui se trouve normalement
dans l'élément <sgmltag>build</sgmltag> et <sgmltag>plugins</sgmltag>.</para>
      </callout>

      <callout arearefs="coDef-profiles-compile-4"
               id="coRef-profiles-compile-4">
        <para>Nous écrasons We're overriding the configuration of the Maven Compiler plugin.
        We're making sure that the bytecode produced by the production profile
        doesn't contain debug information and that the bytecode has gone
        through the compiler's optimization routines.</para>
      </callout>
    </calloutlist>

    <para>To execute <command>mvn install</command> under the
    <literal>production</literal> profile, you need to pass the
    <command>-Pproduction</command> argument on the command-line. To verify
    that the <literal>production</literal> profile overrides the default
    Compiler plugin configuration, execute Maven with debug output enabled
    (<command>-X</command>) as follows:</para>

    <screen>~/examples/profile $ <command>mvn clean install -Pproduction -X</command>
... (omitting debugging output) ...
[DEBUG] Configuring mojo 'o.a.m.plugins:maven-compiler-plugin:2.0.2:testCompile'
[DEBUG]   (f) basedir = ~\examples\profile
[DEBUG]   (f) buildDirectory = ~\examples\profile\target
...
[DEBUG]   (f) compilerId = javac
[DEBUG]   (f) <emphasis>debug = false</emphasis>
[DEBUG]   (f) failOnError = true
[DEBUG]   (f) fork = false
[DEBUG]   (f) <emphasis>optimize = true</emphasis>
[DEBUG]   (f) outputDirectory = \
          ~\svnw\sonatype\examples\profile\target\test-classes
[DEBUG]   (f) outputFileName = simple-1.0-SNAPSHOT
[DEBUG]   (f) showDeprecation = false
[DEBUG]   (f) showWarnings = false
[DEBUG]   (f) staleMillis = 0
[DEBUG]   (f) verbose = false
[DEBUG] -- end configuration --
... (omitting debugging output) ...
</screen>

    <para>This excerpt from the debug output of Maven shows the configuration
    of the Compiler plugin under the production profile. As shown in the
    output, <varname>debug</varname> is set to false and
    <varname>optimize</varname> is set to true.</para>

    <section id="profiles-sect-overriding-pom">
      <title>Overriding a Project Object Model</title>

      <para>While the previous example showed you how to override the default
      configuration properties of a single Maven plugin, you still don't know
      exactly what a Maven profile is allowed to override. The short-answer to
      that question is that a Maven profile can override almost everything
      that you would have in a <filename>pom.xml</filename>. The Maven
      <acronym>POM</acronym> contains an element under project called
      <sgmltag>profiles</sgmltag> containing a project's alternate
      configurations, and under this element are profile elements which define
      each profile. Each profile must have an <sgmltag>id</sgmltag>, and other
      than that, it can contain almost any of the elements one would expect to
      see under project. The following <acronym>XML</acronym> document shows
      all of the elements, a profile is allowed to override.</para>

      <para><example>
          <title>Elements Allowed in a Profile</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;build&gt;
        &lt;defaultGoal&gt;...&lt;/defaultGoal&gt;
        &lt;finalName&gt;...&lt;/finalName&gt;
        &lt;resources&gt;...&lt;/resources&gt;
        &lt;testResources&gt;...&lt;/testResources&gt;
        &lt;plugins&gt;...&lt;/plugins&gt;
      &lt;/build&gt;
      &lt;reporting&gt;...&lt;/reporting&gt;
      &lt;modules&gt;...&lt;/modules&gt;
      &lt;dependencies&gt;...&lt;/dependencies&gt;
      &lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt;
      &lt;distributionManagement&gt;...&lt;/distributionManagement&gt;
      &lt;repositories&gt;...&lt;/repositories&gt;
      &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt;
      &lt;properties&gt;...&lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>A profile can override an element shown with ellipses. A profile
      can override the final name of a project's artifact in a profile, the
      dependencies, and the behavior of a project's build via plugin
      configuration. A profile can also override the configuration of
      distribution settings depending on the profile; for example, if you need
      to publish an artifact to a staging server in a staging profile, you
      would create a staging profile which overrides the
      <sgmltag>distributionManagement</sgmltag> element in a profile.</para>
    </section>
  </section>

  <section id="profiles-sect-activation">
    <title>Profile Activation</title>

    <para>In the previous section we showed you how to create a profile that
    overrides default behavior for a specific target environment. In the
    previous build the default build was designed for development and the
    <literal>production</literal> profile exists to provide configuration for
    a production environment. What happens when you need to provide
    customizations based on variables like operating systems or
    <acronym>JDK</acronym> version? Maven provides a way to "activate" a
    profile for different environmental parameters, this is called profile
    activation.</para>

    <para>Take the following example, assume that we have a Java library that
    has a specific feature only available in the Java 6 release: the Scripting
    Engine as defined in <ulink
    url="http://jcp.org/en/jsr/detail?id=223">JSR-223</ulink>. You've
    separated the portion of the library that deals with the scripting library
    into a separate Maven project, and you want people running Java 5 to be
    able to build the project without attempting to build the Java 6 specific
    library extension. You can do this by using a Maven profile that adds the
    script extension module to the build only when the build is running within
    a Java 6 <acronym>JDK</acronym>. First, let's take a look at our project's
    directory layout and how we want developers to build the system.</para>

    <para>When someone runs <command>mvn install</command> with a Java 6
    <acronym>JDK</acronym>, you want the build to include the
    <literal>simple-script</literal> project's build, when they are running in
    Java 5, you would like to skip the <literal>simple-script</literal>
    project build. If you failed to skip the <literal>simple-script</literal>
    project build in Java 5, your build would fail because Java 5 does not
    have the <classname>ScriptEngine</classname> on the classpath. Let's take
    a look at the library project's <filename>pom.xml</filename>:</para>

    <example>
      <title>Dynamic Inclusion of Submodules Using Profile Activation</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                             http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;simple&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;name&gt;simple&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;jdk16&lt;/id&gt;
      &lt;activation&gt;<co id="coDef-profiles-active-1"
          linkends="coRef-profiles-active-1" />
        &lt;jdk&gt;1.6&lt;/jdk&gt;
      &lt;/activation&gt;
      &lt;modules&gt;<co id="coDef-profiles-active-2" lang=""
          linkends="coRef-profiles-active-2" />
        &lt;module&gt;simple-script&lt;/module&gt;
      &lt;/modules&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>If you run <command>mvn install</command> under Java 1.6, you will
    see Maven descending into the <filename>simple-script</filename>
    subdirectory to build the <literal>simple-script</literal> project. If you
    are running <command>mvn install</command> in Java 1.5, the build will not
    try to build the <literal>simple-script</literal> submodule. Exploring
    this activation configuration in more detail:</para>

    <calloutlist>
      <callout arearefs="coDef-profiles-active-1" id="coRef-profiles-active-1">
        <para>The <sgmltag>activation</sgmltag> element lists the conditions
        for profile activation. In this example, we've specified that this
        profile will be activated by Java versions that begin with "1.6". This
        would include "1.6.0_03", "1.6.0_02", or any other string that began
        with "1.6". Activation parameters are not limited to Java version, for
        a full list of activation parameters, see <xref
        linkend="profiles-sect-activation-config"
        xrefstyle="select:title" />.</para>
      </callout>

      <callout arch="" arearefs="coDef-profiles-active-2"
               id="coRef-profiles-active-2">
        <para>In this profile we are adding the module
        <literal>simple-script</literal>. Adding this module will cause Maven
        to look in the <filename>simple-script/</filename> subdirectory for a
        <filename>pom.xml</filename>.</para>
      </callout>
    </calloutlist>

    <section id="profiles-sect-activation-config">
      <title>Activation Configuration</title>

      <para>Activations can contain one of more selectors including JDK
      versions, Operating System parameters, files, and properties. A profile
      is activated when all activation criteria has been satisfied. For
      example, a profile could list an Operating System family of Windows, and
      a JDK version of 1.4, this profile will only be activated when the build
      is executed on a Windows machine running Java 1.4. If the profile is
      active then all elements override the corresponding project-level
      elements as if the profile were included with the <command>-P</command>
      command-line argument. The following example, lists a profile which is
      activated by a very specific combination of operating system parameters,
      properties, and a JDK version.</para>

      <para><example>
          <title>Profile Activation Parameters: JDK Version, OS Parameters,
          and Properties</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;dev&lt;/id&gt;
      &lt;activation&gt;
        &lt;activeByDefault&gt;false&lt;/activeByDefault&gt;<co
              id="coDef-profiles-active2-1"
              linkends="coRef-profiles-active2-1" />
        &lt;jdk&gt;1.5&lt;/jdk&gt;<co id="coDef-profiles-active2-2"
              linkends="coRef-profiles-active2-2" />
        &lt;os&gt;
          &lt;name&gt;Windows XP&lt;/name&gt;<co id="coDef-profiles-active2-3"
              linkends="coRef-profiles-active2-3" />
          &lt;family&gt;Windows&lt;/family&gt;
          &lt;arch&gt;x86&lt;/arch&gt;
          &lt;version&gt;5.1.2600&lt;/version&gt;
        &lt;/os&gt;
        &lt;property&gt;
          &lt;name&gt;mavenVersion&lt;/name&gt;<co
              id="coDef-profiles-active2-4"
              linkends="coRef-profiles-active2-4" />
          &lt;value&gt;2.0.5&lt;/value&gt;
        &lt;/property&gt;
        &lt;file&gt;
          &lt;exists&gt;file2.properties&lt;/exists&gt;<co
              id="coDef-profiles-active2-5"
              linkends="coRef-profiles-active2-5" />
          &lt;missing&gt;file1.properties&lt;/missing&gt;
        &lt;/file&gt;
      &lt;/activation&gt;
      ...
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>This previous example defines a very narrow set of activation
      parameters. Let's examine each activation criterion in detail:</para>

      <calloutlist>
        <callout arearefs="coDef-profiles-active2-1"
                 id="coRef-profiles-active2-1">
          <para>The <sgmltag>activeByDefault</sgmltag> element controls
          whether this profile is considered active by default.</para>
        </callout>

        <callout arearefs="coDef-profiles-active2-2"
                 id="coRef-profiles-active2-2">
          <para>This profile will only be active for JDK versions that begin
          with "1.5". This includes "1.5.0_01", "1.5.1".</para>
        </callout>

        <callout arearefs="coDef-profiles-active2-3"
                 id="coRef-profiles-active2-3">
          <para>This profile targets a very specific version of Windows XP,
          version 5.1.2600 on a 32-bit platform. If your project uses the
          native plugin to build a C program, you might find yourself writing
          projects for specific platforms.</para>
        </callout>

        <callout arearefs="coDef-profiles-active2-4"
                 id="coRef-profiles-active2-4">
          <para>The <sgmltag>property</sgmltag> element tells Maven to
          activate this profile if the property
          <varname>mavenVersion</varname> is set to the value
          <literal>2.0.5</literal>. <varname>mavenVersion</varname> is an
          implicit property that is available to all Maven builds.</para>
        </callout>

        <callout arearefs="coDef-profiles-active2-5"
                 id="coRef-profiles-active2-5">
          <para>The <sgmltag>file</sgmltag> element allows us to activate a
          profile based on the presence (or absence) of files. The
          <literal>dev</literal> profile will be activated if a file named
          <filename>file2.properties</filename> exists in the base directory
          of the project. The <literal>dev</literal> profile will only be
          activated if there is no file named
          <filename>file1.properties</filename> file in the base directory of
          the project.</para>
        </callout>
      </calloutlist>
    </section>

    <section id="profiles-sect-activation-by-absence">
      <title>Activation by the Absence of a Property</title>

      <para>You can activate a profile based on the value of a property like
      <varname>environment.type</varname>. You can activate a
      <literal>development</literal> profile if
      <varname>environment.type</varname> equals <literal>dev</literal>, or a
      <literal>production</literal> profile if
      <varname>environment.type</varname> equals <literal>prod</literal>. You
      can also activate a profile in the absence of a property. The following
      configuration activates a profile if the property
      <varname>environment.type</varname> is not present during Maven
      execution.</para>

      <para><example>
          <title>Activating Profiles in the Absence of a Property</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;development&lt;/id&gt;
      &lt;activation&gt;
        &lt;property&gt;
          &lt;name&gt;!environment.type&lt;/name&gt;
        &lt;/property&gt;
      &lt;/activation&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>Note the exclamation point prefixing the property name. The
      exclamation point is often referred to as the "bang" character and
      signifies "not". This profile is activated when no
      <varname>\${environment.type}</varname> property is set.</para>
    </section>
  </section>

  <section id="profiles-sect-listing-active-profiles">
    <title>Listing Active Profiles</title>

    <para>Maven profiles can be defined in either
    <filename>pom.xml</filename>, <filename>profiles.xml</filename>,
    <filename>~/.m2/settings.xml</filename>, or
    <filename>\${M2_HOME}/conf/settings.xml</filename>. With these four levels,
    there's no good way of keeping track of profiles available to a particular
    project without remembering which profiles are defined in these four
    files. To make it easier to keep track of which profiles are available,
    and where they have been defined, the Maven Help plugin defines a goal,
    <literal>active-profiles</literal>, which lists all the active profiles
    and where they have been defined. You can run the
    <literal>active-profiles</literal> goal, as follows:</para>

    <screen>$ <command>mvn help:active-profiles</command>
Active Profiles for Project 'My Project':

The following profiles are active:

 - my-settings-profile (source: settings.xml)
 - my-external-profile (source: profiles.xml)
 - my-internal-profile (source: pom.xml)</screen>
  </section>

  <section id="profiles-sect-tips-tricks">
    <title>Tips and Tricks</title>

    <para>Profiles can encourage build portability. If your build needs subtle
    customizations to work on different platforms or if you need your build to
    produce different results for different target platforms, project profiles
    increase build portability. Settings profiles generally decrease build
    portability by adding extra-project information that must be communicated
    from developer to developer. The following sections provide some
    guidelines and some ideas for applying Maven profiles to your
    project.</para>

    <section id="profiles-sect-common-envs">
      <title>Common Environments</title>

      <para>One of the core motivations for Maven project profiles was to
      provide for environment-specific configuration settings. In a
      development environment, you might want to produce bytecode with debug
      information and you might want to configure your system to use a
      development database instance. In a production environment you might
      want to produce a signed JAR and configure the system to use a
      production database. In this chapter, we defined a number of
      environments with identifiers like <literal>dev</literal> and
      <literal>prod</literal>. A simpler way to do this would be to define
      profiles that are activated by environment properties and to use these
      common environment properties across all of your projects. For example,
      if every project had a <literal>development</literal> profile activated
      by a property named <varname>environment.type</varname> having a value
      of <literal>dev</literal>, and if those same projects had a
      <literal>production</literal> profile activated by a property named
      <varname>environment.type</varname> having a value of
      <literal>prod</literal>, you could create a default profile in your
      <filename>settings.xml</filename> that always set
      <varname>environment.type</varname> to <literal>dev</literal> on your
      development machine. This way, each project defines a
      <literal>dev</literal> profile activated by the same environment
      variable. Let's see how this is done, the following
      <filename>settings.xml</filename> defines a profile in
      <filename>~/.m2/settings.xml</filename> which sets the
      <varname>environment.type</varname> property to
      <literal>dev</literal>.</para>

      <para><example>
          <title>~/.m2/settings.xml defines a default profile setting
          environment.type</title>

          <programlisting language="xml">&lt;settings&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;activation&gt;
        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;environment.type&gt;dev&lt;/environment.type&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/settings&gt;
</programlisting>
        </example></para>

      <para>This means that every time you run Maven on your machine, this
      profile will be activated and the property
      <varname>environment.type</varname> will have the value
      <literal>dev</literal>. You can then use this property to activate
      profiles defined in a project's <filename>pom.xml</filename> as follows.
      Let's take a look at how a project's <filename>pom.xml</filename> would
      define a profile activated by <varname>environment.type</varname> having
      the value <literal>dev</literal>.</para>

      <para><example id="ex-profile-envtype-pom">
          <title>Project Profile Activated by environment.type equalling
          'dev'</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;development&lt;/id&gt;
      &lt;activation&gt;
        &lt;property&gt;
          &lt;name&gt;environment.type&lt;/name&gt;
          &lt;value&gt;dev&lt;/value&gt;
        &lt;/property&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;database.driverClassName&gt;com.mysql.jdbc.Driver&lt;/database.driverClassName&gt;
        &lt;database.url&gt;
          jdbc:mysql://localhost:3306/app_dev
        &lt;/database.url&gt;
        &lt;database.user&gt;development_user&lt;/database.user&gt;
        &lt;database.password&gt;development_password&lt;/database.password&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
    &lt;profile&gt;
      &lt;id&gt;production&lt;/id&gt;
      &lt;activation&gt;
        &lt;property&gt;
          &lt;name&gt;environment.type&lt;/name&gt;
          &lt;value&gt;prod&lt;/value&gt;
        &lt;/property&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;database.driverClassName&gt;com.mysql.jdbc.Driver&lt;/database.driverClassName&gt;
        &lt;database.url&gt;jdbc:mysql://master01:3306,slave01:3306/app_prod&lt;/database.url&gt;
        &lt;database.user&gt;prod_user&lt;/database.user&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>This project defines some properties like
      <varname>database.url</varname> and <varname>database.user</varname>
      which might be used to configure another Maven plugin configured in the
      <filename>pom.xml</filename>. There are plugins available that can
      manipulate the database, run SQL, and plugins like the Maven Hibernate3
      plugin which can generate annotated model objects for use in persistence
      frameworks. A few of these plugins, can be configured in a
      <filename>pom.xml</filename> using these properties. These properties
      could also be used to filter resources. In this example, because we've
      defined a profile in <filename>~/.m2/settings.xml</filename> which sets
      <varname>environment.type</varname> to <literal>dev</literal>, the
      development profile will always be activated when we run Maven on our
      development machine. Alternatively, if we wanted to override this
      default, we could set a property on the command-line. If we need to
      activate the production profile, we could always run Maven with:</para>

      <screen>~/examples/profiles $ <command>mvn install -Denvironment.type=prod</command></screen>

      <para>Setting a property on the command-line would override the default
      property set in <filename>~/.m2/settings.xml</filename>. We could have
      just defined a profile with an <sgmltag>id</sgmltag> of "dev" and
      invoked it directly with the <command>-P</command> command-line
      argument, but using this <varname>environment.type</varname> property
      allows us to code other project <filename>pom.xml</filename> files to
      this standard. Every project in your codebase could have a profile which
      is activated by the same <varname>environment.type</varname> property
      set in every user's <filename>~/.m2/settings.xml</filename>. In this
      way, developers can share common configuration for development without
      defining this configuration in non-portable
      <filename>settings.xml</filename> files.</para>
    </section>

    <section id="profiles-sect-protecting-secrets">
      <title>Protecting Secrets</title>

      <para>This best practice builds upon the previous section. In <xref
      linkend="ex-profile-envtype-pom" xrefstyle="select:title" />, the
      production profile does not contain the
      <varname>database.password</varname> property. I've done this on purpose
      to illustrate the concept of putting secrets in you user-specific
      <filename>settings.xml</filename>. If you were developing an application
      at a large organization which values security, it is likely that the
      majority of the development group will not know the password to the
      production database. In an organization that draws a bold line between
      the development group and the operations group, this will be the norm.
      Developers may have access to a development and a staging environment,
      but they might not have (or want to have) access to the production
      database. There are a number of reasons why this makes sense,
      particularly if an organization is dealing with extremely sensitive
      financial, intelligence, or medical information. In this scenario, the
      production environment build may only be carried out by a lead developer
      or by a member of the production operations group. When they run this
      build using the <literal>prod</literal>
      <varname>environment.type</varname>, they will need to define this
      variable in their <filename>settings.xml</filename> as follows:</para>

      <example>
        <title>Storing Secrets in a User-specific Settings Profile</title>

        <programlisting language="xml">&lt;settings&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
      &lt;properties&gt;
        &lt;environment.type&gt;prod&lt;/environment.type&gt;
        &lt;database.password&gt;m1ss10nimp0ss1bl3&lt;/database.password&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/settings&gt;
</programlisting>
      </example>

      <para>This user has defined a default profile which sets the
      <varname>environment.type</varname> to <literal>prod</literal> and which
      also sets the production password. When the project is executed, the
      production profile is activated by the
      <varname>environment.type</varname> property and the
      <varname>database.password</varname> property is populated. This way,
      you can put all of the production-specific configuration into a
      project's <filename>pom.xml</filename> and leave out only the single
      secret necessary to access the production database.</para>

      <note>
        <para>Secrets usually conflict with wide portability, but this makes
        sense. You wouldn't want to share your secrets openly.</para>
      </note>
    </section>

    <section id="profiles-sect-platform-classifier">
      <title>Platform Classifiers</title>

      <para>Let's assume that you have a library or a project that produces
      platform-specific customizations. Even though Java is platform-neutral,
      there are times when you might need to write some code that invokes
      platform-specific native code. Another possibility is that you've
      written some C code which is compiled by the Maven Native plugin and you
      want to produce a qualified artifact depending on the build platform.
      You can set a classifier with the Maven Assembly plugin or with the
      Maven Jar plugin. The following <filename>pom.xml</filename> produces a
      qualified artifact using profiles which are activated by Operation
      System parameters. For more information about the Maven Assembly plugin,
      see <xref linkend="assemblies" />.</para>

      <para><example>
          <title>Qualifying Artifacts with Platform Activated Project
          Profiles</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;windows&lt;/id&gt;
      &lt;activation&gt;
        &lt;os&gt;
          &lt;family&gt;windows&lt;/family&gt;
        &lt;/os&gt;
      &lt;/activation&gt;
      &lt;build&gt;
        &lt;plugins&gt;
          &lt;plugin
            &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
              &lt;classifier&gt;win&lt;/classifier&gt;
            &lt;/configuration&gt;
          &lt;/plugin&gt;
        &lt;/plugins&gt;
      &lt;/build&gt;
    &lt;/profile&gt;
    &lt;profile&gt;
      &lt;id&gt;linux&lt;/id&gt;
      &lt;activation&gt;
        &lt;os&gt;
          &lt;family&gt;unix&lt;/family&gt;
        &lt;/os&gt;
      &lt;/activation&gt;
      &lt;build&gt;
        &lt;plugins&gt;
          &lt;plugin&gt;
            &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
              &lt;classifier&gt;linux&lt;/classifier&gt;
            &lt;/configuration&gt;
          &lt;/plugin&gt;
        &lt;/plugins&gt;
      &lt;/build&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>If the Operating System is in the Windows family, this
      <filename>pom.xml</filename> qualifies the JAR artifact with "-win". If
      the Operating System is in the Unix family, the artifact is qualified
      with "-linux". This <filename>pom.xml</filename> successfully adds the
      qualifiers to the artifacts, but it is more verbose than it need to be
      due to the redundant configuration of the Maven Jar plugin in both
      profiles. This example could be rewritten to use variable substitution
      to minimize redundancy as follows:</para>

      <para><example>
          <title>Qualifying Artifacts with Platform Activated Project Profiles
          and Variable Substitution</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;classifier&gt;\${envClassifier}&lt;/classifier&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;windows&lt;/id&gt;
      &lt;activation&gt;
        &lt;os&gt;
          &lt;family&gt;windows&lt;/family&gt;
        &lt;/os&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;envClassifier&gt;win&lt;/envClassifier&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
    &lt;profile&gt;
      &lt;id&gt;linux&lt;/id&gt;
      &lt;activation&gt;
        &lt;os&gt;
          &lt;family&gt;unix&lt;/family&gt;
        &lt;/os&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;envClassifier&gt;linux&lt;/envClassifier&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>In this <filename>pom.xml</filename>, each profile doesn't need to
      include a <sgmltag>build</sgmltag> element to configure the Jar plugin.
      Instead, each profile is activated by the Operating System family and
      sets the <varname>envClassifier</varname> property to either
      <literal>win</literal> or <literal>linux</literal>. This
      <varname>envClassifier</varname> is then referenced in the default
      <filename>pom.xml</filename> <sgmltag>build</sgmltag> element to add a
      classifier to the project's JAR artifact. The JAR artifact will be named
      <code>\${finalName}-\${envClassifier}.jar</code> and included as a
      dependency using the following dependency syntax:</para>

      <para><example>
          <title>Depending on a Qualified Artifact</title>

          <programlisting language="xml">&lt;dependency&gt;
      &lt;groupId&gt;com.mycompany&lt;/groupId&gt;
      &lt;artifactId&gt;my-project&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;classifier&gt;linux&lt;/classifier&gt;
    &lt;/dependency&gt;
</programlisting>
        </example></para>
    </section>
  </section>

  <section id="profiles-sect-summary">
    <title>Summary</title>

    <para>When used judiciously, profiles can make it very easy to customize a
    build for different platforms. If something in your build needs to define
    a platform-specific path for something like an application server, you can
    put these configuration points in a profile which is activated by an
    operating system parameter. If you have a project which needs to produce
    different artifacts for different environments, you can customize the
    build behavior for different environments and platforms via
    profile-specific plugin behavior. Using profiles, builds can become
    portable, there is no need to rewrite your build logic to support a new
    environment, just override the configuration that needs to change and
    share the configuration points which can be shared.</para>
  </section>
</chapter>
