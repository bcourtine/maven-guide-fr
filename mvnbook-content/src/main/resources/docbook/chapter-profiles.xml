<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="profiles" lang="fr">
  <title>Profils de Build</title>

  <section id="profiles-sect-what">
    <title>À quoi servent-ils ?</title>

    <para>Les profils permettent d'adapter un build à l'environnement, ils assurent la portabilité entre différents
    environnements de build.</para>

    <para>Qu'entendons-nous par différents environnements de build ? La production et le développement sont deux
    environnements typiques. Quand vous travaillez dans l'environnement de développement, votre système est certainement
    configuré pour travailler sur une base de donnée de développement installée sur le poste local tandis qu'en
    production, votre système est configuré pour accèder à la base de donnée de production. Maven permet de définir
    différents environnements de build (profils de build) qui peuvent remplacer n'importe quel paramètre du fichier
    <filename>pom.xml</filename>. Vous pourriez configurer votre application pour lire dans votre base de donnée de
    développement locale dans un profil "development", et la configurer dans le profil "production" pour lire dans
    la base de donnée de production. Les profils peuvent également être activés en fonction de l'environnement et de la
    plateforme, vous pouvez personnaliser un build pour qu'il s'exécute différemment selon le système d'exploitation ou
    la version du <acronym>JDK</acronym> installé. Avant que nous parlions de l'utilisation et la configuration des
    profils Maven, nous devons définir le concept de Portabilité du Build.</para>

    <section id="profiles-sect-portability">
      <title>Qu'est ce que la Portabilité du Build ?</title>

      <para>La "portabilité" du build est la mesure de la facilité avec laquelle on peut prendre un projet particulier
      et le construire sur différents environnements. Un build qui fonctionne sans aucune configuration particulière ni
      ni personnalisation des fichiers properties est plus portable qu'un build qui nécessite une un certain travail pour
      construire le projet à partir de rien. Les projets les plus portables sont bien souvent des projets opensource très
      utilisés comme Apache Commons ou Apache Velocity qui fonctionnent avec Maven sans personnalisation ou presque.
      Pour faire simple, les builds les plus portables fonctionnent immédiatement et les moins portables vous demandent
      de réaliser des acrobaties dans les fichiers de configuration pour modifier les chemins vers les outils de build
      en fonction des plateformes. Avant que nousvous dévoilions comment obtenir un build portable, étudions les
      différents types de portabilité dont nous allons parler.</para>

      <section id="profiles-sect-non-portable">
        <title>Builds non portables</title>

        <para>L'absence de portabilité est exactement ce que les outils de build essayent d'éviter - cependant, 
        n'importe quel outil peut être configuré pour être non-portable (même Maven). Un projet n'est pas portable
        lorsqu'il ne peut être construit que dans certaines circonstances spécifiques (ex : votre machine locale). A
        moins que vous travailliez seul et que vous n'envisagiez pas de déployer votre application sur une autre
        machine, il vaut mieux éviter complètement la non-portabilité. Un build non-portable fonctionne seulement sur
        une machine, c'est un build "à usage unique". Maven est conçu pour décourager les buids non-portables en offrant
        la possibilité de personnaliser les builds grâce aux profils.</para>

        <para>Quand un développeur récupère le code source d'un projet non-portable, il n'est pas en mesure de
        construire le projet sans remanier une grosse partie du script de build.</para>
      </section>

      <section id="profiles-sect-environment-portability">
        <title>Portabilité sur l'environnement</title>

        <para>Un build est qualifié de portable d'un environnement à l'autre s'il possède un mécanisme pour
        personnaliser le comportement et la configuration en fonction de l'environnement. Par exemple, un projet qui
        contient une référence à une base de donnée de test dans un environnement de test et à une base de donnée de
        production dans un environnement de production, est portable sur ces deux environnements. Il est probable que ce
        build ait différentes propriétés pour chaque environnement. Quand vous changez pour un environnement pour qui
        n'est pas défini et qui ne possède pas de profile associé, le projet ne fonctionnera pas. Donc un projet n'est
        portable que sur des environnements bien définis.</para>

        <para>Quand un nouveau développeur récupère le code source d'un projet dépendant de l'environnement, il devra
        exécuter le build dans cet environnement ou créer l'environnement adéquat pour réussir à construire le
        projet.</para>
      </section>

      <section id="profiles-sect-org-portability">
        <title>Portabilité interne à une organisation</title>

        <para>Le point clef de cet environnement est que seuls quelques uns ont accès à des ressources internes à
        l'organisation comme le gestionnaire de configuration ou le dépôt interne Maven. Un projet dans une grande
        entreprise peut dépendre de la présence d'une base de donnée accessible uniqument pour les développeurs 
        internes. Un projet opensource peut exiger un certain niveau de droits pour pouvoir publier le site web et les
        artefacts produits sur un dépôt publique.</para>

        <para>Si vous essayez de construire un projet interne hors du réseau interne de l'entreprise (par exemple de
        l'autre coté du firewall), le build va échouer. Il se peut que celà vienne de plugins propres à l'entreprise qui
        ne sont pas disponibles ou de dépendances du projet inaccessibles car vous n'avez pas les droits nécessaires
        pour accéder au dépôt distant d'entreprise. Un tel projet n'est portable que sur les environnements au sein
        d'une organisation.</para>
      </section>

      <section id="profiles-sect-wide-portability">
        <title>Véritable Portabilité (Universelle)</title>

        <para>Tout le monde peut télécharger le code source d'un projet véritablement portable, le compiler et
        l'installer sans avoir à configurer le build pour son environnement spécifique. C'est le plus haut niveau de
        portabilité ; aucun travail supplémentaire n'est nécessaire pour construire ce projet. Ce niveau de portabilité
        est important surtout pour les projets libres qui dépendent de la facilité avec laquelle les contributeurs
        potentiels vont pouvoir construire le projet à partir du code source téléchargé.</para>

        <para>N'importe quel développeur peut télécharger le code source d'un projet véritablement portable.</para>
      </section>
    </section>

    <section id="profiles-sect-select-level">
      <title>Choisir le bon niveau de portabilité</title>

      <para>Evidemment, vous voulez éviter le pire cas : le build non-portable. Vous avez peut-être connu le malheur de
      travailler ou d'étudier pour une organisation dont les applications critiques ont des builds non-portables. Dans
      une organisation comme celle-là, impossible de déployer une application sans une personne bien spécifique sur une
      machine bien spécifique aussi. Avec une telle organisation, il est très difficile d'introduire de nouvelles
      dépendances ou des changements sans se coordonner avec la personne qui gère ce build non-portable. Ces builds
      non-portables ont tendances à se développer dans des environnements très politiques où une personne ou un groupe
      veut contrôler quand et comment un projet est construit et déployé. "Comment construit-on le système ? Oh, nous
      devons appeler Jack et lui demander de nous le construire, personne d'autre ne peut déployer en production". C'est
      une situation périlleuse qui est beaucoup plus fréquente qu'on ne le pense. Si vous travaillez dans cette
      organisation, Maven et les profils Maven sont votre porte de sortie.</para>

      <para>A l'autre bout du spectre de la portabilité se trouvent les builds très portables. Ces builds sont des
      builds très difficiles à atteindre. Ils restreignent vos dépendances aux projets et aux outils qui sont librement
      distribuables et facilement accessibles. De nombreux packages commerciaux doivent être exclus des builds les plus
      portables car ils ne peuvent être téléchargés sans que vous n'ayez à accepter une license spécifique. Cette large
      portabilité va aussi restreindre les dépendances aux logiciels qui sont distribués sous la forme d'artefacts
      Maven. Par exemple, si vous dépendez des pilotes JDBC d'Oracle, vos utilisateurs devront les télécharger et les
      installer manuellement ; ce n'est pas très portable car vous devrez fournir les intructions nécessaires pour
      configurer l'environnement afin que les personnes itéressées puissent construire votre application. D'un autre
      côté, vous pourriez utiliser un pilote JDBC disponible sur le dépôt publique de Maven comme MySQL ou
      HSQLDB.</para>

      <para>Comme nous l'avons vu précédemment, les projets libres bénéficient d'avoir des builds le plus portable
      possible. Les builds très portables réduisent le coût de contribution à un projet. Dans un projet libre (comme
      Maven) on trouve deux groupes très distincts : les développeurs et les utilisateurs finaux. Quand un utilisateur
      final utilise Maven et qu'il décide de contribuer en proposant un patch de Maven, il doit passer de l'utilisation
      de l'artefact résultat d'un build à produire cet artefact. Il doit donc tout d'abord se transformer en
      développeur, et si apprendre à construire ce projet est trop compliqué, alors cet utilisateur perdra de sa
      motivation à contribuer au projet. Avec un projet très portable, un utilisateur n'a pas à connaitre les arcanes du
      projet pour se tranformer en développeur, il peut télécharger le code source, le modifier, construire son artefact
      et proposer sa contribution sans avoir à demander de l'aide pour configurer son environnement. Plus le coût
      d'entrée pour contribuer à un projet libre est bas et plus le nombre de contributions augmente, surtout dans ces
      petites contributions qui font la différence pour la réussite d'un projet. Une des conséquences de l'adoption de
      Maven par un grand nombre de projets libres est que contribuer à ces projets est devenu beaucoup plus
      facile.</para>
    </section>
  </section>

  <section id="profiles-sect-maven-profiles">
    <title>Portabilité grâce aux profiles Maven</title>

    <para>Un profil dans Maven est un ensemble alternatif de valeurs qui définissent ou écrasent les valeurs par défaut.
    En utilisant un profil, vous pouvez personnaliser un build pour différents environnements. Les profils sont
    configurés dans le <filename>pom.xml</filename> et possèdent un identifiant. Vous pouez ensuite exécuter Maven en
    précisant dans la ligne de commande le profil à utiliser. Le <filename>pom.xml</filename> suivant utilise un profil
    <literal>production</literal> pour écraser les paramètres par défaut du plugin Compiler.</para>

    <example>
      <title>Utilisation d'un profil Maven pour écraser les paramètres du compilateur pour la production</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;simple&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;name&gt;simple&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;profiles&gt; <co id="coDef-profiles-compile-1" linkends="coRef-profiles-compile-1" />&lt;profile&gt; &lt;id&gt;production&lt;/id&gt; <co
          id="coDef-profiles-compile-2" linkends="coRef-profiles-compile-2" />&lt;build&gt; <co
          id="coDef-profiles-compile-3" linkends="coDef-profiles-compile-3" />&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;debug&gt;false&lt;/debug&gt; <co
          id="coDef-profiles-compile-4" linkends="coDef-profiles-compile-4" />&lt;optimize&gt;true&lt;/optimize&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/profile&gt; &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>Dans cet exemple, nous avons ajouté un profil nommé <literal>production</literal> pour écraser la
    configuration par défaut du plugin Maven. Examinons la syntaxe de ce profil en détail.</para>

    <calloutlist>
      <callout arearefs="coDef-profiles-compile-1" id="coRef-profiles-compile-1">
        <para>L'élément <sgmltag>profiles</sgmltag> est dans le <filename>pom.xml</filename>, il contient un ou
        plusieurs éléments <sgmltag>profile</sgmltag>. Puisque les profils écrasent les paramètres par défaut dans le
        <filename>pom.xml</filename>, l'élément <sgmltag>profiles</sgmltag> est habituellement positionné en fin de
        <filename>pom.xml</filename>.</para>
      </callout>

      <callout arearefs="coDef-profiles-compile-2" id="coRef-profiles-compile-2">
        <para>Chaque profil doit avoir un élément <sgmltag>id</sgmltag>. Cet element <sgmltag>id</sgmltag> contient le
        nom qui est utilisé pour invoquer ce profil sur la ligne de commande. Un profil est invoqué en passant
        l'argument <command>-P&lt;profile_id&gt;</command> à la ligne de commande Maven.</para>
      </callout>

      <callout arearefs="coDef-profiles-compile-3" id="coRef-profiles-compile-3">
        <para>Un élément <sgmltag>profile</sgmltag> peut contenir de nombreux éléments contenus dans l'élément
        <sgmltag>project</sgmltag> d'un POM. Dans cet exemple, nous écrasons le comportement du plugin Compiler et nous
        devons écraser la configuration du plugin qui se trouve normalement dans l'élément
        <sgmltag>build</sgmltag>/<sgmltag>plugins</sgmltag>.</para>
      </callout>

      <callout arearefs="coDef-profiles-compile-4" id="coRef-profiles-compile-4">
        <para>Nous surchargeons la configuration du plugin Maven Compiler. Nous nous assurons que le bytecode produit
        par le profil de production ne contient pas les informtions de deboggage et qu'il a été optimisé par le
        compilateur.</para>
      </callout>
    </calloutlist>

    <para>Pour exécuter la commande <command>mvn install</command> avec le profil de <literal>production</literal> vous
    devez passer l'argument <command>-Pproduction</command> sur la ligne de commande. Pour vérifier que le profil de
    <literal>production</literal> surcharge la configuation par défaut du plugin Compiler, exécutez Maven avec les
    options de debug (<command>-X</command>) activées ainsi :</para>

    <screen>~/examples/profile $ <command>mvn clean install -Pproduction -X</command>
... (omitting debugging output) ...
[DEBUG] Configuring mojo 'o.a.m.plugins:maven-compiler-plugin:2.0.2:testCompile'
[DEBUG]   (f) basedir = ~\examples\profile
[DEBUG]   (f) buildDirectory = ~\examples\profile\target
...
[DEBUG]   (f) compilerId = javac
[DEBUG]   (f) <emphasis>debug = false</emphasis>
[DEBUG]   (f) failOnError = true
[DEBUG]   (f) fork = false
[DEBUG]   (f) <emphasis>optimize = true</emphasis>
[DEBUG]   (f) outputDirectory = \
          ~\svnw\sonatype\examples\profile\target\test-classes
[DEBUG]   (f) outputFileName = simple-1.0-SNAPSHOT
[DEBUG]   (f) showDeprecation = false
[DEBUG]   (f) showWarnings = false
[DEBUG]   (f) staleMillis = 0
[DEBUG]   (f) verbose = false
[DEBUG] -- end configuration --
... (omitting debugging output) ...
</screen>

    <para>Cet extrait de la sortie en mode debug de Maven nous montre la configuration du plugin Compiler avec le profil
    de production. Comme nous pouvons le voir, la variable <varname>debug</varname> est à faux et la variable
    <varname>optimize</varname> est à vrai.</para>

    <section id="profiles-sect-overriding-pom">
      <title>Surcharger un POM</title>

      <para>L'exemple précédent vous a montré comment surcharger la configuration par défaut d'un unique plugin Maven,
      mais vous ne savez toujours pas ce qu'il est possible de faire avec un profil Maven. Pour faire court, un profil
      Maven peut surcharger presque tout ce que vous pouvez trouver dans un fichier <filename>pom.xml</filename>. Le
      <acronym>POM</acronym> Maven possède une balise appelée <sgmltag>profiles</sgmltag> qui contient les différentes
      configurations d'un projet, et dans cette balise se trouve une balise profile qui définit chacun d'entre eux.
      Chaque profil doit avoir une balise <sgmltag>id</sgmltag>, et à part celà elle peut contenir presque toutes les
      balises que l'on peut trouver dans la balise <sgmltag>project</sgmltag>. Le document <acronym>XML</acronym> qui
      suit nous montre toutes les balsies qu'un profile peut surcharger.</para>

      <para><example>
          <title>Balises autorisées dans un profil</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;build&gt;
        &lt;defaultGoal&gt;...&lt;/defaultGoal&gt;
        &lt;finalName&gt;...&lt;/finalName&gt;
        &lt;resources&gt;...&lt;/resources&gt;
        &lt;testResources&gt;...&lt;/testResources&gt;
        &lt;plugins&gt;...&lt;/plugins&gt;
      &lt;/build&gt;
      &lt;reporting&gt;...&lt;/reporting&gt;
      &lt;modules&gt;...&lt;/modules&gt;
      &lt;dependencies&gt;...&lt;/dependencies&gt;
      &lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt;
      &lt;distributionManagement&gt;...&lt;/distributionManagement&gt;
      &lt;repositories&gt;...&lt;/repositories&gt;
      &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt;
      &lt;properties&gt;...&lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>Un profil peut donc redéfinir les éléments entourés par une ellipse. Un profil peut redéfinir le nom de
      l'artefact final, les dépendances et le build d'un projet via la en surchargeant la configuration de plugins. Un
      profil peut aussi redéfinir les paramètres de distribution ; par exemple, si pour une étape de validation vous
      devez publier vos artefacts sur un serveur de pré-production vous allez créer un profil de validation qui va
      surcharger la balise <sgmltag>distributionManagement</sgmltag>.</para>
    </section>
  </section>

  <section id="profiles-sect-activation">
    <title>Activation de profil</title>

    <para>Dans la section précédente nous vous avons présenté comment créer un profil qui redéfinit le comportement par
    défaut selon un environnement cible spécifique. Le build précédent était configuré par défaut pour le développement,
    et le profil <literal>production</literal> existe pour apporter les éléments de configuration propres à
    l'environnement de production. Que se passe t'il si vous devez adapter votre build selon le système d'exploitation
    ou la version du <acronym>JDK</acronym> ? Maven fournit un mécanisme pour "activer" un profil selon différents
    paramètres liés à l'environnement, c'est ce qe l'on appelle l'activation de profil.</para>

    <para>Prenons l'exemple suivant, supposons que nous avons une bibliothèque Java dont certaines fonctions ne sont
    disponibles que pour Java 6 : le moteur de scripts défini dans la <ulink
    url="http://jcp.org/en/jsr/detail?id=223">JSR-223</ulink>. Une fois que vous avez séparé le bloc de code qui utilise
    le moteur de scripts dans un projet Maven à part, vous voulez que les personnes qui utilisent Java 5 puissent
    construire votre projet sans essayer de construire l'extension spécifique Java 6. Vous pouvez faire celà au moyen
    d'un profil Maven qui ajoute le module de gestion des scripts uniquement lorsque le build se fait sur un
    <acronym>JDK</acronym> Java 6. Tout d'abord, jettons un oeil à la structure des répertoires de notre projet et
    comment nous souhaitons que les développeurs construisent notre système.</para>

    <para>Lorsque l'on exécute la commande <command>mvn install</command> avec un <acronym>JDK</acronym> Java 6, nous
    voulons que le build construise le projet <literal>simple-script</literal>, par contre si cette commande est
    exécutée sur Java 5 il faut exclure le projet <literal>simple-script</literal> du build. Si vous n'excluez pas le
    projet <literal>simple-script</literal> de votre build en Java 5, celui-ci va échouer car Java 5 ne fournit pas la
    classe <classname>ScriptEngine</classname>. Etudions plus en détail le fichier <filename>pom.xml</filename> du
    projet de bibliothèque :</para>

    <example>
      <title>Inclusion dynamique de sous-modules par activation de profil</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                             http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;simple&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;name&gt;simple&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;jdk16&lt;/id&gt;
      &lt;activation&gt; <co id="coDef-profiles-active-1" linkends="coRef-profiles-active-1" />&lt;jdk&gt;1.6&lt;/jdk&gt; &lt;/activation&gt; &lt;modules&gt; <co
          id="coDef-profiles-active-2" lang="" linkends="coRef-profiles-active-2" />&lt;module&gt;simple-script&lt;/module&gt; &lt;/modules&gt; &lt;/profile&gt; &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
    </example>

    <para>Si vous exécutez la commande <command>mvn install</command> en Java 1.6, vous vous apercevrez que Maven
    descent dans le sous-répertoire <filename>simple-script</filename> pour y construire le projet
    <literal>simple-script</literal>. Si vous exécutez la même commande <command>mvn install</command> en Java 1.5, le
    build n'essayera pas de construire le sous-module <literal>simple-script</literal>. Analysons cette configuration
    d'activation en détails :</para>

    <calloutlist>
      <callout arearefs="coDef-profiles-active-1" id="coRef-profiles-active-1">
        <para>La balise <sgmltag>activation</sgmltag> indique les conditions d'activation du profil. Dans cet exemple,
        nous avons indiqué que ce profil sera activé pour les versions de Java à partir de Java "1.6". Ce qui inclut
        donc "1.6.0_03", "1.6.0_02" ou tout autre version commençant par "1.6". Les conditions d'activation ne sont pas
        limitées à la version de Java, pour une liste complète des paramètres d'activation rendez-vous à la <xref
        linkend="profiles-sect-activation-config" xrefstyle="select:title" />.</para>
      </callout>

      <callout arch="" arearefs="coDef-profiles-active-2" id="coRef-profiles-active-2">
        <para>Dans ce profil nous ajoutons le module <literal>simple-script</literal>. A cause de l'ajout de ce module,
        Maven va aller regarder dans le sous-répertoire <filename>simple-script/</filename> à la recherche d'u fichier
        <filename>pom.xml</filename>.</para>
      </callout>
    </calloutlist>

    <section id="profiles-sect-activation-config">
      <title>Configuration de l'activation</title>

      <para>L'activation contient une ou plusieurs conditions sur les versions du JDK, les systèmes d'exploitation ou
      des propriétés. Un profil est activé lorsque toutes les conditions d'activation sont satisfaites. Par exemple, un
      profil peut indiquer comme conditions d'être sur un système d'exploitation Windows avec un JDK version 1.4. Ce
      profil ne sera donc activé que si le build est exécuté sur une machine Windows avec Java 1.4. Si le profil est
      actif, alors tous ses éléments surchargent les éléments correspondants du projet comme si ce profil était inclus
      via l'argument <command>-P</command> en ligne de commande. L'exemple uivant présente un profil qui n'est activé
      que par une combinaison très spécifique de propriétés, de version du JDK et de système d'exploitation.</para>

      <para><example>
          <title>Paramètres d'activation du profil : version du JDK Version, système d'exploitation et
          propriétés</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;dev&lt;/id&gt;
      &lt;activation&gt;
        &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; <co id="coDef-profiles-active2-1"
              linkends="coRef-profiles-active2-1" />&lt;jdk&gt;1.5&lt;/jdk&gt; <co id="coDef-profiles-active2-2"
              linkends="coRef-profiles-active2-2" />&lt;os&gt; &lt;name&gt;Windows XP&lt;/name&gt; <co
              id="coDef-profiles-active2-3" linkends="coRef-profiles-active2-3" />&lt;family&gt;Windows&lt;/family&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;property&gt; &lt;name&gt;mavenVersion&lt;/name&gt; <co
              id="coDef-profiles-active2-4" linkends="coRef-profiles-active2-4" />&lt;value&gt;2.0.5&lt;/value&gt; &lt;/property&gt; &lt;file&gt; &lt;exists&gt;file2.properties&lt;/exists&gt; <co
              id="coDef-profiles-active2-5" linkends="coRef-profiles-active2-5" />&lt;missing&gt;file1.properties&lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; ... &lt;/profile&gt; &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>L'exemple précédent définit un ensemble très précis de paramètres d'activation. Regardons chacun d'entre eux
      plus en détail :</para>

      <calloutlist>
        <callout arearefs="coDef-profiles-active2-1" id="coRef-profiles-active2-1">
          <para>La balise <sgmltag>activeByDefault</sgmltag> controle si ce profil est actif par défaut.</para>
        </callout>

        <callout arearefs="coDef-profiles-active2-2" id="coRef-profiles-active2-2">
          <para>Ce profil n'est actif que pour les versions du JDK commençant par "1.5". Ce qui inclut "1.5.0_01" et
          "1.5.1".</para>
        </callout>

        <callout arearefs="coDef-profiles-active2-3" id="coRef-profiles-active2-3">
          <para>Ce profil cible ussi une version très spécifique de Windows XP, version 5.1.2600 sur une plateforme
          32-bit. Si votre projet utilise le plugin natif pour compiler du code en C, vous risquez de vous retrouver à
          écrire plusieurs projets selon les plateformes.</para>
        </callout>

        <callout arearefs="coDef-profiles-active2-4" id="coRef-profiles-active2-4">
          <para>La balise <sgmltag>property</sgmltag> indique à Maven qu'il doit activer ce profil si la propriété
          <varname>mavenVersion</varname> a pour valeur <literal>2.0.5</literal>. La propriété
          <varname>mavenVersion</varname> est une propriété implicite qui est disponible pour tous les builds
          Maven.</para>
        </callout>

        <callout arearefs="coDef-profiles-active2-5" id="coRef-profiles-active2-5">
          <para>La balise <sgmltag>file</sgmltag> nous permet d'activer un profil sur la présence (ou l'absence) de
          fichiers. Le profil <literal>dev</literal> sera activé si un fichier <filename>file2.properties</filename>
          existe à la racine du projet. Le profil <literal>dev</literal> ne sera activé que s'il n'existe pas de fichier
          <filename>file1.properties</filename> à la racine du projet.</para>
        </callout>
      </calloutlist>
    </section>

    <section id="profiles-sect-activation-by-absence">
      <title>Activation par l'absence d'une propriété</title>

      <para>Vous pouvez activer un profil sur la valeur d'une propriété telle que
      <varname>environment.</varname><varname>type</varname>. Vous pouvez donc activer un profil
      <literal>development</literal> si la variable <varname>environment.</varname><varname>type</varname> a pour valeur
      <literal>dev</literal> et un profil <literal>production</literal> si cette variable vaut maintenant
      <literal>prod</literal>. Il est aussi possible d'activer un profil en cas d'absence d'une propriété. La
      configuration suivante active un profil si la propriété <varname>environment.</varname><varname>type</varname>
      n'est pas présente durant l'exécution de Maven.</para>

      <para><example>
          <title>Activation de profiles en cas d'absence d'une propriété</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;development&lt;/id&gt;
      &lt;activation&gt;
        &lt;property&gt;
          &lt;name&gt;!environment.type&lt;/name&gt;
        &lt;/property&gt;
      &lt;/activation&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>Attention au point d'exclamation qui préfixe le nom de la propriété. Le point d'exclamation est souvent
      appelé le caractère "bang" cet signifie "non". Ce profil est activé quand aucune propriété
      <varname>\${environment.</varname><varname>type}</varname> est définie.</para>
    </section>
  </section>

  <section id="profiles-sect-listing-active-profiles">
    <title>Lister les profiles actifs</title>

    <para>Les profiles Maven peuvent être définis soit dans le fichier <filename>pom.xml</filename>, dans un fichier
    <filename>profiles.xml</filename>, dans le fichier <filename>~/.m2/settings.xml</filename> ou dans le fichier
    <filename>\${M2_HOME}/conf/settings.xml</filename>. Avec ces quatre possibilités, il est difficile de savoir quels
    sont les profiles disponibles pour un projet sans avoir à parcourir les quatre fichiers en question. Pour faciliter
    la gestion des profiles, connaitre ceux qui sont disponibles et où ils sont définis, il existe le goal du plugin
    Maven Help <literal>active-profiles</literal> qui liste l'ensemble des profiles actifs et où ils sont définis. Voici
    les instructions pour exécuter le goal <literal>active-profiles</literal> :</para>

    <screen>$ <command>mvn help:active-profiles</command>
Active Profiles for Project 'My Project':

The following profiles are active:

 - my-settings-profile (source: settings.xml)
 - my-external-profile (source: profiles.xml)
 - my-internal-profile (source: pom.xml)</screen>
  </section>

  <section id="profiles-sect-tips-tricks">
    <title>Trucs et Astuces</title>

    <para>Les profils encouragent la portabilité du build. Si vous avez besoin de configurer avec délicatesse votre
    build pour qu'il puisse s'exécuter sur différentes plateformes ou pour construire différents artefacts selon la
    plateforme cible, alors les profils peuvent améliorer la portabilité de votre build. Les profils définis dans les
    fichiers <filename>settings.xml</filename> diminuent la portabilité d'un build puisque les développeurs doivent
    échanger cette information supplémentaire. Les sections qui vont suivre présentent des guides et des suggestions
    pour l'utilisation de profils Maven dans votre projet.</para>

    <section id="profiles-sect-common-envs">
      <title>Common Environments</title>

      <para>Une des principales motivations pour l'utilisation de profils Maven est de fournir la configuration
      spécifique à un environnement. Dans un environnement de développement, vous voudrez produire du bytecode avec les
      informations nécessaires pour le déboggage et vous voudrez configurer votre système pour qu'il utilise une base de
      données de dévelopement. Dans un environnement de prodution, vous souhaiterez produire un JAR signé et configurer
      votre système pour qu'il utilise la base de données de production. Dans ce chapitre, nous avons défini un certain
      nombre d'environnements avec des identifiants comme <literal>dev</literal> et <literal>prod</literal>. On peut
      faire plus simple en définissant des profils qui seront activés par des propriétés de l'environnement et en
      utilisant ces propriétés pour tous vos projets. Par exemple, si chaque projet a un profil
      <literal>development</literal> activé par une propriété appelée
      <varname>environment.</varname><varname>type</varname> ayant pour valeur <literal>dev</literal>, et si ces mêmes
      projets avaient un profil <literal>production</literal> activé par la présence d'une propriété
      <varname>environment.</varname><varname>type</varname> ayant pour valeur <literal>prod</literal>, vous pourriez
      alors créer un profil dans votre fichier <filename>settings.xml</filename> qui définirait une propriété
      <varname>environment.</varname><varname>type</varname> avec pour valeur <literal>dev</literal> sur votre machine
      de développement. Ainsi, chaque projet définit un profil <literal>dev</literal> activé par la même variable
      d'environnement. Voyons comment appliquer tout celà, le fichier <filename>settings.xml</filename> suivant définit
      un profil dans <filename>~/.m2/settings.xml</filename> qui spécifie la valeur <literal>dev</literal> pour la
      propriété <varname>environment.</varname><varname>type</varname>.</para>

      <para><example>
          <title>Le fichier ~/.m2/settings.xml définit un profil par défaut qui sépcifie la propriété
          environment.type</title>

          <programlisting language="xml">&lt;settings&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;activation&gt;
        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;environment.type&gt;dev&lt;/environment.type&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/settings&gt;
</programlisting>
        </example></para>

      <para>Ce implique que lorsque vous exécutez Maven sur votre poste ce profil sera activé et la propriété
      <varname>environment.</varname><varname>type</varname> aura pour valeur <literal>dev</literal>. Vous pouvez
      utiliser cette propriété pour activer les profils définis dans le fichier <filename>pom.xml</filename> d'un projet
      comme nous allons le voir. Regardons donc, comment le fichier <filename>pom.xml</filename> définirait un profil
      qui serait activé par le fait que la propriété <varname>environment.</varname><varname>type</varname> a la valeur
      <literal>dev</literal>.</para>

      <para><example id="ex-profile-envtype-pom">
          <title>Profil d'un projet activé parle fait que environment.type vaut 'dev'</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;development&lt;/id&gt;
      &lt;activation&gt;
        &lt;property&gt;
          &lt;name&gt;environment.type&lt;/name&gt;
          &lt;value&gt;dev&lt;/value&gt;
        &lt;/property&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;database.driverClassName&gt;com.mysql.jdbc.Driver&lt;/database.driverClassName&gt;
        &lt;database.url&gt;
          jdbc:mysql://localhost:3306/app_dev
        &lt;/database.url&gt;
        &lt;database.user&gt;development_user&lt;/database.user&gt;
        &lt;database.password&gt;development_password&lt;/database.password&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
    &lt;profile&gt;
      &lt;id&gt;production&lt;/id&gt;
      &lt;activation&gt;
        &lt;property&gt;
          &lt;name&gt;environment.type&lt;/name&gt;
          &lt;value&gt;prod&lt;/value&gt;
        &lt;/property&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;database.driverClassName&gt;com.mysql.jdbc.Driver&lt;/database.driverClassName&gt;
        &lt;database.url&gt;jdbc:mysql://master01:3306,slave01:3306/app_prod&lt;/database.url&gt;
        &lt;database.user&gt;prod_user&lt;/database.user&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>Ce projet définit de nouvelles propriétés comme <varname>database.</varname><varname>url</varname> et
      <varname>database.user</varname> qui pourraient être utilisées pour configurer un plugin Maven ailleurs dans le
      fichier <filename>pom.xml</filename>. Il existe de nombreux plugins qui peuvent manipuler une base de données,
      exécuter du SQL, ou comme le plugin Maven Hibernate3 peuvent générer un ensemble d'objets annotés utilisés par les
      frameworks de persitance. Certains de ces plugins peuvent être configurés dans un fichier
      <filename>pom.xml</filename> grâce à ces propriétés. Ces propriétés peuvent aussi être utilisées pour filtrer des
      ressources. Dans cet exemple, comme nous avons définit un profil dans le fichier
      <filename>~/.m2/settings.xml</filename> qui spécifie la valeur <literal>dev</literal> pour
      <varname>environment.</varname><varname>type</varname>, le profil de développement sera toujours actif à chaque
      exécution de Maven sur cette machine. Par contre, si nous voulions modifier ce comportement par défaut, nous
      pourrions indiquer la vleur de cette propriété en ligne de commande. Si nous avons besoin d'activer le profil de
      production, nous pourrions exécuter Maven avec la commande :</para>

      <screen>~/examples/profiles $ <command>mvn install -Denvironment.type=prod</command></screen>

      <para>Spécifier une propriété en ligne de commande surchagera la valeur par défaut définie dans le fichier
      <filename>~/.m2/settings.xml</filename>. Nous aurions pu aussi défiir un profil avec une <sgmltag>id</sgmltag>
      "dev" et l'invoquer directemet avec l'argument <command>-P</command> en ligne de commande, mais l'utilisation de
      cette propriété <varname>environment.</varname><varname>type</varname> nous permet d'écrire de nouveaux fichiers
      <filename>pom.xml</filename> en respectant ce standard. Tous vos projets pourraient possèder un profil qui serait
      activé par la même propriété <varname>environment.</varname><varname>type</varname>définie dans les fichiers
      <filename>~/.m2/settings.xml</filename> de chaque développeur. Ainsi, les développeurs peuvent partager une
      configuration commune pour le développement sans avoir à la définir dans des fichiers
      <filename>settings.xml</filename> non-portables.</para>
    </section>

    <section id="profiles-sect-protecting-secrets">
      <title>Protèger les mots de passe</title>

      <para>Cette bonne pratique est la conséquence de la section précédente. Dans <xref
      linkend="ex-profile-envtype-pom" xrefstyle="select:title" />, le profil de production ne contient pas la propriété
      <varname>database.password</varname>. J'ai fait celà délibéremment pour illustrer le fait de stocker les mots de
      passe dans votre fichier <filename>settings.xml</filename>. Si vous développez une application dans une grande
      orgaisation qui accorde de l'importance à la sécurité, il est probable que la majorité des développeurs ne
      connaissent pas le mot de passe de production de la base de données. Dans une organisation qui trace des
      frontières entre équipe de développement et équipe de production celà sera la norme. Les développeurs ont accès
      aux environnements de développement et de pré-production,mais ils pourraient ne pas avoir (ou ne pas vouloir)
      accès à la base de données de production. Il y a un certain nombres de raisons pour lesquelles celà aurait un
      sens, particulièrement si une organisation gère des données sensibles financières, médicales ou autres. Dans ce
      scénario, l'environnement de production ne pourrait être utilisé que par le responsable technique ou par un
      memebre de l'équipe de production. Quand ils exécutent le build avec la valeur <literal>prod</literal> pour la
      propriété <varname>environment.</varname><varname>type</varname>, ils ont devoir définir cette variable dans leur
      fichier <filename>settings.xml</filename> comme suit :</para>

      <example>
        <title>Enregistrement de mots de passe dans un profil du fichier settings.xml propre à l'utilisateur</title>

        <programlisting language="xml">&lt;settings&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
      &lt;properties&gt;
        &lt;environment.type&gt;prod&lt;/environment.type&gt;
        &lt;database.password&gt;m1ss10nimp0ss1bl3&lt;/database.password&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/settings&gt;
</programlisting>
      </example>

      <para>Cet utilisateur a définit un profil par défaut qui donne à
      <varname>environment.</varname><varname>type</varname> la valeur <literal>prod</literal> et qui spécifie le mot de
      passe de production. Quand le build du projet est exécuté, le profil de production est activé par la propriété
      <varname>environment.</varname><varname>type</varname> et la propriété <varname>database.password</varname> est
      remplie. Ainsi, vous pouvez mettre toute la configuration spécifique à la production dans le fichier
      <filename>pom.xml</filename> du projet et ne retirer que l'unique mot de passe nécessaire pour accèder à la base
      de données de production.</para>

      <note>
        <para>Ces données secrètes sont en général contraires à la portabilité, mais ce que nous venons de faire a du
        sens. Vous ne voudriez pas partager vos secrets avec n'importe qui.</para>
      </note>
    </section>

    <section id="profiles-sect-platform-classifier">
      <title>Classifiers selon la plateforme</title>

      <para>Supposons que vous avez une bibliothèque ou un projet qui produit des artefacts spécifiques selon la
      plateforme. Même si Java est indépendant de la plateforme, parfois vous pourriez avoir besoin d'écrire du code qui
      invoque du code natif, spécifique à une plateforme. Un autre cas possible est que vous avez écrit du code C qui
      est compilé par le plugin Maven Native et que vous voulez produire un artefact qualifié selon la plateforme sur
      laquelle il a été construit. Vous pouvez définir un classifier avec le plugin Maven Assemblyou le plugin Maven
      Jar. Le fichier <filename>pom.xml</filename> suivant produit un artefact qualifié grâce à des profils activés
      selon le système d'exploitation. Pour plus d'informations sur le plugin Maven Assembly vous pouvez consulter le
      <xref linkend="assemblies" />.</para>

      <para><example>
          <title>Qualification d'artéfacts avec des profils activés selon la plateforme</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;windows&lt;/id&gt;
      &lt;activation&gt;
        &lt;os&gt;
          &lt;family&gt;windows&lt;/family&gt;
        &lt;/os&gt;
      &lt;/activation&gt;
      &lt;build&gt;
        &lt;plugins&gt;
          &lt;plugin
            &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
              &lt;classifier&gt;win&lt;/classifier&gt;
            &lt;/configuration&gt;
          &lt;/plugin&gt;
        &lt;/plugins&gt;
      &lt;/build&gt;
    &lt;/profile&gt;
    &lt;profile&gt;
      &lt;id&gt;linux&lt;/id&gt;
      &lt;activation&gt;
        &lt;os&gt;
          &lt;family&gt;unix&lt;/family&gt;
        &lt;/os&gt;
      &lt;/activation&gt;
      &lt;build&gt;
        &lt;plugins&gt;
          &lt;plugin&gt;
            &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
              &lt;classifier&gt;linux&lt;/classifier&gt;
            &lt;/configuration&gt;
          &lt;/plugin&gt;
        &lt;/plugins&gt;
      &lt;/build&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>Si le système d'exploitation fait partie de la famille Windows, ce fichier <filename>pom.xml</filename>
      qualifie l'artefact Jar avec "-win". Si le système d'exploitation est un membre de la famille Unix, l'artefact est
      qualifié avec "-linux". Ce fichier <filename>pom.xml</filename> ajoute avec succèsles qualifieurs aux artefacts,
      mais il est plus verbeux que nécessaire en recopiant la configuration du plugin Maven Jar dans les deux profils.
      Cet exemple pourrrait être ainsi réecrit en utilisant la substitution de variables pour rduire la redondance
      :</para>

      <para><example>
          <title>Qualification des artefacts avec des profils activés selon la plateforme d'exécution et en utilisant la
          substitution de variables</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;classifier&gt;\${envClassifier}&lt;/classifier&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  ...
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;windows&lt;/id&gt;
      &lt;activation&gt;
        &lt;os&gt;
          &lt;family&gt;windows&lt;/family&gt;
        &lt;/os&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;envClassifier&gt;win&lt;/envClassifier&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
    &lt;profile&gt;
      &lt;id&gt;linux&lt;/id&gt;
      &lt;activation&gt;
        &lt;os&gt;
          &lt;family&gt;unix&lt;/family&gt;
        &lt;/os&gt;
      &lt;/activation&gt;
      &lt;properties&gt;
        &lt;envClassifier&gt;linux&lt;/envClassifier&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>Dans ce fichier <filename>pom.xml</filename> chaque profil n'a pas besoin d'inclure une balise
      <sgmltag>build</sgmltag> pour configurer le plugin Jar. Au lieu de celà, chaque profil est activé par la famille à
      laquelle appartient le système d'exploitation, et valorise la propriété <varname>envClassifier</varname> soit à
      <literal>win</literal> soit à <literal>linux</literal>. Cette propriété <varname>envClassifier</varname> est
      référencée dans la balise <sgmltag>build</sgmltag> du fichier <filename>pom.xml</filename> pour ajouter un
      classifieur à l'artefact JAR produit par le projet. Ainsi l'artefact JAR produit s'appellera
      <code>\${finalName}-\${envClassifier}.jar </code>et sera utilisé comme dépendance grâce à la syntaxe suivante
      :</para>

      <para><example>
          <title>Dépendance ves un artefact qualifié</title>

          <programlisting language="xml">&lt;dependency&gt;
      &lt;groupId&gt;com.mycompany&lt;/groupId&gt;
      &lt;artifactId&gt;my-project&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;classifier&gt;linux&lt;/classifier&gt;
    &lt;/dependency&gt;
</programlisting>
        </example></para>
    </section>
  </section>

  <section id="profiles-sect-summary">
    <title>En résumé</title>

    <para>Lorsqu'ils sont utilisés judicieusement, les profils facilitent grandement la configuration du build pour
    différentes plateformes. Si quelque part dans votre build vous avez besoin de définir un chemin spécifique à une
    plateforme pour un serveur d'application, vous pouvez mettre ces éléments de configuration dans un profil qui sera
    activé selon la nature de votre système d'exploitation. Si vous avez un projet qui doit produire différents
    artefacts pour différents environnements, vous pouvez personnaliser le comportement du build selon les différents
    environnements et plateformes par des profils spécifiques à ceux-ci. L'utilisation de profils permet de rendre les
    builds portables, il n'est plus nécessaire de réecrire votre logique de construction pour l'adapter à un nouvel
    environnement. Surchargez la configuration qui doit être modifiée et partagez celle qui peut l'être.</para>
  </section>
</chapter>
