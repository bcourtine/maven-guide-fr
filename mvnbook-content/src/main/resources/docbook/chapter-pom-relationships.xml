<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="pom-relationships" lang="fr">
  <title>Le Modèle Objet de Projet</title>

  <section id="pom-relationships-sect-intro">
    <title>Introduction</title>

    <para>Ce chapitre traite du concept au cœur de Maven — le Project Object Model (Modèle Objet de Projet)<indexterm class="startofrange"
        id="pom1">
        <primary>POM (Project Object Model)</primary>
      </indexterm>. C'est dans ce <acronym>POM</acronym> que sont déclarées l'identité et la structure d'un projet, que
      sont configurés les builds et où sont définies les relations entre projets. C'est l'existence d'un fichier <filename
    moreinfo="none">pom.xml</filename> qui définit un projet Maven.</para>
  </section>

  <section id="pom-relationships-sect-pom">
    <title>Le POM</title>

    <para>Les projets Maven, les dépendances, les builds, les artefacts : tous sont des objets qu'il va falloir
    modéliser et décrire. Ces objets sont décrits dans un fichier <acronym>XML</acronym> appelé Modèle Objet de Projet.
    Le <acronym>POM</acronym> indique à Maven quel type de projet il va devoir traiter et comment il va devoir
    s'adapter pour transformer les sources et produire le résultat attendu. Ainsi, comme le fichier 
    <filename moreinfo="none">web.xml</filename> décrit, configure et personnalise une application web Java, c'est
     la présence d'un fichier<indexterm>
        <primary>pom.xml file</primary>
      </indexterm><indexterm>
        <primary>pom.xml file</primary>
        <seealso>POM</seealso>
      </indexterm> <filename moreinfo="none">pom.xml</filename> qui définit un projet Maven. Il s'agit d'une déclaration
      décrivant un projet Maven; c'est le “plan” abstrait que Maven doit comprendre et suivre pour construire votre projet.</para>

    <para>Vous pouvez aussi voir dans ce fichier <filename moreinfo="none">pom.xml</filename> un équivalent à un fichier <filename
    moreinfo="none">Makefile</filename> ou à un fichier <filename moreinfo="none">build.xml</filename> pour Ant. Quand vous
    utilisez <acronym>GNU</acronym> <emphasis>make</emphasis> pour construire une application comme par exemple MySQL,
    vous aurez le plus souvent un fichier <filename moreinfo="none">Makefile</filename> contenant toutes les instructions
    explicites pour produire un binaire à partir des sources. Quand vous utilisez Apache Ant, vous avez très probablement 
    un fichier <filename moreinfo="none">build.xml</filename> qui contient les instructions explicites pour nettoyer,
    compiler, packager et déployer une application. <emphasis>make</emphasis>, Ant, et Maven ont en commun le fait qu'il
    leur faut un fichier avec un nom pré-déterminé, qu'il s'agisse de <filename
    moreinfo="none">Makefile</filename>, <filename moreinfo="none">build.xml</filename>, ou <filename
    moreinfo="none">pom.xml</filename>, mais c'est là que les similarités s'arrêtent. Si vous regardez un <filename
    moreinfo="none">pom.xml</filename> Maven, la plus grande partie du <acronym>POM</acronym> se compose de
    descriptions. Où se trouve le code source ? Où sont les ressources ? Quel est le packaging ? Si vous regardez un
    fichier <filename moreinfo="none">build.xml</filename> pour Ant, vous verrez quelque chose d'entièrement différent.
    Vous verrez des instructions explicites pour des tâches comme la compilation de classes Java. Le
    <acronym>POM</acronym> Maven est déclaratif, et même si vous pouvez y inclure des personnalisations
    procédurales via le plugin Maven Ant, en général vous n'aurez pas besoin de vous plonger dans les délicats
    détails procéduraux de la construction de votre projet.</para>

    <para>Le <acronym>POM</acronym> n'est pas spécifique à la construction de projets Java. Même si la plupart des
    exemples de ce livre sont des applications Java, il n'y a rien de spécifique à Java dans la définition d'un Modèle
    Objet de Projet Maven. Si effectivement les plugins par défaut de Maven permettent de construire des artefacts sous
    forme de <acronym>JAR</acronym> à partir d'un ensemble de sources, de tests et de ressources, rien ne vous empêche
    de définir un <acronym>POM</acronym> pour un projet qui contient des sources C# et produit un binaire Microsoft
    propriétaire avec des outils Microsoft. De même, rien ne vous empêche d'utiliser un <acronym>POM</acronym> pour un
    livre technique. En effet, le source de ce livre et ses exemples sont répartis dans un projet Maven multimodule qui
    utilise l'un des nombreux plugins Maven pour Docbook afin d'appliquer une feuille <acronym>XSL</acronym> Docbook
    standard à un ensemble de chapitres présents sous la forme de fichiers <acronym>XML</acronym>. Certains ont créé des
    plugins Maven pour transformer du code Adobe Flex en <acronym>SWC</acronym>s et <acronym>SWF</acronym>s ; 
    d'autres utilisent Maven pour construire des projets écrits en C.</para>

    <para>Nous avons donc établi que le <acronym>POM</acronym> décrit et déclare, et qu'il se différencie de Ant ou de
    Make en ne fournissant pas d'instructions explicites. Nous avons vu que les concepts du <acronym>POM</acronym>
    ne sont pas propres à Java. Regardons tout cela plus en détail au travers de la <xref linkend="fig-pom" /> pour une
    analyse du contenu d'un <acronym>POM</acronym>.</para>

    <para><figure id="fig-pom">
        <title>Le Modèle Objet de Projet</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/pom-relationships_pom-small.png" />
          </imageobject>

          <imageobject role="print">
            <imagedata align="center" fileref="figs/print/pom-relationships_pom-small.pdf" format="PDF" scalefit="0"
                       width="100%" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>Le <acronym>POM</acronym> se compose de quatre catégories de description et de configuration :</para>

    <variablelist>
      <varlistentry>
        <term>Informations générales sur le projet</term>

        <listitem>
          <para>Cette catégorie regroupe le nom l'<acronym>URL</acronym> et la licence du<indexterm>
              <primary>project information (in pom.xml)</primary>
            </indexterm><indexterm>
              <primary>licensing information (project information)</primary>
            </indexterm><indexterm>
              <primary>organizational information (project information)</primary>
            </indexterm><indexterm>
              <primary>developer information (project information)</primary>
            </indexterm><indexterm>
              <primary>pom.xml file</primary>

              <secondary>project information in</secondary>
            </indexterm> projet, l'organisation qui produit ce projet, et une liste de développeurs et de
            contributeurs.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Configuration du build</term>

        <listitem>
          <para>Dans cette section, nous configurons le build Maven<indexterm>
              <primary>build information (in pom.xml)</primary>
            </indexterm><indexterm>
              <primary>pom.xml file</primary>

              <secondary>build information in</secondary>
            </indexterm> en personnalisant le comportement par défaut. Nous pouvons changer l'endroit où se trouvent 
            les sources et les tests, ajouter de nouveaux plugins, lier des goals de plugins au cycle de vie et
            personnaliser les paramètres de génération du site web.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Environnement du build</term>

        <listitem>
          <para>L'environnement du build consiste en un ensemble de profils qui peuvent être<indexterm>
              <primary>build environment</primary>
            </indexterm><indexterm>
              <primary>pom.xml file</primary>

              <secondary>build environment</secondary>
            </indexterm> activés pour être utilisés dans différents environnements. Par exemple, au cours du
          développement vous pouvez vouloir déployer sur un serveur qui sera différent de celui sur lequel vous déploierez
          en production. L'environnement de build adapte la configuration du build
          pour un environnement spécifique et il s'accompagne souvent d'un fichier<indexterm>
              <primary>settings.xml file</primary>
            </indexterm> <filename moreinfo="none">settings.xml</filename> personnalisé dans le répertoire <filename
          moreinfo="none">~/.m2</filename>. Ce fichier <filename>settings.xml</filename> est détaillé dans le <xref linkend="profiles" /> et
          dans la <xref linkend="appendix-settings-sect-details" />.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Relations entre POM</term>

        <listitem>
          <para>Un projet est rarement isolé. Il dépend souvent d'autres projets, hérite d'une configuration de
          <acronym>POM</acronym> de projets parent, définit ses propres coordonnées, et peut comporter des
          sous-modules.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <section id="pom-relationships-sect-super-pom">
      <title>Le Super POM</title>

      <para>Avant de se plonger dans des exemples de <acronym>POM</acronym>s, jetons un rapide coup d'œil au Super
      <acronym>POM</acronym>. Tous les <acronym>POM</acronym>s de projet Maven étendent le Super <acronym>POM</acronym>
      qui définit un ensemble de valeurs par défaut partagé par tous les projets. Ce Super <acronym>POM</acronym> fait
      partie de l'installation de Maven, et se trouve dans le fichier
      <filename>maven-${maven.version}-uber.jar</filename> du répertoire <filename>\${M2_HOME}/lib</filename>. Si
      vous regardez ce fichier <acronym>JAR</acronym>, vous y trouverez un fichier <filename>pom-4.0.0.xml</filename>
      dans le package <package>org.apache.maven.project</package>. Le Super <acronym>POM</acronym> de Maven est
      présenté dans l'<xref linkend="ex-super-pom" />.</para>

      <example id="ex-super-pom">
        <title>Le Super POM</title>

        <programlisting>&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;name&gt;Maven Default Project&lt;/name&gt;

  &lt;repositories&gt;
    &lt;repository&gt;
      &lt;id&gt;central&lt;/id&gt;  <co id="coDef-super-1" linkends="coRef-super-1" />
      &lt;name&gt;Maven Repository Switchboard&lt;/name&gt;
      &lt;layout&gt;default&lt;/layout&gt;
      &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt;
      &lt;snapshots&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;/snapshots&gt;
    &lt;/repository&gt;
  &lt;/repositories&gt;

  &lt;pluginRepositories&gt;
    &lt;pluginRepository&gt;
      &lt;id&gt;central&lt;/id&gt;   <co id="coDef-super-2" linkends="coRef-super-2" />
      &lt;name&gt;Maven Plugin Repository&lt;/name&gt;
      &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt;
      &lt;layout&gt;default&lt;/layout&gt;
      &lt;snapshots&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;/snapshots&gt;
      &lt;releases&gt;
        &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;
      &lt;/releases&gt;
    &lt;/pluginRepository&gt;
  &lt;/pluginRepositories&gt;

  &lt;build&gt;  <co id="coDef-super-3" linkends="coRef-super-3" />
    &lt;directory&gt;target&lt;/directory&gt;
    &lt;outputDirectory&gt;target/classes&lt;/outputDirectory&gt;
    &lt;finalName&gt;\${pom.artifactId}-\${pom.version}&lt;/finalName&gt;
    &lt;testOutputDirectory&gt;target/test-classes&lt;/testOutputDirectory&gt;
    &lt;sourceDirectory&gt;src/main/java&lt;/sourceDirectory&gt;
    &lt;scriptSourceDirectory&gt;src/main/scripts&lt;/scriptSourceDirectory&gt;
    &lt;testSourceDirectory&gt;src/test/java&lt;/testSourceDirectory&gt;
    &lt;resources&gt;
      &lt;resource&gt;
        &lt;directory&gt;src/main/resources&lt;/directory&gt;
      &lt;/resource&gt;
    &lt;/resources&gt;
    &lt;testResources&gt;
      &lt;testResource&gt;
        &lt;directory&gt;src/test/resources&lt;/directory&gt;
      &lt;/testResource&gt;
    &lt;/testResources&gt;
  &lt;/build&gt; <co id="coDef-super-4" linkends="coRef-super-4" />
  &lt;pluginManagement&gt;
       &lt;plugins&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;
           &lt;version&gt;1.1&lt;/version&gt;
         &lt;/plugin&gt;       
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2-beta-1&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.3&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-ear-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.3.1&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-ejb-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.1&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.4&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-plugin-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.3&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-rar-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;                
           &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0-beta-7&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;                
           &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0-beta-6&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0.4&lt;/version&gt;
         &lt;/plugin&gt;         
         &lt;plugin&gt;
            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.4.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.1-alpha-1&lt;/version&gt;
         &lt;/plugin&gt;
       &lt;/plugins&gt;
     &lt;/pluginManagement&gt;
  
  &lt;reporting&gt;
    &lt;outputDirectory&gt;target/site&lt;/outputDirectory&gt;
  &lt;/reporting&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>Le Super <acronym>POM</acronym> définit des variables de configuration standards qui seront héritées par
      tous les projets. Les valeurs de ces variables sont définies dans les sections numérotées :</para>

      <calloutlist>
        <callout arearefs="coDef-super-1" id="coRef-super-1">
          <para>Le Super <acronym>POM</acronym> par défaut déclare un unique dépôt Maven distant ayant pour ID
          <literal>central</literal>. C'est ce dépôt central de Maven qui est configuré par défaut dans toutes les
          installations de Maven pour être interrogé. Cette configuration peut être surchargée par un fichier <filename
          moreinfo="none">settings.xml</filename> personnalisé. Attention, le Super <acronym>POM</acronym> par défaut a
          désactivé la récupération des artefacts snapshots depuis le dépôt central de Maven. Si vous avez besoin d'un
          dépôt snapshot, vous devrez configurer vos dépôts dans votre fichier <filename moreinfo="none">pom.xml</filename> ou
          votre fichier <filename moreinfo="none">settings.xml</filename>. Le fichier <filename>settings.xml</filename> et les
          profils sont traités dans le <xref linkend="profiles" /> ainsi que dans <xref
          linkend="appendix-settings-sect-details" />.</para>
        </callout>

        <callout arearefs="coDef-super-2" id="coRef-super-2">
          <para>Le dépôt central de Maven contient aussi des plugins Maven. Le dépôt de plugins est par défaut le dépôt
          central de Maven. La récupération des snapshots est désactivée par défaut et la règle de gestion des mises à
          jour indique "never", ce qui signifie que Maven ne met jamais automatiquement à jour un plugin si une nouvelle
          version est publiée.</para>
        </callout>

        <callout arearefs="coDef-super-3" id="coRef-super-3">
          <para>L'élément <sgmltag>build</sgmltag> définit les positions par défaut des répertoires selon la disposition
          Maven standard des répertoires.</para>
        </callout>

        <callout arearefs="coDef-super-4" id="coRef-super-4">
          <para>Depuis la version 2.0.9 de Maven les versions par défaut des plugins du cœur sont définies dans le Super
          <acronym>POM</acronym>. Cela a été mis en place pour apporter une certaine stabilité aux utilisateurs qui ne
          précisent pas de version dans leurs <acronym>POM</acronym>s.</para>
        </callout>
      </calloutlist>

      <figure id="fig-super-always-base">
        <title>Le Super POM est toujours le parent de plus haut niveau</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/pom-relationships_pom-inherit-simple-super.png" />
          </imageobject>

          <imageobject role="print">
            <imagedata align="center" fileref="figs/print/pom-relationships_pom-inherit-simple-super.pdf" format="PDF"
                       scalefit="0" width="100%" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section id="pom-relationships-sect-simplest-pom">
      <title>Le POM le plus simple possible</title>

      <para>Tous les <acronym>POM</acronym>s Maven héritent leurs valeurs par défaut du Super <acronym>POM</acronym>
      (dont nous avons parlé dans la <xref linkend="pom-relationships-sect-super-pom" />). Si vous écrivez un
      projet tout simple qui produit un <acronym>JAR</acronym> à partir de fichiers source se trouvant dans <filename
      moreinfo="none">src/main/java</filename> dont les tests JUnit à exécuter sont dans <filename
      moreinfo="none">src/test/java</filename> et que vous voulez produire le site web de ce projet avec la commande
      <command moreinfo="none">mvn site</command>, vous n'avez rien à configurer. Vous n'avez besoin, dans ce cas, que
      du <acronym>POM</acronym> le plus simple possible, tel celui présenté dans l'<xref linkend="ex-simplest-pom" />. Ce
      <acronym>POM</acronym> définit un <varname>groupId</varname>, un <varname>artifactId</varname> et une
      <varname>version</varname> : les trois coordonnées exigées pour tout projet.</para>

      <example id="ex-simplest-pom">
        <title>Le POM le plus simple possible</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.ch08&lt;/groupId&gt;
  &lt;artifactId&gt;simplest-project&lt;/artifactId&gt;
  &lt;version&gt;1&lt;/version&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>Un <acronym>POM</acronym> aussi simple serait plus qu'adéquat pour un projet très simple — par exemple, une
      bibliothèque Java qui produirait un fichier <acronym>JAR</acronym>. Ce <acronym>POM</acronym> ne fait aucune
      référence à un autre projet, ne dépend de rien et il lui manque des informations basiques comme son nom et une
      <acronym>URL</acronym>. Si vous créiez un tel fichier et un sous-répertoire <filename
      moreinfo="none">src/main/java</filename> contenant du code source, l'exécution de la commande <command
      moreinfo="none">mvn package</command> produirait le <acronym>JAR</acronym> <filename
      moreinfo="none">target/simple-project-1.jar</filename>.</para>
    </section>

    <section id="pom-relationships-sect-effective-pom">
      <title>Le POM effectif</title>

      <para>Ce <acronym>POM</acronym>, le plus simple soit-il, introduit le concept de <indexterm>
          <primary>effective POMs</primary>
        </indexterm> “<acronym>POM</acronym> effectif”. Comme les <acronym>POM</acronym>s héritent leur configuration
      d'autres <acronym>POM</acronym>s, vous devez toujours voir un <acronym>POM</acronym> Maven comme la combinaison du
      Super <acronym>POM</acronym>, plus tous les <acronym>POM</acronym>s parents intermédiaires et enfin le
      <acronym>POM</acronym> du projet en cours. Maven commence par le Super <acronym>POM</acronym> et surcharge la
      configuration par défaut avec un ou plusieurs <acronym>POM</acronym>s parents. Puis, il surcharge la configuration
      résultante avec les valeurs du <acronym>POM</acronym> du projet. Au final, vous obtenez un <acronym>POM</acronym>
      effectif qui est le résultat de la combinaison de plusieurs <acronym>POM</acronym>s. Si vous voulez voir le
      <acronym>POM</acronym> effectif d'un projet, vous allez devoir exécuter le goal <varname>effective-pom</varname>
      du plugin Maven Help dont nous parlerons dans la <xref
      linkend="installation-sect-help-plugin-install" />. Pour lancer le goal <varname>effective-pom</varname>, exécutez
      la commande suivante dans un répertoire contenant un fichier <filename moreinfo="none">pom.xml</filename> :</para>

      <screen>$ <command>mvn help:effective-pom</command></screen>

      <para>L'exécution du goal <varname>effective-pom</varname> devrait afficher un document <acronym>XML</acronym>
      résultant de la fusion du Super <acronym>POM</acronym> et du <acronym>POM</acronym> de l'<xref
      linkend="ex-simplest-pom" />.</para>
    </section>

    <section id="pom-relationships-sect-real-poms">
      <title>Véritables POMs</title>

      <para>Plutôt que de taper un ensemble de <acronym>POM</acronym>s convenu <indexterm>
          <primary>real POMs</primary>
        </indexterm> pour vous guider pas-à-pas, vous pouvez regarder les exemples fournis dans <xref
      linkend="part-example" />. Maven est un véritable caméléon, vous pouvez choisir et utiliser ce dont vous voulez
      profiter. Certains projets libres peuvent accorder de l'importance à la possibilité de lister les développeurs et
      les contributeurs, de pouvoir produire une documentation claire pour un projet et de pouvoir gérer
      automatiquement les livraisons grâce au plugin Maven Release. Par contre, pour quelqu'un qui travaille dans
      le contexte d'une petite équipe au sein d'une entreprise, les capacités de Maven pour gérer les distributions ou lister
      les développeurs peuvent avoir un moindre intérêt. La suite de ce chapitre va traiter les caractéristiques du
      <acronym>POM</acronym> en lui-même. Au lieu de vous bombarder avec un listing de 10 pages contenant tout un
      ensemble de <acronym>POM</acronym>s , nous allons nous concentrer sur la création d'une bonne référence pour
      chacune des sections spécifiques du <acronym>POM</acronym>. Dans ce chapitre, nous allons parler des relations
      entre les <acronym>POM</acronym>s mais sans ajouter un nouvel exemple pour l'illustrer. Si vous voulez un tel
      exemple, vous le trouverez dans le <xref linkend="multimodule-web-spring" />.</para>
    </section>
  </section>

  <section id="pom-relationships-sect-pom-syntax">
    <title>Syntaxe de POM</title>

    <para>Le <acronym>POM</acronym> se trouve toujours <indexterm class="startofrange" id="pom2">
        <primary>POM (Project Object Model)</primary>

        <secondary>syntax</secondary>
      </indexterm>dans un fichier <filename moreinfo="none">pom.xml</filename> dans le répertoire racine d'un projet
    Maven. Ce document <acronym>XML</acronym> peut commencer par la déclaration <acronym>XML</acronym>, mais elle n'est
    pas obligatoire. Toutes les valeurs dans un <acronym>POM</acronym> se présentent sous la forme d'éléments
    <acronym>XML</acronym>.</para>

    <section id="pom-reationships-sect-versions">
      <title>Les versions d'un projet</title>

      <para>La balise <sgmltag>version</sgmltag> d'un projet Maven contient le numéro de<indexterm>
          <primary>major versions (projects)</primary>
        </indexterm><indexterm>
          <primary>minor versions (projects)</primary>
        </indexterm><indexterm>
          <primary>incremental versions (projects)</primary>
        </indexterm><indexterm>
          <primary>qualifiers for project versions</primary>
        </indexterm><indexterm>
          <primary>project versions, about</primary>

          <seealso>version attribute</seealso>
        </indexterm><indexterm>
          <primary>version attribute (pom.xml)</primary>
        </indexterm><indexterm>
          <primary>project versions, about</primary>
        </indexterm> version stable qui est utilisé pour regrouper et ordonner les distributions. Les versions dans Maven
      se décomposent ainsi : version majeure, version mineure, version incrémentale et qualifieur. Dans un numéro de
      version, ces différents éléments se présentent selon le format suivant :</para>

      <screen>&lt;version majeure&gt;.&lt;version mineure&gt;.&lt;version incrémentale&gt;-&lt;qualifieur&gt;</screen>

      <para>Par exemple, la version "1.3.5" correspond à la version majeure 1, mineure 3 et incrémentale 5. La version 
      "5" correspond à la version majeure 5 sans version mineure ou incrémentale. Le qualifieur est utilisé pour les
      builds des étapes intermédiaires : distributions alpha ou beta, et il est séparé des autres éléments de version
      par un tiret. Par exemple, la version "1.3-beta-01" a une version majeure 1, mineure 3 et un qualifieur
      "beta-01".</para>

      <para>Suivre ces préconisations pour les numéros de version prend tout son sens lorsque vous commencez à utiliser
      des intervalles pour vos versions dans les <acronym>POM</acronym>s. Les intervalles de versions seront abordés
      dans la <xref linkend="pom-relationships-sect-version-ranges" />. Ils permettent de spécifier une dépendance dont
      la version est comprise dans cet intervalle. Cela n'est possible que parce que Maven est capable de trier les
      versions en se basant sur le format de numéro de version dont nous venons de parler.</para>

      <para>Si votre numéro de version respecte le format
      <varname>&lt;majeure&gt;.</varname><varname>&lt;mineure&gt;.</varname><varname>&lt;incrémentale&gt;-&lt;qualifieur&gt;</varname>
      alors vos versions seront correctement ordonnées, "1.2.3" sera donc bien considérée comme plus récente que
      "1.0.2". La comparaison se fera en utilisant les valeurs numériques des versions majeure, mineure et incrémentale.
      Si votre numéro de version ne respecte pas ce standard, alors vos versions seront comparées comme des chaînes de
      caractères ; la chaîne "1.0.1b" sera comparée à la chaîne "1.2.0b".</para>

      <section id="pom-relationships-sect-version-build-numbers">
        <title>Numéro de version de build</title>

        <para>Un des problèmes avec les numéros de version est l'ordonnancement des<indexterm>
            <primary>ordering of version qualifiers</primary>
          </indexterm><indexterm>
            <primary>qualifiers for project versions</primary>

            <secondary>ordering of</secondary>
          </indexterm> qualifieurs. Prenez par exemple, les numéros de version “1.2.3-alpha-2” et “1.2.3-alpha-10” où
        “<phrase role="keep-together">alpha-2</phrase>” correspond au second build alpha et “alpha-10” au dixième build
        alpha. Alors que le build “alpha-10” devrait être considéré comme plus récent que le build “alpha-2”, Maven va
        mettre “alpha-10” avant “alpha-2”. Ceci est dû à un problème connu dans la façon dont Maven traite les numéros
        de version.</para>

        <para>Maven doit, en théorie, considérer le nombre après le qualifieur comme le numéro du build. En d'autres
        termes, le qualifieur devrait être "alpha", et le numéro du build 2. Même si Maven a été conçu pour séparer le
        numéro du build du qualifieur, cette fonctionnalité ne fonctionne pas actuellement. En conséquence, "alpha-2" et
        "alpha-10" sont comparés comme des chaînes de caractères, ce qui positionne "alpha-10" avant "alpha-2"
        alphabétiquement. Pour contourner cette limitation, vous devez compléter à gauche vos numéros de version de build
        qualifiés. Si vous utilisez "alpha-02" et "alpha-10" vous n'aurez plus ce problème, et tout continuera à bien 
        fonctionner le jour où Maven traitera correctement les numéros de version de build.</para>
      </section>

      <section id="pom-relationships-sect-snapshot-versions">
        <title>Les versions SNAPSHOT</title>

        <para>Les numéros de versions dans Maven peuvent contenir une chaîne de caractères pour indiquer que le
        <indexterm>
            <primary>snapshot versions</primary>
          </indexterm>projet est en cours de développement. Si une version contient la chaîne “SNAPSHOT”, alors Maven va
        prendre en compte cette clef et la convertir en une valeur de type date et heure au format
        <acronym>UTC</acronym> (Coordinated Universal Time) quand vous installerez ou publierez ce composant. Par exemple,
        si votre projet est en version “1.0-SNAPSHOT” et que vous déployez ses artefacts sur un dépôt Maven, Maven va
        alors convertir cette version en “1.0-20080207-230803-1” si vous réalisez votre déploiement le 7 Février 2008 à
        23:08 <acronym>UTC</acronym>. En d'autres termes, quand vous déployez un snapshot, vous ne livrez pas un composant
        logiciel ; vous livrez un instantané d'un composant.</para>

        <para>Pourquoi utiliser cette fonctionnalité ? Les versions SNAPSHOT sont utilisées pour les projets en cours de
        développement. Si votre projet dépend d'un composant logiciel en cours de développement, vous pouvez dépendre
        d'une version SNAPSHOT, Maven essayera alors de télécharger périodiquement la dernière version snapshot du dépôt
        lorsque vous lancerez votre build. De même, si la prochaine livraison de votre système est la
        version "1.4", tant que votre projet n'est pas livré définitivement, il devrait être en version
        "1.4-SNAPSHOT".</para>

        <para>Par défaut, Maven ne va pas vérifier la présence de versions SNAPSHOT sur les dépôts distants. Pour
        pouvoir dépendre de versions SNAPSHOT les utilisateurs doivent donc activer explicitement le téléchargement des
        snapshots au travers des balises XML <sgmltag>repository</sgmltag> ou <sgmltag>pluginRepository</sgmltag> dans
        le <acronym>POM</acronym>.</para>

        <para>Lorsque vous livrez un projet vous devriez remplacer toutes vos dépendances sur des versions SNAPSHOT par
        des dépendances vers des versions stables. Si un projet dépend d'un SNAPSHOT, il n'est pas stable car
        ses dépendances peuvent évoluer dans le temps. Les artefacts publiés sur les dépôts Maven stables comme <ulink
        url="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</ulink> ne peuvent pas dépendre de versions
        SNAPSHOT. Le Super <acronym>POM</acronym> de Maven désactive la publication de snapshots sur le dépôt Central.
        Les versions SNAPSHOT sont utilisées uniquement pour le développement.</para>
      </section>
<!--
      <section id="pom-relationships-sect-latest-release">
        <title>Les versions LATEST et RELEASE</title>

        <para>Quand vous dépendez d'un plugin ou d'une bibliothèque, vous pouvez utiliser LATEST ou RELEASE comme
        numéro de version. LATEST indique que la version correspond à la dernière version déployée d'un artefact sur un
        dépôt particulier, qu'il s'agisse d'une version stable ou d'une version snapshot. RELEASE indique la dernière
        version stable déployée sur le dépôt. En général, dépendre d'une version explicite d'un artefact n'est pas une
        bonne pratique. Si vous êtes en train de développer un logiciel, vous pouvez être amené à utiliser RELEASE ou
        LATEST comme une facilité pour ne pas à mettre à jour les numéros de version lorsqu'une bibliothèque tierce est
        déployée. Quand vous livrer un logiciel, vous devriez toujours vous assurer que votre projet dépend de versions
        spéciques pour limiter l'impact sur votre build d'un déploiement d'artefacts hors de votre contrôle. Utilisez
        donc LATEST et RELEASE prudemment, voire pas du tout.</para>

        <para>Depuis la version 2.0.9 de Maven, les numéros de version des plugins qui constituent le cœur de Maven sont
        fixés dans le super POM pour lier un ensemble des principaux plugins de Maven à une version de Maven. Ce
        changement a été introduit à partir de la version 2.0.9 de Maven pour apporter de la stabilité et de la
        reproductibilité aux builds Maven. Avant Maven 2.0.9, Maven mettait automatiqument à jour les principaux plugins
        en utilisant la version LATEST. Ce comportement apportait son lot de surprises quand des bugs apparaissaient
        dans les plugin du cœur ou que leurs fonctionnement avaient changé ce qui faisait échouer le build. Quand Maven
        mettait automatiquement à jour ses plugins principaux, il n'y avait aucune garantie que les builds soient
        reproductibles puisque des plugins pouvaient avoir changé suite àau déploiement d'une nouvelle version sur le
        dépôt centrel. Depuis Maven 2.0.9, Maven, essentially, est livré avec des versions fixes des principaux plugins.
        Les plugins qui ne constituent pas le cœur de Maven ou dont le numéro de version n'est pas défini dans le Super
        POM, seront considérés comme utilisant la version LATEST lors de la récupération de leurs artefacts depuis le
        dépôt. C'est pour cette raison que vous devriez explicitement définir les numéros de version pour tous les
        plugins de votre build, qu'ils vous soient propres ou qu'ils ne fassent pas partie des principaux plugins de
        Maven.</para>
      </section>
  -->
    </section>

    <section id="pom-relationships-sect-property-refs">
      <title>Référence à une propriété</title>

      <para>Un <acronym>POM</acronym> peut contenir des références à des propriétés<indexterm>
          <primary>properties</primary>

          <secondary>referencing in pom.xml</secondary>
        </indexterm><indexterm>
          <primary>references to properties, in pom.xml</primary>
        </indexterm>, elles sont précédées par le signe dollar et entourées par des accolades. Par exemple, regardons le
      <acronym>POM</acronym> suivant :</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;build&gt;
    &lt;finalName&gt;\${project.groupId}-\${project.artifactId}&lt;/finalName&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>

      <para>Si vous écrivez ce <acronym>XML</acronym> dans un fichier <filename>pom.xml</filename> et que vous exécutez 
      la commande <command>mvn help:effective-pom</command>, vous verrez le message suivant s'afficher sur la sortie
      standard :</para>

      <programlisting language="xml">...
&lt;finalName&gt;org.sonatype.mavenbook-project-a&lt;/finalName&gt;
...</programlisting>

      <para>Quand Maven lit un <acronym>POM</acronym>, il remplace les références vers des propriétés lorsqu'il charge le
      <acronym>XML</acronym> du <acronym>POM</acronym>. On rencontre fréquemment des propriétés dans un usage avancé de
      Maven. Ces propriétés sont similaires à celles que l'on trouve dans d'autres systèmes comme Ant ou Velocity. Il
      s'agit tout simplement de variables délimitées par <varname>\${...</varname><varname>}</varname>. Maven fournit
      trois variables implicites qui peuvent être utilisées pour accéder aux variables d'environnement, aux informations
      du <acronym>POM</acronym> et à votre configuration de Maven :</para>

      <variablelist>
        <varlistentry>
          <term>env</term>

          <listitem>
            <para>La variable <varname>env</varname> permet d'accéder aux variables d'environnement <indexterm>
                <primary>env variable</primary>
              </indexterm><indexterm>
                <primary>implicit variables, list of</primary>
              </indexterm> de votre système d'exploitation ou de votre shell. Par exemple, une référence à
            <varname>\${env.</varname><varname>PATH}</varname> dans un <acronym>POM</acronym> Maven serait remplacée par
            le contenu de la variable d'environnement <varname>\${PATH}</varname> (ou <varname>%PATH%</varname> sous
            Windows).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>project</term>

          <listitem>
            <para>La variable <varname>project</varname> permet d'accéder au<indexterm>
                <primary>project variable</primary>
              </indexterm> <acronym>POM</acronym>. Vous pouvez utiliser un chemin pavé de points ('.') pour référencer la
            valeur d'un élément du <acronym>POM</acronym>. Par exemple, dans cette section nous avons utilisé le
            <varname>groupId</varname> et l'<varname>artifactId</varname> pour définir la valeur de l'élément
            <sgmltag>finalName</sgmltag> dans la configuration du build. La syntaxe pour cette référence était :
            <code>\${project.groupId}-\${project.</code><code>artifactId}</code>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>settings</term>

          <listitem>
            <para>La variable <varname>settings</varname> permet d'accéder aux informations de <indexterm>
                <primary>settings variable</primary>
              </indexterm>votre configuration de Maven. Là encore, vous pouvez utiliser un chemin pavé de points (.)
            pour référencer la valeur d'un élément du fichier <filename moreinfo="none">settings.xml</filename>. Par
            exemple, <varname>\${settings.offline}</varname> ferait référence à la valeur de l'élément
            <sgmltag>offline</sgmltag> du fichier <filename moreinfo="none">~/.m2/settings.xml</filename>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <note>
        <para>Vous pouvez rencontrer d'anciens builds qui utilisent <varname>\${pom.xxx}</varname> ou simplement
        <varname>\${xxx}</varname> pour référencer des propriétés du <acronym>POM</acronym>. Ces méthodes ont été
        marquées comme abandonnées, et vous ne devriez utiliser que <varname>\${project.xxx}</varname>.</para>
      </note>

      <para>En plus de ces trois variables implicites, vous pouvez référencer <indexterm>
          <primary>system properties, referencing</primary>
        </indexterm> les propriétés système et toute propriété configurée dans un <acronym>POM</acronym> Maven ou dans
      un profil de build :</para>

      <variablelist>
        <varlistentry>
          <term>Propriétés système en Java</term>

          <listitem>
            <para>Toutes les propriétés accessibles via la méthode<indexterm>
                <primary>Java system properties, referencing</primary>
              </indexterm> <methodname>getProperties()</methodname> de la classe
            <classname>java.lang.</classname><classname>System</classname> sont visibles comme propriétés du
            <acronym>POM</acronym>. Voici quelques exemples de propriétés système :
            <varname>\${user.name}</varname>, <varname role="keep-together">\${user.home}</varname>,
            <varname>\${java.home}</varname>, et <varname>\${os.name}</varname>. Une liste complète des propriétés
            système se trouve dans la Javadoc de la classe
            <classname>java.lang.</classname><classname>System</classname>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>x</term>

          <listitem>
            <para>Il est possible de définir des propriétés supplémentaires grâce à la balise<indexterm>
                <primary>arbitrary properties, referencing</primary>
              </indexterm> <varname>properties</varname>, soit dans un fichier <filename moreinfo="none">pom.xml</filename>,
              dans le fichier <filename moreinfo="none" role="keep-together">settings.xml</filename>, ou enfin en les
              chargeant depuis des fichiers externes. Si vous définissez une propriété <varname>fooBar</varname>
              dans votre fichier <filename moreinfo="none">pom.xml</filename>, cette propriété est référencée par
            <varname>\${fooBar}</varname>. Ces propriétés de configuration sont très pratiques lorsque pour construire
            votre système, vous devez filtrer des ressources que vous déployez sur différentes plateformes. Voici la
            syntaxe pour déclarer <literal>\${foo}=bar</literal> dans un <acronym>POM</acronym>:</para>

            <programlisting language="xml">&lt;properties&gt;
  &lt;foo&gt;bar&lt;/foo&gt;
&lt;/properties&gt;</programlisting>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Pour une liste plus détaillée des propriétés disponibles, lisez le <xref
      linkend="resource-filtering" />.</para>
    </section>
  </section>

  <section id="pom-relationships-sect-project-dependencies">
    <title>Dépendances d'un projet</title>

    <para>Maven sait gérer des dépendances internes et externes. Pour un projet Java, une<indexterm class="startofrange" id="pom3a">
        <primary>dependencies</primary>
      </indexterm><indexterm>
        <primary>POM (Project Object Model)</primary>

        <secondary>project dependencies</secondary>

        <see>dependencies</see>
      </indexterm><indexterm>
        <primary>project dependencies</primary>

        <see>dependencies</see>
      </indexterm><indexterm>
        <primary>external dependencies</primary>
      </indexterm><indexterm>
        <primary>internal dependencies</primary>

        <seealso>dependencies</seealso>
      </indexterm><indexterm>
        <primary>internal dependencies</primary>

        <seealso>dependencies</seealso>
      </indexterm> dépendance externe est une bibliothèque comme Plexus, Spring ou Log4J. Un
    exemple de dépendance interne est un projet d'application web qui dépend d'un autre projet contenant les classes des
    services, des objets du domaine ou assurant la persistance. L'<xref linkend="ex-dependency" /> donne un exemple des
    dépendances d'un projet.</para>

    <para><example id="ex-dependency">
        <title>Dépendances d'un projet</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.codehaus.xfire&lt;/groupId&gt;
      &lt;artifactId&gt;xfire-java5&lt;/artifactId&gt;
      &lt;version&gt;1.2.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
      &lt;version&gt;2.4&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  ...
&lt;/project&gt;
</programlisting>
      </example></para>

    <para>La première dépendance est une dépendance de compilation vers la bibliothèque XFire <acronym>SOAP</acronym> de
    chez Codehaus. Vous pouvez utiliser une dépendance de ce type dans votre projet lorsque celui-ci dépend d'une
    bibliothèque pour compiler, exécuter les tests et s'exécuter. La deuxième dépendance est une dépendance sur
    JUnit avec la portée (scope) <literal>test</literal>. Vous pouvez utiliser une dépendance dans le scope
    <literal>test</literal> lorsque vous n'avez besoin de cette bibliothèque que pour compiler et exécuter les tests. La
    dernière dépendance de l'<xref linkend="ex-dependency" /> est une dépendance sur l'<acronym>API</acronym> Servlet
    2.4. Cette dernière dépendance se trouve dans le scope <literal>provided</literal>. Vous pouvez utiliser le scope
    <literal>provided</literal> quand votre application a besoin d'une bibliothèque à la compilation ainsi que pour les
    tests et que cette bibliothèque est fournie par un conteneur à l'exécution.</para>

    <section id="pom-relationships-sect-dependency-scope">
      <title>Scope de dépendance</title>

      <para>L'<xref linkend="ex-dependency" /> nous a permis d'introduire brièvement trois des <indexterm>
          <primary>scope, dependency</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>scope of</secondary>
        </indexterm>cinq scopes de dépendance : <literal>compile</literal>, <literal>test</literal> et
      <literal>provided</literal>. Le scope contrôle dans quel classpath vont se retrouver les dépendances et quelles
      seront celles qui seront intégrées à l'application. Regardons ces scopes plus en détail :</para>

      <variablelist>
        <varlistentry>
          <term>compile</term>

          <listitem>
            <para><literal>compile</literal> est le scope par défaut ; toutes les dépendances sont dans ce scope
            <indexterm>
                <primary>compile dependencies</primary>
              </indexterm><literal>compile</literal> si aucun scope n'est précisé. Les dépendances du scope
            <literal>compile</literal> se retrouvent dans tous les classpaths et sont packagées avec l'application.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>provided</term>

          <listitem>
            <para>Les dépendances du scope <literal>provided</literal> sont utilisées lorsqu'elles doivent être fournies
            par le <acronym>JDK</acronym> ou un conteneur. Par <indexterm>
                <primary>provided dependencies</primary>
              </indexterm>exemple, si vous développez une application web, vous aurez besoin de l'<acronym>API</acronym>
            Servlet dans votre classpath pour pouvoir compiler une servlet, mais vous ne voudrez pas inclure
            l'<acronym>API</acronym> Servlet dans votre fichier <acronym>WAR</acronym> ; le <acronym>JAR</acronym> de
            l'<acronym>API</acronym> Servlet est fourni par votre serveur d'applications ou par votre conteneur de
            servlet. Les dépendances du scope <literal>provided</literal> font partie du classpath de compilation (mais
            pas de celui d'exécution). Elles ne sont pas transitives et ne seront pas packagées avec
            l'application.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>runtime</term>

          <listitem>
            <para>Les dépendances du scope <literal>runtime</literal> sont des dépendances nécessaires à l'exécution de
            l'application et des tests<indexterm>
                <primary>runtime dependencies</primary>
              </indexterm>, mais qui sont inutiles à la compilation. Par exemple, vous pouvez avoir besoin d'un
            <acronym>JAR</acronym> pour l'<acronym>API</acronym> <acronym>JDBC</acronym> à la compilation et uniquement
            de l'implémentation du driver <acronym>JDBC</acronym> à l'exécution.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>test</term>

          <listitem>
            <para>Les dépendances du scope <literal>test</literal> sont des dépendances qui ne sont pas nécessaires à
            l'application <indexterm>
                <primary>dependencies</primary>

                <secondary>test-scoped</secondary>
              </indexterm><indexterm>
                <primary>test-scoped dependencies</primary>
              </indexterm><indexterm>
                <primary>unit tests</primary>

                <secondary>test-scoped dependencies</secondary>
              </indexterm><indexterm>
                <primary>testing</primary>

                <secondary>using test-scoped dependencies</secondary>
              </indexterm>durant son fonctionnement normal, elles ne servent que durant les phases de compilation et
            d'exécution des tests. Nous avons déjà parlé du scope <literal>test</literal> dans la <xref
            linkend="customizing-sect-test-scope" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>system</term>

          <listitem>
            <para>Le scope <literal>system</literal> est assez proche du scope <literal>provided</literal> sauf que vous
            devez <indexterm>
                <primary>system-scope dependencies</primary>
              </indexterm>fournir un chemin explicite vers le <acronym>JAR</acronym> sur le système de fichiers local. Il
            permet la compilation utilisant des objets natifs faisant partie des bibliothèques système. On suppose que
            cet artefact est toujours présent et donc il ne sera pas cherché dans un dépôt. Si vous utilisez le scope
            <literal>system</literal>, vous devez automatiquement lui adjoindre une balise
            <sgmltag>systemPath</sgmltag>. Il est important de noter que l'utilisation de ce scope n'est pas recommandée
            (vous devriez toujours essayer de référencer des dépendances qui se trouvent dans un dépôt Maven public ou privé).</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section id="pom-relationships-sect-optional">
      <title>Dépendances optionnelles</title>

      <para>Supposons que vous travaillez sur une bibliothèque qui fournit un service <indexterm>
          <primary>optional dependencies</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>optional</secondary>
        </indexterm>de cache. Au lieu d'écrire votre propre système de cache en partant de zéro, vous voulez utiliser
      certaines des bibliothèques existantes qui gèrent un cache sur le système de fichiers ou un cache distribué.
      Supposons encore que vous voulez permettre à l'utilisateur final de choisir entre un cache sur le système de
      fichiers et un cache distribué en mémoire. Vous voulez utiliser la bibliothèque libre EHCache (<ulink
      url="http://ehcache.sourceforge.net/">http://ehcache.sourceforge.net/</ulink>) pour le cache sur le système de
      fichiers, et pour le cache distribué <phrase role="keep-together"> en mémoire</phrase>, vous voulez utiliser
      SwarmCache (<ulink url="http://swarmcache.sourceforge.net/">http://swarmcache.sourceforge.net/</ulink>), une autre
      bibliothèque libre. Vous allez écrire une interface et créer une bibliothèque qui pourra être configurée pour
      utiliser EHCache ou SwarmCache, cependant vous ne voulez pas ajouter une dépendance vers ces deux bibliothèques de
      cache dans chaque projet qui dépendrait de votre bibliothèque.</para>

      <para>En d'autres termes, vous avez besoin de ces deux bibliothèques à la compilation de votre projet, mais vous
      ne voulez pas que toutes les deux apparaissent comme des dépendances transitives nécessaires à l'exécution dans un
      projet qui utiliserait votre bibliothèque. Vous pouvez réaliser cela en utilisant des dépendances optionnelles
      comme dans l'<xref linkend="ex-optional-depend" />.</para>

      <example id="ex-optional-depend">
        <title>Déclaration de dépendances optionnelles</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;my-project&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
      &lt;artifactId&gt;ehcache&lt;/artifactId&gt;
      &lt;version&gt;1.4.1&lt;/version&gt;
      &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;swarmcache&lt;/groupId&gt;
      &lt;artifactId&gt;swarmcache&lt;/artifactId&gt;
      &lt;version&gt;1.0RC2&lt;/version&gt;
      &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j&lt;/artifactId&gt;
      &lt;version&gt;1.2.13&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>Une fois que vous avez déclaré ces dépendances comme optionnelles, vous devrez les ajouter de manière
      explicite dans les projets qui dépendront de <varname>my-project</varname>. Par exemple, si vous écrivez une
      application qui dépend de <varname>my-project</varname> et que vous voulez utiliser l'implémentation EHCache, vous
      devrez ajouter la balise <sgmltag>dependency</sgmltag> suivante à votre projet.</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;my-application&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
      &lt;artifactId&gt;my-project&lt;/artifactId&gt;
      &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
      &lt;artifactId&gt;swarmcache&lt;/artifactId&gt;
      &lt;version&gt;1.4.1&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>

      <para>Dans un monde idéal, vous ne devriez pas avoir besoin de dépendances optionnelles. Au lieu d'avoir un gros
      projet avec un ensemble de dépendances optionnelles, vous devriez isoler le code <phrase
      role="keep-together">spécifique à EHCache</phrase> dans un sous-module <varname>my-project-ehcache</varname> et le
      code <phrase role="keep-together">spécifique à SwarmCache</phrase> dans un autre sous-module
      <varname>my-project-swarmcache</varname>. Ainsi, les projets qui référencent <varname>my-project</varname> et qui
      doivent ajouter une dépendance spécifique, pourraient référencer une dépendance vers une implémentation spécifique
      et bénéficieraient ainsi des dépendances transitives.</para>
    </section>

    <section id="pom-relationships-sect-version-ranges">
      <title>Intervalle de versions pour une dépendance</title>

      <para>Vous n'avez pas à dépendre d'une version spécifique d'une <indexterm>
          <primary>version attribute (pom.xml)</primary>

          <secondary>dependency version ranges</secondary>
        </indexterm><indexterm>
          <primary>project versions, about</primary>

          <secondary>dependency version ranges</secondary>
        </indexterm><indexterm>
          <primary>ranges for dependency versions</primary>
        </indexterm>dépendance, vous pouvez définir un ensemble de versions acceptables pour une dépendance donnée. Par
      exemple, vous pouvez configurer votre projet pour qu'il dépende de JUnit 3.8 ou supérieure, ou toutes les versions
      de JUnit comprises entre 1.2.10 et 1.2.14. Pour cela, vous devez entourer les numéros de versions avec les
      caractères suivants :</para>
      <variablelist>
        <varlistentry>
          <term role="plain">(, )</term>
          <listitem>
            <para>pour définir un intervalle ouvert</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term role="plain">[, ]</term>
          <listitem>
            <para>pour définir un intervalle fermé</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>Par exemple, si vous voulez accéder aux versions de <code>JUnit </code>supérieures ou égales à 3.8 mais
      inférieures à 4.0, vous déclareriez votre dépendance comme dans l'<xref linkend="ex-dep-range" />.</para>

      <para><example id="ex-dep-range">
          <title>Définition d'un intervalle de versions : JUnit 3.8 - JUnit 4.0</title>

          <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;junit&lt;/groupId&gt;
  &lt;artifactId&gt;junit&lt;/artifactId&gt;
  &lt;version&gt;[3.8,4.0)&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</programlisting>
        </example></para>

      <para>Si vous voulez dépendre de JUnit pour toutes les versions inférieures à <indexterm>
          <primary>upper boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>inclusive boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>lower boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>exclusive boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>boundaries for version ranges, specifying</primary>
        </indexterm> 3.8.1, vous ne devez spécifier que la borne supérieure comme dans l'<xref
      linkend="ex-dep-range-2" />.</para>

      <example id="ex-dep-range-2">
        <title>Définition d'un intervalle de versions : JUnit &lt;= 3.8.1</title>

        <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;junit&lt;/groupId&gt;
  &lt;artifactId&gt;junit&lt;/artifactId&gt;
  &lt;version&gt;[,3.8.1]&lt;/version&gt;ex-de
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</programlisting>
      </example>

      <para>Une version avant ou après la virgule n'est pas obligatoire et signifie +/- l'infini. Par exemple, "[4.0,)"
      signifie toute version supérieure ou égale à 4.0. "(,2.0)" signifie toute version strictement inférieure à 2.0.
      "[1.2]" signifie uniquement la version 1.2, et rien d'autre.</para>

      <note>
        <para>Quand vous déclarez une version "normale" telle que la version 3.8.2 de JUnit, Maven voit cette déclaration
        comme "accepter toute version, mais en préférant la version 3.8.2". Ce qui signifie que
        lorsqu'un conflit est détecté, Maven s'autorise l'utilisation des algorithmes de résolution de conflit pour
        choisir la meilleure version. Si vous spécifiez [3.8.2], cela indique que seule la version 3.8.2 sera utilisée
        et aucune autre. Si ailleurs il se trouve une dépendance qui spécifie [3.8.1], le build va échouer en vous
        indiquant le conflit en question. Nous vous précisons tout cela pour que vous soyez au courant de cette option,
        mais n'utilisez là que lorsque c'est véritablement nécessaire. Pour résoudre ces conflits de version, il est
        préférable de passer par la balise <sgmltag>dependencyManagement</sgmltag>.</para>
      </note>
    </section>

    <section id="pom-relationships-sect-transitive">
      <title>Dépendances transitives</title>

      <para>Une dépendance transitive est la dépendance d'une dépendance. Si <indexterm>
          <primary>transitive dependencies</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>transitive</secondary>

          <see>transitive dependencies</see>
        </indexterm>le <varname>projet-a</varname> dépend du <varname>projet-b</varname>, qui lui-même dépend à son tour
      du <varname>projet-c</varname>, alors le <varname>projet-c</varname> est une dépendance transitive du
      <varname>projet-a</varname>. Si le <varname>projet-c</varname> dépendait du <varname>projet-d</varname>, alors le
      <varname>projet-d</varname> serait lui aussi une dépendance transitive du <varname>projet-a</varname>. Un des
      grands intérêts de Maven et qu'il sait gérer les dépendances transitives.  Il évite ainsi au développeur d'avoir à
      gérer l'ensemble des dépendances nécessaires pour compiler et exécuter une application. Vous pouvez ainsi dépendre
      uniquement de Spring sans avoir à gérer toutes les dépendances de Spring.</para>

      <para>Maven réalise cette opération en construisant un graphe des dépendances et en gérant les conflits et les
      recouvrements qui pourraient arriver. Par exemple, si Maven s'aperçoit que deux projets dépendent des mêmes
      <varname>groupId</varname> et <varname>artifactId</varname>, il va automatiquement trouver la dépendance à
      utiliser, en favorisant toujours la version la plus récente. Même si tout cela semble fort pratique, il existe un
      certain nombre de cas où les dépendances transitives peuvent entraîner des problèmes de configuration. Dans ce
      cas, vous pouvez utiliser l'exclusion de dépendance.</para>

      <section id="pom-relationships-sect-transitive-scope">
        <title>Dépendances transitives et scope</title>

        <para>Chacun des scopes présentés plus tôt dans la <xref linkend="pom-relationships-sect-dependency-scope" />
        affecte non seulement le scope de la <indexterm>
            <primary>scope, dependency</primary>

            <secondary>transitive dependencies and</secondary>
          </indexterm>dépendance dans le projet, mais aussi le comportement transitif de cette dépendance.
          La manière la plus simple de présenter tout cela est sous la forme d'un tableau, comme celui du 
        <xref linkend="table-transitive-dep-and-scope" />. Les scopes dans la première ligne représentent le scope
        d'une dépendance transitive. Les scopes dans la colonne de gauche représentent le scope de la dépendance
        directe. L'intersection des lignes et des colonnes donne le scope de la dépendance transitive. Une cellule vide
        indique que la dépendance transitive ne sera pas prise en compte.</para>

        <para><table id="table-transitive-dep-and-scope">
            <title>Comment le scope affecte les dépendances transitives</title>

            <tgroup cols="5">
              <thead>
                <row>
                  <entry>Scope Direct</entry>
                  
                  <entry>Scope Transitif</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry></entry>

                  <entry><emphasis>compile</emphasis></entry>

                  <entry><emphasis>provided</emphasis></entry>

                  <entry><emphasis>runtime</emphasis></entry>

                  <entry><emphasis>test</emphasis></entry>
                </row>

                <row>
                  <entry><emphasis>compile</emphasis></entry>

                  <entry>compile</entry>

                  <entry>-</entry>

                  <entry>runtime</entry>

                  <entry>-</entry>
                </row>

                <row>
                  <entry><emphasis>provided</emphasis></entry>

                  <entry>provided</entry>

                  <entry>provided</entry>

                  <entry>provided</entry>

                  <entry>-</entry>
                </row>

                <row>
                  <entry><emphasis>runtime</emphasis></entry>

                  <entry>runtime</entry>

                  <entry>-</entry>

                  <entry>runtime</entry>

                  <entry>-</entry>
                </row>

                <row>
                  <entry><emphasis>test</emphasis></entry>

                  <entry>test</entry>

                  <entry>-</entry>

                  <entry>test</entry>

                  <entry>-</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>

        <para>Pour illustrer la relation entre le scope d'une dépendance transitive et le scope d'une dépendance
        directe, voici quelques exemples. Si le <varname>projet-a</varname> possède une dépendance dans le scope test
        vers le <varname>projet-b</varname> qui a une dépendance dans le scope compile vers le
        <varname>projet-c</varname>. Le <varname>projet-c</varname> sera donc une dépendance transitive du
        <varname>projet-a</varname> dans le scope test.</para>

        <para>Vous pouvez voir cela comme une ligne de transitivité qui agit comme un filtre sur le scope de dépendance.
        Les dépendances transitives qui sont dans les scopes test et provided n'ont en général pas d'effet sur un
        projet. L'exception à cette règle concerne les dépendances transitives provided de dépendances elles-aussi
        provided qui seront donc des dépendances dans le scope provided du projet. Les dépendances transitives qui sont
        dans les scopes compile et runtime affectent le projet quelque soit le scope de la dépendance directe. Les
        dépendances transitives qui sont dans le scope compile resteront dans ce scope quelque soit le scope de la
        dépendance directe. Les dépendances transitives qui sont dans le scope runtime seront en général dans le même
        scope que la dépendance directe sauf lorsque cette dernière est dans le scope compile. Quand une dépendance
        transitive est dans le scope runtime et que la dépendance directe est dans le scope compile alors la dépendance
        transitive sera dans le scope effectif runtime.</para>
      </section>
    </section>

    <section id="pom-relationships-sect-conflict">
      <title>Résolution des conflits</title>

      <para>À certains moments, vous aurez besoin d'exclure une dépendance<indexterm>
          <primary>conflict, dependency</primary>
        </indexterm><indexterm>
          <primary>resolving dependency conflicts</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>conflicts with, resolving</secondary>
        </indexterm><indexterm>
          <primary>transitive dependencies</primary>

          <secondary>resolving conflicts with</secondary>
        </indexterm><indexterm>
          <primary>excluding transitive dependencies</primary>
        </indexterm><indexterm>
          <primary>replacing transitive dependencies</primary>
        </indexterm> transitive lorsque votre projet dépend d'un autre projet et que vous voulez retirer complètement la
      dépendance transitive ou que vous souhaitez la remplacer par une autre qui apporte la même fonctionnalité. L'<xref
      linkend="ex-exclude" /> présente une dépendance vers le <varname>projet-a</varname> qui exclut la dépendance
      transitive vers le <varname>projet-b</varname>.</para>

      <para><example id="ex-exclude">
          <title>Exclusion d'une dépendance transitive</title>

          <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;exclusions&gt;
    &lt;exclusion&gt;
      &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
      &lt;artifactId&gt;project-b&lt;/artifactId&gt;
    &lt;/exclusion&gt;
  &lt;/exclusions&gt;
&lt;/dependency&gt;</programlisting>
        </example></para>

      <para>Souvent, vous voudrez remplacer une dépendance transitive par une autre implémentation de la
      fonctionnalité. Par exemple, si vous dépendez d'une bibliothèque qui elle-même dépend de l'<acronym>API</acronym>
      <acronym>JTA</acronym> de Sun, vous pouvez vouloir remplacer cette dépendance transitive. Hibernate en est un bon
      exemple. Hibernate dépend du <acronym>JAR</acronym> de l'<acronym>API</acronym> <acronym>JTA</acronym> de Sun qui
      n'est pas disponible sur le dépôt central de Maven car il n'est pas librement distribuable. Heureusement, le projet
      Apache Geronimo a créé une implémentation indépendante de cette bibliothèque qui est librement redistribuable.
      Pour remplacer une dépendance transitive par une autre, vous devrez exclure la dépendance transitive et ajouter
      l'autre dépendance à votre projet. L'<xref linkend="ex-exclude-replace" /> donne un exemple d'un tel
      remplacement.</para>

      <example id="ex-exclude-replace">
        <title>Exclusion et remplacement d'une dépendance transitive</title>

        <programlisting language="xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate&lt;/artifactId&gt;
    &lt;version&gt;3.2.5.ga&lt;/version&gt;
    &lt;exclusions&gt;
      &lt;exclusion&gt;
        &lt;groupId&gt;javax.transaction&lt;/groupId&gt;
        &lt;artifactId&gt;jta&lt;/artifactId&gt;
      &lt;/exclusion&gt;
    &lt;/exclusions&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;
    &lt;artifactId&gt;geronimo-jta_1.1_spec&lt;/artifactId&gt;
    &lt;version&gt;1.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting>
      </example>

      <para>Dans l'<xref linkend="ex-exclude-replace" />, rien n'indique que la dépendance
      <varname>geronimo-jta_1.1_spec</varname> en remplace une autre, il se trouve juste qu'il s'agit d'une bibliothèque qui
      présente la même <acronym>API</acronym> que la dépendance <acronym>JTA</acronym> originale. Voici d'autres raisons
      pour lesquelles vous voudriez exclure ou remplacer des dépendances transitives :</para>

      <orderedlist>
        <listitem>
          <para>Le <varname>groupId</varname> ou l'<varname>artifactId</varname> de l'artefact a changé alors que le
          projet nécessite une version avec l'autre nom de cet artefact, ce qui fait que vous vous retrouvez avec deux
          copies du même projet dans votre classpath. Normalement, Maven détecte ce genre de conflit et utilise une
          unique version du projet, mais quand les <varname>groupId</varname> et <varname>artifactId</varname> sont
          différents, Maven les considère comme deux bibliothèques distinctes.</para>
        </listitem>

        <listitem>
          <para>Un artefact n'est pas utilisé dans votre projet et la dépendance transitive n'a pas été rendue
          optionnelle. Dans ce cas, vous voulez exclure cette dépendance non requise pour votre projet 
          car vous essayez de réduire le nombre de bibliothèques que vous redistribuez avec votre application.</para>
        </listitem>

        <listitem>
          <para>Un artefact est fourni par votre conteneur à l'exécution et donc il ne doit pas être inclus par votre
          build. Par exemple, si une dépendance dépend de l'API Servlet et que vous voulez être sûr que cette dépendance
          transitive ne se retrouve pas dans le répertoire <filename>WEB-INF/lib</filename> de l'application web.</para>
        </listitem>

        <listitem>
          <para>Pour exclure une dépendance qui peut être une <acronym>API</acronym> avec plusieurs implémentations.
          C'est le cas présenté dans l'<xref linkend="ex-exclude-replace" /> ; où une <acronym>API</acronym> de Sun qui
          demande une acceptation d'une licence et une installation manuelle dans un dépôt personnel (le
          <acronym>JAR</acronym> <acronym>JTA</acronym> de Sun) peut être remplacée par une version librement
          redistribuable de la même <acronym>API</acronym> disponible sur le dépôt central de Maven (l'implémentation
          <acronym>JTA</acronym> de Geronimo).</para>
        </listitem>
      </orderedlist>
    </section>

    <section id="pom-relationships-sect-dep-manage">
      <title>Gestion des dépendances</title>

      <para>Une fois que vous avez adopté Maven dans votre multinationale, vous allez vous demander
      s'il n'existe pas une meilleure manière de gérer les versions des dépendances dans vos deux cent vingt projets
      Maven interdépendants. Si chaque projet qui utilise une dépendance comme le connecteur Java de MySQL doit gérer
      dans son coin le numéro de version de cette dépendance, vous allez au-devant de graves problèmes le jour où
      vous allez faire évoluer cette version. Puisque les numéros de version sont répartis sur toute l'arborescence du projet,
      vous allez devoir éditer à la main chacun des fichiers <filename>pom.xml</filename> qui fait référence à cette
      dépendance pour être sûr de mettre à jour ce numéro de version partout. Même avec des commandes comme
      <command>find</command>, <command>xargs</command>, et <command>awk</command>, vous risquez d'oublier un
      <acronym>POM</acronym>.</para>

      <para>Heureusement, Maven fournit un moyen de consolider le numéro de version d'une dépendance grâce à la balise
      <sgmltag>dependencyManagement</sgmltag>. Vous rencontrerez habituellement la balise
      <sgmltag>dependencyManagement</sgmltag> dans un <acronym>POM</acronym> parent de haut niveau d'une organisation ou
      d'un projet. L'utilisation de la balise <sgmltag>dependencyManagement</sgmltag> dans un fichier
      <filename>pom.xml</filename> vous permet de référencer une dépendance dans un projet fils sans avoir à spécifier
      la version. Maven va parcourir la hiérarchie des POMs jusqu'à ce qu'il trouve un projet avec une balise
      <sgmltag>dependencyManagement</sgmltag>, il utilisera alors la version déclarée dans cette balise
      <sgmltag>dependencyManagement</sgmltag>.</para>

      <para>Par exemple, si vous avez un grand nombre de projets qui utilisent le connecteur Java MySQL dans sa version
      5.1.2, vous pourriez écrire la balise <sgmltag>dependencyManagement</sgmltag> suivante dans le
      <acronym>POM</acronym> de plus haut niveau de votre projet multimodule.</para>

      <para><example>
          <title>Définition des versions dans un POM de haut niveau</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  ...
  &lt;dependencyManagement&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.2&lt;/version&gt;
      &lt;/dependency&gt;
      ...
    &lt;dependencies&gt;
  &lt;/dependencyManagement&gt;
</programlisting>

          <para>Vous pourrez alors, dans un projet fils, ajouter une dépendance au connecteur Java MySQL avec le
          <acronym>XML</acronym> suivant :</para>

          <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
    &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>

          <para>Faites attention au fait que le projet fils n'a pas déclaré explicitement la version de la dépendance à
          <varname>mysql-connector-java</varname>. Comme cette dépendance a été déclarée dans la balise
          <sgmltag>dependencyManagement</sgmltag> du <acronym>POM</acronym> de plus haut niveau, le numéro de version
          va se propager jusqu'à la dépendance <varname>mysql-connector-java</varname> du projet fils. Attention, si le
          projet fils avait défini une version, celle-ci aurait remplacé la version définie dans la section
          <sgmltag>dependencyManagement</sgmltag> du <acronym>POM</acronym> de plus haut niveau. Tout cela signifie que
          la version déclarée dans <sgmltag>dependencyManagement</sgmltag> n'est utilisée que lorsque le projet fils ne
          déclare pas de version.</para>

          <para>La gestion des dépendances avec un <acronym>POM</acronym> de haut niveau est différente de la
          déclaration d'une dépendance partagée au travers d'un <acronym>POM</acronym> parent. Pour commencer, toutes
          les dépendances sont héritées. Si <varname>mysql-connector-java</varname> était déclarée comme une dépendance
          du projet de plus haut niveau, chaque projet fils ferait référence à cette dépendance. Au lieu d'ajouter des
          dépendances inutiles, l'utilisation de la balise <sgmltag>dependencyManagement</sgmltag> vous permet de
          consolider et de centraliser la gestion des versions des dépendances sans ajouter de dépendances héritées
          par tous les projets fils. En d'autres termes, la balise <sgmltag>dependencyManagement</sgmltag> est
          équivalente à une variable d'environnement qui vous permet de déclarer une dépendance dans un sous-projet sans
          avoir à préciser de numéro de version.</para>
        </example></para>
    </section>
  </section>

  <section id="pom-relationships-sect-project-relationships">
    <title>Relations entre projets</title>

    <para>Une des raisons pour lesquelles nous utilisons Maven est qu'il facilite le suivi des dépendances (et des
    dépendances de dépendances). Quand un projet dépend d'un artefact produit par un autre projet alors cet artefact est
    une dépendance. Dans le cas d'un projet Java, cela peut être aussi simple que de dépendre d'une dépendance externe
    comme Log4J ou JUnit. Les dépendances peuvent donc représenter des dépendances externes, mais elles permettent aussi
    de gérer les dépendances entre projets. Si le <varname>projet-a</varname> dépend du <varname>projet-b</varname>,
    Maven est suffisamment intelligent pour savoir que le <varname>projet-b</varname> doit être construit avant le
    <varname>projet-a</varname>.</para>

    <para>Les relations d'un projet ne se limitent pas aux dépendances et à déterminer tout ce qui est lui nécessaire pour
    construire un artefact. Maven sait modéliser les relations d'un projet vers son parent et entre sous-modules. Cette
    section présente les différentes relations qui peuvent exister entre projets et comment les configurer.</para>

    <section id="pom-relationships-sect-more-coordinates">
      <title>Au sujet des coordonnées</title>

      <para>Les coordonnées permettent de définir de manière unique un projet, nous en avons déjà parlé dans le <xref
      linkend="simple-project" />. Les relations entre projets se font au moyen des coordonnées Maven. Il ne suffit pas
      de dire que le projet-a dépend du projet-b ; en réalité, un projet avec un groupId, un artifactId et une version
      dépend d'un autre projet avec son groupId, son artifactId et sa version. Pour résumer, les coordonnées Maven
      se composent de trois éléments :</para>

      <variablelist>
        <varlistentry>
          <term>groupId</term>

          <listitem>
            <para>Un <varname>groupId</varname> regroupe un ensemble d'artefacts. Ces identifiants de groupe ont, en
            général, la forme d'un package Java. Par exemple, le <varname>groupId</varname>
            <varname>org.</varname><varname>apache.maven</varname> est le groupId de base de l'ensemble des artefacts
            produits par le projet Apache Maven. Les identifiants de groupe sont convertis en chemin dans les dépôts
            Maven ; par exemple le groupId org.apache.maven correspondra au répertoire
            <filename>/maven2/org/apache/maven</filename> sur <ulink
            url="http://repo1.maven.org/maven2/org/apache/maven">repo1.maven.org</ulink>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>artifactId</term>

          <listitem>
            <para>L'<varname>artifactId</varname> est l'identifiant principal du projet. Quand vous produisez un
            artefact, il va prendre le nom de l'<varname>artifactId</varname>. Quand vous faites référence à un projet
            vous utiliserez l'<varname>artifactId</varname>. La combinaison <varname>artifactId</varname>,
            <varname>groupId</varname> doit être unique. En d'autres termes, vous ne pouvez pas avoir deux projets
            distincts avec les mêmes <varname>artifactId</varname> et <varname>groupId</varname> ; les
            <varname>artifactId</varname>s sont uniques pour un <varname>groupId</varname> donné.</para>

            <note>
              <para>Si l'utilisation des '.' est très courante pour les <varname>groupId</varname>s, vous devriez
              éviter d'en utiliser pour les <varname>artifactId</varname>s. En effet, cela peut provoquer des problèmes
              lors de l'interprétation d'un nom complet jusqu'aux sous-composants.</para>
            </note>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>version</term>

          <listitem>
            <para>Quand un artefact est délivré, on lui affecte un numéro de version. Ce numéro de version peut être un
            identifiant numérique tel que "1.0", "1.1.1" ou "1.1.2-alpha-01". Vous pouvez aussi utiliser ce que l'on
            appelle une version snapshot. Une version snapshot est une version d'un composant en cours de développement.
            Les numéros de version snapshot se terminent toujours par SNAPSHOT ; par exemple "1.0-SNAPSHOT",
            "1.1.1-SNAPSHOT" ou "1-SNAPSHOT". La <xref linkend="pom-relationships-sect-version-build-numbers" /> décrit
            les numéros de versions et les intervalles de versions.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Il existe un quatrième identifiant moins utilisé :</para>

      <variablelist>
        <varlistentry>
          <term>classifier</term>

          <listitem>
            <para>On utilise un classifier lorsqu'on livre le même code, mais sous la forme de plusieurs artefacts
            distincts pour des raisons techniques. Par exemple, si vous voulez construire deux arterfacts d'un
            <acronym>JAR</acronym>, un compilé avec le compilateur Java 1.4 et un autre avec le compilateur
            Java 6, vous utiliserez le classifier pour produire deux <acronym>JAR</acronym>s différents avec la
            même combinaison groupId:artifactId:version. Si votre projet utilise des extensions en code natif, vous
            utiliserez le classifier pour distinguer les artefacts selon chaque plate-forme cible. Les classifiers sont
            couramment utilisés lors du packaging du code source, de la JavaDoc d'un artefact ou d'assemblage de
            binaires.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Dans ce livre, lorsque nous évoquons des dépendances, nous utilisons souvent le format simplifié suivant pour
      décrire une dépendance : <varname>groupId</varname>:<varname>artifactId</varname>:<varname>version</varname>.
      Pour référencer la version 2.5 de Spring, nous utiliserions
      <varname>org.</varname><varname>springframework:</varname><varname>spring:</varname><varname>2.5</varname>. Quand
      vous demandez à Maven d'afficher une liste des dépendances grâce au plugin Maven Dependency, vous verrez que Maven
      a tendance à produire des traces en utilisant cette écriture simplifiée.</para>
    </section>

    <section id="pom-relationships-sect-multi-module">
      <title>Projets multimodules</title>

      <para>Les projets multimodules sont des projets qui se composent d'un ensemble de modules à construire. Le
      packaging d'un projet multimodule a toujours pour valeur <varname>pom</varname>, et ce projet produit rarement un
      artefact. Un projet multimodule n'existe que pour regrouper un ensemble de projets dans un même build. La <xref
      linkend="fig-multiproject" /> nous montre une hiérarchie de projets qui se compose de deux projets parents avec un
      packaging de type <varname>pom</varname>, et de trois projets de type <varname>jar</varname>.</para>

      <para><figure id="fig-multiproject">
          <title>Relations dans un projet multimodule</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/pom_multimodule.png" />
            </imageobject>

            <imageobject role="print">
              <imagedata align="center" fileref="figs/print/pom_multimodule.pdf" format="PDF" scalefit="0" width="100%" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>La structure des répertoires sur le système de fichiers suit les relations entre les modules. L'ensemble des
      projets illustré par la <xref linkend="fig-multiproject" /> aurait la structure de répertoires suivante
      :</para>

      <programlisting>top-parent-project/pom.xml
top-parent-project/subparent-parent-project/pom.xml
top-parent-project/subparent-parent-project/project-a/pom.xml
top-parent-project/subparent-parent-project/project-b/pom.xml
top-parent-project/project-c/pom.xml</programlisting>

      <para>Les projets sont liés entre eux par les projets <varname>top-parent-project</varname> et
      <varname>subparent-parent-project</varname> comme <varname>sous-modules</varname> dans un
      <acronym>POM</acronym>. Par exemple, le projet
      <varname>org.sonatype.mavenbook:</varname><varname>top-parent-project</varname> est un projet multimodule avec un
      packaging de type <varname>pom</varname>. Le fichier <filename>pom.xml</filename> du
      projet <varname>top-parent-project</varname> doit posséder la balise <sgmltag>modules</sgmltag> suivante :</para>

      <example>
        <title>Balise modules du projet <varname>top-parent-project</varname></title>

        <programlisting language="xml">&lt;project&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;top-parent-project&lt;/artifactId&gt;
  ...
  &lt;modules&gt;
    &lt;module&gt;subparent-parent-project&lt;/module&gt;
    &lt;module&gt;project-c&lt;/module&gt;
  &lt;/modules&gt;
  ...
&lt;/project&gt;</programlisting>
      </example>

      <para>Quand Maven parse le <acronym>POM</acronym> du projet <varname>top-parent-project</varname>, il analyse la
      balise modules pour s'apercevoir que le projet <varname>top-parent-project</varname> référence les projets
      <varname>subparent-parent-project</varname> et <varname>project-c</varname>. Maven va alors traiter les fichiers
      <filename>pom.xml</filename> dans chacun de ces sous-répertoires. Maven répète cette opération pour chacun des
      sous-modules : il lira le fichier <filename>subparent-parent-project/pom.xml</filename> pour s'apercevoir que le
      projet <varname>subparent-parent-project</varname> fait référence à deux projets dans la balise 
      <sgmltag>modules</sgmltag> suivante :</para>

      <example>
        <title>Balise modules du projet <varname>subparent-parent-project</varname></title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;modules&gt;
    &lt;module&gt;project-a&lt;/module&gt;
    &lt;module&gt;project-b&lt;/module&gt;
  &lt;/modules&gt;
  ...
&lt;/project&gt;</programlisting>
      </example>

      <para>Attention au fait que nous appelons "modules" les projets qui composent un projet multimodule et non
      projets "enfants" ou "fils". Nous agissons ainsi délibérément pour ne pas confondre les projets qui sont liés dans
      un projet multimodule de ceux qui héritent d'un même <acronym>POM</acronym>.</para>
    </section>

    <section id="pom-relationships-sect-project-inheritance">
      <title>Héritage de projet</title>

      <para>Parfois, nous voulons qu'un projet hérite de certaines valeurs d'un POM parent. Vous pourriez être en train
      de construire un énorme système, et vous ne voulez pas répéter les mêmes balises de dépendance encore et encore.
      Vous pouvez éviter de vous répéter dans vos projets par l'héritage grâce à la balise <sgmltag>parent</sgmltag>.
      Quand un projet spécifie un parent, il hérite de l'ensemble des informations du POM du projet parent. Il peut
      redéfinir les valeurs du POM parent et en ajouter.</para>

      <para>Tous les <acronym>POM</acronym>s de Maven héritent d'un <acronym>POM</acronym> parent. Si un
      <acronym>POM</acronym> ne spécifie pas de parent direct au travers de la balise <sgmltag>parent</sgmltag>, ce
      <acronym>POM</acronym> héritera des valeurs définies dans le Super <acronym>POM</acronym>. L'<xref
      linkend="ex-inheritance" /> présente la balise <sgmltag>parent</sgmltag> du <varname>project-a</varname> qui hérite
      du <acronym>POM</acronym> du projet <varname>a-parent</varname>.</para>

      <example id="ex-inheritance">
        <title>Héritage entre projets</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;groupId&gt;com.training.killerapp&lt;/groupId&gt;
    &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  ...
&lt;/project&gt;
</programlisting>
      </example>

      <para>L'exécution de la commande <command>mvn help:effective-pom</command> dans le <varname>project-a</varname> va
      afficher un <acronym>POM</acronym> qui est le résultat de la fusion du Super <acronym>POM</acronym> avec le
      <acronym>POM</acronym> du projet <varname>a-parent</varname> et celui du <varname>project-a</varname>. Les
      héritages implicites et explicites du <varname>project-a</varname> sont présentés dans <xref
      linkend="fig-inheritance" />. <figure id="fig-inheritance">
          <title>Héritage pour les projets <varname>a-parent</varname> et <varname>project-a</varname></title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/pom_inheritance.png" />
            </imageobject>

            <imageobject role="print">
              <imagedata align="center" fileref="figs/print/pom_inheritance.pdf" format="PDF" scalefit="0" width="100%" />
            </imageobject>
          </mediaobject>
        </figure>Quand un projet spécifie un projet parent, Maven utilise le <acronym>POM</acronym> de ce parent comme
      point de départ avant de traiter le <acronym>POM</acronym> du projet courant. Il hérite de tout, jusqu'au
      <varname>groupId</varname> et au numéro de <varname>version</varname>. Vous pouvez remarquer que le
      <varname>project-a</varname> ne spécifie aucun des deux, le <varname>groupId</varname> et la
      <varname>version</varname> sont tous les deux hérités du projet <varname>a-parent</varname>. Lorsqu'une balise
      parent est présente, tout ce qu'un <acronym>POM</acronym> a besoin de définir est l'<varname>artifactId</varname>.
      Cela n'est pas obligatoire, le <varname>project-a</varname> peut avoir un <varname>groupId</varname> et une
      <varname>version</varname> différents de ceux du parent, mais s'ils ne sont pas définis alors Maven utilisera ceux
      du <acronym>POM</acronym> parent. Si vous commencez à utiliser Maven pour gérer et construire de gros projets
      multimodules, vous aurez souvent à créer des projets qui auront un même <varname>groupId</varname> et une même
      <varname>version</varname>.</para>

      <para>Quand vous héritez d'un <acronym>POM</acronym>, vous avez le choix entre utiliser les valeurs héritées de ce
      <acronym>POM</acronym> ou les surcharger sélectivement. Ce qui suit est une liste d'éléments qu'un
      <acronym>POM</acronym> Maven hérite de son <acronym>POM</acronym> parent :</para>

      <itemizedlist>
        <listitem>
          <para>les identifiants (il faut au moins surcharger le <varname>groupId</varname> ou
          l'<varname>artifactId</varname>).</para>
        </listitem>

        <listitem>
          <para>les dépendances</para>
        </listitem>

        <listitem>
          <para>les développeurs et les contributeurs</para>
        </listitem>

        <listitem>
          <para>les listes de plugins</para>
        </listitem>

        <listitem>
          <para>les listes de rapports</para>
        </listitem>

        <listitem>
          <para>les exécutions de plugin (les exécutions qui ont le même id sont fusionnées)</para>
        </listitem>

        <listitem>
          <para>les configuration de plugin</para>
        </listitem>
      </itemizedlist>

      <para>Quand Maven hérite de dépendances, il va ajouter les dépendances définies dans les projets fils à celles des
      projets parents. C'est ainsi que vous pouvez spécifier des dépendances utilisées tout au long de projets qui
      héritent d'un même <acronym>POM</acronym> parent. Par exemple, si votre projet fait usage de Log4J pour ses
      traces, vous pouvez ajouter cette dépendance dans votre <acronym>POM</acronym> de plus haut niveau. Tous les
      projets qui hériteront de ce <acronym>POM</acronym> auront automatiquement Log4J comme dépendance. De même, si vous
      voulez vous assurer que tous vos projets utilisent la même version d'un plugin Maven, vous pouvez définir la
      version de ce plugin Maven dans la section <sgmltag>pluginManagement</sgmltag> d'un <acronym>POM</acronym> parent
      de haut niveau.</para>

      <para>Maven assume que le <acronym>POM</acronym> parent est disponible dans le dépôt local ou dans le répertoire
      parent (<filename>../pom.xml</filename>) du projet courant. Si aucune de ces options n'est valide, ce comportement
      par défaut peut être redéfini par la balise <sgmltag>relativePath</sgmltag>. Par exemple, certaines organisations
      préfèrent une structure à plat des projets où le fichier <filename>pom.xml</filename> du projet parent ne se
      trouve pas dans le répertoire parent d'un projet fils. Il peut se trouver dans un répertoire au même niveau que
      celui du projet. Si votre projet fils se trouve dans le répertoire <filename>./projet-a</filename> et que le
      projet parent se trouve dans <filename>./a-parent</filename>, vous préciserez dans le <acronym>POM</acronym> le
      chemin relatif du projet <varname>parent-a</varname> ainsi :</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
    &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;relativePath&gt;../a-parent/pom.xml&lt;/relativePath&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;projet-a&lt;/artifactId&gt;
&lt;/project&gt;</programlisting>
    </section>
  </section>

  <section id="pom-relationships-sect-pom-best-practice">
    <title>Les bonnes pratiques du POM</title>

    <para>Maven peut être utilisé pour tout gérer, depuis des systèmes composés d'un projet tout simple à des systèmes
    comprenant des dizaines de sous-modules liés les uns aux autres. Pour utiliser Maven, il ne suffit pas d'apprendre la
    syntaxe nécessaire à sa configuration, il faut apprendre le "Maven Way" (la "manière Maven"). Il s'agit d'un ensemble de bonnes
    pratiques pour organiser et construire des projets avec Maven. Cette section essaye d'en donner certains éléments
    pour vous éviter d'avoir à creuser dans les strates de fils de discussions des listes de diffusion de Maven qui se
    sont accumulées au cours des années.</para>

    <section id="pom-relationships-sect-grouping-deps">
      <title>Regrouper les dépendances</title>

      <para>Si vous avez un ensemble de dépendances qui sont logiquement liées les unes aux autres vous pouvez créer un
      projet de type <varname>pom</varname> qui va les regrouper. Par exemple, supposons que votre application utilise
      Hibernate, un célèbre framework de mapping Objet-Relationnel. Tout projet qui utilise Hibernate dépend aussi de
      Spring et du pilote <acronym>JDBC</acronym> pour MySQL. Au lieu d'avoir à déclarer ces dépendances dans chaque
      projet qui utilise Hibernate, Spring et MySQL vous pourriez créer un <acronym>POM</acronym> spécial qui ne fait
      rien d'autre que de déclarer un ensemble de dépendances communes. Vous pourriez ainsi créer un projet
      <varname>persistence-deps</varname> (un raccourci pour Dépendances de Persistance) et déclarer dans chaque projet
      qui nécessite une fonction de persistance, une dépendance à ce projet :</para>

      <para><example>
          <title>Consolidation des dépendances dans un projet POM</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;persistence-deps&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate&lt;/artifactId&gt;
      &lt;version&gt;\${hibernateVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
      &lt;version&gt;\${hibernateAnnotationsVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-hibernate3&lt;/artifactId&gt;
      &lt;version&gt;\${springVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
      &lt;version&gt;\${mysqlVersion}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;properties&gt;
    &lt;mysqlVersion&gt;(5.1,)&lt;/mysqlVersion&gt;
    &lt;springVersion&gt;(2.0.6,)&lt;/springVersion&gt;
    &lt;hibernateVersion&gt;3.2.5.ga&lt;/hibernateVersion&gt;
    &lt;hibernateAnnotationsVersion&gt;3.3.0.ga&lt;/hibernateAnnotationsVersion&gt;
  &lt;/properties&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>Si vous créez ce projet dans un répertoire <varname>persistence-deps</varname>, tout ce que vous avez à faire
      ensuite est d'écrire ce fichier <filename>pom.xml</filename> et d'exécuter la commande <command>mvn
      install</command>. Comme c'est un projet dont le packaging est de type <varname>pom</varname>, ce
      <acronym>POM</acronym> s'installe dans votre dépôt local. Vous pouvez maintenant ajouter ce projet comme
      dépendance de votre projet et toutes ses dépendances seront automatiquement ajoutées à votre projet. Quand vous
      ajoutez une dépendance vers ce projet <varname>persistence-deps</varname>, n'oubliez pas de spécifier qu'il s'agit
      d'une dépendance dont le packaging est de type <varname>pom</varname>.</para>

      <para><example>
          <title>Déclaration d'une dépendance vers un POM</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;description&gt;Ce projet nécessite JDBC&lt;/description&gt;
  ...
  &lt;dependencies&gt;
    ...
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
      &lt;artifactId&gt;persistence-deps&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>Si plus tard vous décidez de changer de pilote <acronym>JDBC</acronym> (en utilisant par exemple
      <acronym>JTDS</acronym>), vous n'avez qu'à remplacer les dépendances dans le projet
      <varname>persistence-deps</varname> pour utiliser
      <varname>net.</varname><varname>sourceforge.</varname><varname>jtds:</varname><varname>jtds</varname> au lieu de
      <varname>mysql:</varname><varname>mysql-java-connector</varname> puis mettre à jour le numéro de version. Tous les
      projets qui dépendent de <varname>persistence-deps</varname> utiliseront <acronym>JTDS</acronym> s'ils décident
      d'utiliser la nouvelle version. La consolidation des dépendances est une bonne pratique qui permet de réduire la
      taille des fichiers <filename>pom.xml</filename> qui ont un grand nombre de dépendances. Si vous devez
      partager un grand nombre de dépendances entre plusieurs projets, vous pouvez aussi établir des relations
      parent-enfant entre ceux-ci et extraire toutes les dépendances communes dans le projet parent. La limite de cette
      approche parent-enfant est qu'un projet peut n'avoir qu'un seul parent. Parfois, il est donc plus simple de
      regrouper ces dépendances et de référencer une dépendance de type <literal>pom</literal>. Ainsi, votre projet peut
      référencer autant de <acronym>POM</acronym> de dépendance selon ses besoins.</para>

      <note>
        <para>Maven utilise le niveau d'une dépendance dans l'arbre lorsqu'il résout un conflit, ne retenant que la
        dépendance la plus proche. Cette technique de regroupement de dépendances les fait descendre d'un niveau dans
        l'arbre. Ne l'oubliez pas lorsque vous devez choisir entre regrouper des dépendances dans un fichier 
        <filename>pom.xml</filename> ou utiliser la balise <sgmltag>dependencyManagement</sgmltag> dans un
        <acronym>POM</acronym> parent.</para>
      </note>
    </section>

    <section id="pom-relationships-sect-multi-vs-inherit">
      <title>Multimodule ou héritage</title>

      <para>Il existe une différence entre hériter d'un projet parent et<indexterm>
          <primary>multimodule projects, in general</primary>

          <secondary>inheritance versus</secondary>
        </indexterm><indexterm>
          <primary>project inheritance</primary>

          <secondary>choosing multimodule projects instead of</secondary>
        </indexterm><indexterm>
          <primary>inheritance between projects or modules</primary>

          <secondary>choosing multimodule projects instead of</secondary>
        </indexterm><indexterm>
          <primary>module inheritance</primary>

          <secondary>choosing multimodule projects instead of</secondary>
        </indexterm> être géré dans un projet multimodule. Un projet parent transfert sa configuration à ses enfants. Un
      projet multimodule gère un ensemble de sous-projets ou modules. Les relations dans un projet multimodule vont du
      haut vers le bas. Quand vous configurez un projet multimodule, vous indiquez tout simplement que votre build doit
      intégrer les modules spécifiés. Les builds multimodules servent à regrouper un ensemble de modules dans un même
      build. La relation parent-enfant va du noeud feuille vers le haut. La relation parent-enfant concerne plutôt la
      définition d'un projet particulier. Quand vous associez un projet fils à son parent, vous indiquez à Maven que le
      <acronym>POM</acronym> d'un projet dérive d'un autre.</para>

      <para>Pour illustrer la prise de décision entre une approche par héritage et une approche multimodule regardez les
      deux exemples qui vont suivre : le projet Maven utilisé pour produire ce livre et un projet hypothétique qui
      contient un ensemble logique de modules.</para>

      <section id="pom-relationships-sect-simple-project">
        <title>Projet simple</title>

        <para>Tout d'abord, jetons un oeil au projet maven-book. L'héritage et les relations multimodules sont
        présentées dans la <xref linkend="fig-maven-book" />.</para>

        <figure id="fig-maven-book">
          <title>Héritage dans le projet multimodule maven-book</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/pom_book-example.png" />
            </imageobject>

            <imageobject role="print">
              <imagedata align="center" fileref="figs/print/pom_book-example.pdf" format="PDF" scalefit="0" width="100%" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Quand nous construisons ce livre sur Maven que vous êtes en train de lire, nous exécutons la commande
        <command>mvn package</command> dans un projet multimodule qui s'appelle <varname>maven-book</varname>. Ce projet
        multimodule se compose de deux sous-modules : <varname>book-examples</varname> et
        <varname>book-chapters</varname>. Aucun de ces projets ne partage le même parent, ils ne sont liés que par le
        fait qu'ils sont tous les deux des modules du projet <varname>maven-book</varname>. Le projet
        <varname>book-examples</varname> construit les archives <acronym>ZIP</acronym> et <acronym>TGZ</acronym> que
        vous avez téléchargées pour obtenir les exemples de ce livre. Quand nous exécutons le build du projet
        <varname>book-examples</varname> depuis le répertoire <filename>book-examples/</filename> avec la commande
        <command>mvn package</command>, il ne sait pas qu'il n'est qu'une partie du projet
        <varname>maven-book</varname>. Le projet <varname>book-examples</varname> ne s'intéresse pas au projet
        <varname>maven-book</varname>, tout ce qu'il sait est que son parent est le <acronym>POM</acronym>
        <varname>sonatype</varname> de plus haut-niveau et qu'il construit une archive d'exemples. Dans ce cas, le
        projet <varname>maven-book</varname> existe uniquement comme facilitateur en regroupant des modules.</para>

        <para>Chacun de ces trois projets : <varname>maven-book</varname>, <varname>book-examples</varname> et
        <varname>book-chapters</varname> ont le même parent "d'entreprise" — <varname>sonatype</varname>. C'est une
        pratique courante dans les organisations qui ont adopté Maven. Au lieu d'avoir chaque projet qui étende le Super
        <acronym>POM</acronym> par défaut, certaines organisations définissent un <acronym>POM</acronym> d'entreprise
        de haut niveau qui sert de parent par défaut quand un projet n'a aucune raison d'en dépendre d'un autre.
        Dans ce livre, par exemple, il n'y a aucune raison pour que les projets <varname>book-examples</varname> et
        <varname>book-chapters</varname> partagent le même <acronym>POM</acronym> parent. Il s'agit de projets
        complètement différents avec leurs propres dépendances et configurations. Ils utilisent des plugins très
        différents pour construire ce que vous êtres en train de lire. Le <acronym>POM</acronym>
        <varname>sonatype</varname> permet à une organisation de personnaliser le comportement par défaut de Maven et de
        fournir des informations propres à l'organisation pour le déploiement et les profils.</para>
      </section>

      <section id="pom-relationships-sect-multi-module-enterprise">
        <title>Projet multimodule d'entreprise</title>

        <para>Regardons un exemple qui fournit une image plus précise de ce que pourrait être un véritable projet où
        l'héritage et les relations multimodules existent côte à côte. La <xref linkend="fig-multi-module" /> montre un
        ensemble de projets qui ressemblent à ceux que l'on pourrait rencontrer dans une véritable application
        d'entreprise. Il y a un <acronym>POM</acronym> de haut niveau pour l'entreprise avec un
        <varname>artifactId</varname> ayant pour valeur <varname>sonatype</varname>. Il y a ensuite un projet
        multimodule <varname>big-system</varname> qui référence les sous-modules <varname>server-side</varname> et
        <varname>client-side</varname>.</para>

        <figure id="fig-multi-module">
          <title>Héritage dans un projet multimodule d'entreprise</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/pom_real_multi.png" />
            </imageobject>

            <imageobject role="print">
              <imagedata align="center" fileref="figs/print/pom_real_multi.pdf" format="PDF" scalefit="0" width="100%" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>De quoi s'agit-il ? Essayons de donner un sens à toutes ces flèches. Tout d'abord, regardons
        <varname>big-system</varname>. Le projet <varname>big-system</varname> pourrait être le projet dans lequel vous
        exécuteriez la commande <command>mvn package</command> pour construire et tester le système dans son entier. Le
        projet <varname>big-system</varname> référence les sous-modules <varname>client-side</varname> et
        <varname>server-side</varname>. Chacun de ces projets regroupe le code qui s'exécute côté serveur et côté
        client. Concentrons-nous sur le projet <varname>server-side</varname>. Sous ce projet <varname>server-side</varname>
        se trouve un projet appelé <varname>server-lib</varname> et un projet multimodule <varname>web-apps</varname>.
        Sous <varname>web-apps</varname> nous retrouvons deux applications web Java : <varname>client-web</varname> et
        <varname>admin-web</varname>.</para>

        <para>Commençons par les relations parent/enfant de <varname>client-web</varname> et
        <varname>admin-web</varname> avec <varname>web-apps</varname>. Puisque ces deux applications web utilisent le
        même framework (Wicket par exemple), ces deux projets partagent un même ensemble de dépendances. Les dépendances
        vers l'<acronym>API</acronym> <acronym>Servlet</acronym>, l'<acronym>API</acronym> <acronym>JSP</acronym> et
        Wicket seraient toutes regroupées dans le projet <varname>web-apps</varname>. Ces deux
        projets <varname>client-web</varname> et <varname>admin-web</varname> doivent aussi dépendre de
        <varname>server-lib</varname>. Cette dépendance sera définie comme une dépendance de <varname>web-apps</varname>
        vers <varname>server-lib</varname>. Puisque <varname>client-web</varname> et <varname>admin-web</varname>
        partagent tous les deux cette configuration en héritant de <varname>web-apps</varname>, ces
        deux projets auront des <acronym>POM</acronym>s succincts contenant tout au plus les identifiants, le parent et
        le nom de l'artefact final.</para>

        <para>Maintenant, concentrons-nous sur la relation parent/enfant de <varname>web-apps</varname> et
        <varname>server-lib</varname> vers <varname>server-side</varname>. Dans ce cas-ci, supposons qu'il existe deux
        groupes de développeurs séparés, l'un qui travaille sur le code côté serveur et l'autre sur le code côté
        client. La liste des développeurs serait configurée dans le POM du projet <varname>server-side</varname> et
        héritée par ses projets fils : <varname>web-apps</varname>, <varname>server-lib</varname>,
        <varname>client-web</varname> et <varname>admin-web</varname>. Nous pourrions aussi imaginer que le projet
        <varname>server-side</varname> soit configuré différemment pour prendre en compte les spécificités du
        développement côté serveur. Le projet <varname>server-side</varname> pourrait utiliser un profil qui n'aurait
        de sens que pour tous les projets <varname>server-side</varname>. Ce profil pourrait contenir les informations
        de connexion à la base de données, ou le <acronym>POM</acronym> de ce projet <varname>server-side</varname>
        pourrait configurer une version spécifique du plugin Maven Jetty qui serait récupérée par tous les projets
        qui hériteraient du <acronym>POM</acronym> <varname>server-side</varname>.</para>

        <para>Dans cet exemple, la principale raison d'utiliser les relations parent/enfant est cet ensemble de
        dépendances partagées et la configuration commune à un groupe de projets qui sont liés logiquement. Tous les
        projets sous <varname>big-system</varname> sont liés les uns aux autres en tant que sous-modules, cependant tous
        les sous-modules ne sont pas obligés de déclarer comme parent le projet qui les a déclarés comme sous-module.
        Tout est sous-module pour des raisons de simplification, pour construire le système dans son ensemble allez dans
        le répertoire du projet <varname>big-system</varname> et exécutez la commande <command>mvn package</command>. Si
        vous regardez attentivement la figure vous noterez qu'il n'existe pas de relation parent/enfant entre les
        projets <varname>server-side</varname> et <varname>big-system</varname>. Pourquoi donc ? L'héritage de
        <acronym>POM</acronym> est très puissant, mais il ne doit pas être utilisé à tort et à travers. Quand le partage de
        dépendances et de configuration a du sens, il faut utiliser la relation parent/enfant. Mais elle n'a pas de sens
        lorsque les deux projets sont très différents. Ce qui est le cas, par exemple, des projets
        <varname>server-side</varname> et <varname>client-side</varname>. Il est tout à fait possible de concevoir un
        système où <varname>client-side</varname> et <varname>server-side</varname> héritent du <acronym>POM</acronym>
        commun de <varname>big-system</varname>. Cependant à chaque apparition d'une divergence significative entre ces
        deux projets il va falloir trouver des manières subtiles pour factoriser la configuration commune dans
        <varname>big-system</varname> sans perturber tous les projets fils. Même si <varname>client-side</varname> et
        <varname>server-side</varname> partagent la même dépendance à Log4J, ils peuvent avoir des configurations de
        plugins très différentes.</para>

        <para>Il existe un certain point, dont la position dépend de votre style et de votre expérience, au-delà duquel
        vous estimerez que la duplication de configuration est acceptable pour garder des projets comme
        <varname>client-side</varname> et <varname>server-side</varname> indépendants . Concevoir un système qui se
        compose de dizaines de projets sur plus de cinq niveaux d'héritage de POM n'est pas la meilleure idée qu'on
        puisse avoir. Dans une telle configuration, vous n'avez pas dupliqué votre dépendance à Log4J, mais vous devrez
        naviguer entre les cinq niveaux de POM pour comprendre comment Maven calcule votre POM effectif. Toute cette
        complexité pour éviter d'avoir à dupliquer cinq fois les quelques lignes d'une dépendance. Avec Maven, il y a
        toujours "une manière Maven de faire", mais il en existe bien d'autres. Au final, tout est question de
        préférences et de style. Dans la plupart des cas vous n'aurez pas de soucis si vos sous-modules déclarent le
        même projet comme parent, mais il se peut que votre utilisation de Maven évolue dans temps.</para>
      </section>
    </section>
  </section>
</chapter>