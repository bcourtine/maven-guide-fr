<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="pom-relationships" lang="fr">
  <title>Le Modèle Objet de Projet</title>

  <section id="pom-relationships-sect-intro">
    <title>Introduction</title>

    <para>Ce chapitre traite du concept central de Maven—le Modèle Objet de Projet<indexterm class="startofrange"
        id="pom1">
        <primary>POM (Project Object Model)</primary>
      </indexterm>. Le <acronym>POM</acronym> est l'endroit où l'identité et la structure d'un projet sont déclarées, où
    les builds sont configurés, et où sont définies les relations entre projets. L'existence d'un fichier <filename
    moreinfo="none">pom.xml</filename> définit un projet Maven.</para>
  </section>

  <section id="pom-relationships-sect-pom">
    <title>Le POM</title>

    <para>Les projets Maven, les dépendances, les builds, les artefacts : tous sont des objets qu'il a falloir modèliser
    et décrire. Ces objets sont décrits dans un fichier <acronym>XML</acronym> appelé Modèle Objet de Projet. Le
    <acronym>POM</acronym> indique à Maven de quel type de projet il va devoir traiter et comment il va devoir modifier
    son comportement par défaut pour produire le résultat attendu à partir des sources. Ainsi comme une application web
    Java avec son fichier <filename moreinfo="none">web.xml</filename> qui décrit, configure et personnalise
    l'application, un projet Maven se définit par la présence<indexterm>
        <primary>pom.xml file</primary>
      </indexterm><indexterm>
        <primary>pom.xml file</primary>

        <seealso>POM</seealso>
      </indexterm> d'un <filename moreinfo="none">pom.xml</filename>. Il s'agit d'une déclaration décriant un projet
    Maven; c'est un “plan” abstrait que Maven doit comprendre et suivre lorsqu'il va construirevotre projet.</para>

    <para>Vous pouvez aussi y voir une <filename moreinfo="none">pom.xml</filename> analogie à un fichier <filename
    moreinfo="none">Makefile</filename> ou un <filename moreinfo="none">build.xml</filename> pour Ant. Quand vous
    utilisez <acronym>GNU</acronym> <emphasis>make</emphasis> pour construire une application comme MySQL, vous aurez le
    plus souvent un fichier <filename moreinfo="none">Makefile</filename> qui conteint les instructions explicites pour
    construire un binaire à partir des sources. Quand vous utilisez Apache Ant, vous avez très probablement un fichier
    <filename moreinfo="none">build.xml</filename> qui contient les instructions explicites pour nettoyer, compiler,
    packager et déployer une application. <emphasis>make</emphasis>, Ant, et Maven ont en commun le fait qu'ils
    dépendent de la présence d'un fichier avec toujours le même nom qu'il s'agisse de <filename
    moreinfo="none">Makefile</filename>, <filename moreinfo="none">build.xml</filename>, ou <filename
    moreinfo="none">pom.xml</filename>, mais c'est là que les similarités s'arrêtent. Si vous regardez un <filename
    moreinfo="none">pom.xml</filename> Maven, la plus grande partie du <acronym>POM</acronym> se compose de
    descriptions. Où se trouve le code source? Où sont les ressources? Quel est le packaging? Si vous regardez un
    fichier <filename moreinfo="none">build.xml</filename> pour Ant, vous verrez quelquechose d'entièrement différent.
    Vous verrez des instructions explicites pour des tâches comme la compilation de classes Java. Le
    <acronym>POM</acronym> Maven est déclaratif, et bien que vous puissiez choisir d'y inclure des personnalisations
    procédurales via le plugin Maven Ant, dans l'ensemble vous n'aurez pas besoin de vous plonger dans les délicats
    détails procéduraux de la construction de votre projet.</para>

    <para>Le <acronym>POM</acronym> n'est pas sépcificque à la construction de projets Java. Même si la plupart des
    exemples de ce livre traitent d'applications Java, il n'y a rien de spécifique à Java dans la définition d'un Modèle
    Objet de Projet Maven. Si effectivementles plugins par défaut de Maven permettent de construiredes artéfacts sous
    forme de <acronym>JAR</acronym> à partir d'un ensemble de sources, de tests et de ressources, rien ne vous empêche
    de définir un <acronym>POM</acronym> pour un projet qui contient des sources C# et produit un binaire Microsoft
    propriétaire avec des outils Microsoft. De même, rien ne vous empêche d'utiliser un <acronym>POM</acronym> pour un
    livre technique. En effet, le source de ce livre et ses exemples sont répartis dans un projet Maven multi-module qui
    utilise l'un des nombreux plugins Maven pour Docbook pour appliquer un <acronym>XSL</acronym> standard Docbook à un
    ensemble de chapitres sous forme de fichiers <acronym>XML</acronym>. D'autres ont créé des plugins Maven pour
    transformer du code Adobe Flex en <acronym>SWC</acronym>s et <acronym>SWF</acronym>s, et enfin certains utilisent
    Maven pour contruire des projets écrits en C.</para>

    <para>Nous avons établi que le <acronym>POM</acronym> décrit et déclare,et qu'il se différencie de Ant ou de Make en
    ce qu'il de fournit pas d'instructions explicites,et nous avons vu que les concepts du <acronym>POM</acronym> ne
    sont pas propres à Java. Regardons plus en détails tout cela au travers de la <xref linkend="fig-pom" /> pour une
    analyse du contenu d'un <acronym>POM</acronym>.</para>

    <para><figure id="fig-pom">
        <title>Le Modèle Objet de Projet</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/pom-relationships_pom-small.png" />
          </imageobject>

          <imageobject role="print">
            <imagedata align="center" fileref="figs/print/pom-relationships_pom-small.pdf" format="PDF" scalefit="0"
                       width="100%" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>Le <acronym>POM</acronym> se compose de quatre types de descritpion et de configuration:</para>

    <variablelist>
      <varlistentry>
        <term>Informations générales sur le projet</term>

        <listitem>
          <para>Cett catégorie regroupe le nom du projet, l'<acronym>URL</acronym> du<indexterm>
              <primary>project information (in pom.xml)</primary>
            </indexterm><indexterm>
              <primary>licensing information (project information)</primary>
            </indexterm><indexterm>
              <primary>organizational information (project information)</primary>
            </indexterm><indexterm>
              <primary>developer information (project information)</primary>
            </indexterm><indexterm>
              <primary>pom.xml file</primary>

              <secondary>project information in</secondary>
            </indexterm> projet, l'organisation qui le produit, une liste de dvelopeurs et de contributeurs ainsi que sa
          license.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Configuration du Build</term>

        <listitem>
          <para>Dans cette section, nous personnalisons le comportement du build Maven<indexterm>
              <primary>build information (in pom.xml)</primary>
            </indexterm><indexterm>
              <primary>pom.xml file</primary>

              <secondary>build information in</secondary>
            </indexterm> par défaut. Nous pouvons changer l'endroit où se trouvent les sources et les tests, ajouter de
          nouveaux plugins, lier des goals de plugins au cycle de vien et nous pouvons personnaliser les paramètres pour
          la génération du site web.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Environnement du Build</term>

        <listitem>
          <para>L'environnement du build consiste en un ensemble de profils qui peuvent être<indexterm>
              <primary>build environment</primary>
            </indexterm><indexterm>
              <primary>pom.xml file</primary>

              <secondary>build environment</secondary>
            </indexterm> activés pour être utilisés dans différents environnements. Par exemple, au cours du
          développement vous pouvez vouloir déployer sur un serveur de développement, alors qu'en production vous allez
          vouloir déployer sur un serveur différent. L'environnement de build personnalise la configuration du build
          pour un environnement spécifique et il s'accompagne souvent d'un fichier<indexterm>
              <primary>settings.xml file</primary>
            </indexterm> <filename moreinfo="none">settings.xml personnalisé</filename> dans <filename
          moreinfo="none">~/.m2</filename>. Ce fichier settings.xml est détaillé dans le <xref linkend="profiles" /> et
          dans la section <xref linkend="appendix-settings-sect-details" />.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Relations entre POM</term>

        <listitem>
          <para>Un projet est rarement isolé,; il dépend souvent d'autres projets, hérite d'une configuration de
          <acronym>POM</acronym> de projets parent, définit ses propres coordonnées, et peut inclure des
          sous-modules.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <section id="pom-relationships-sect-super-pom">
      <title>Le Super POM</title>

      <para>Avant de se plonger dans des exemples de <acronym>POM</acronym>s, jettons un rapide coup d'œil au Super
      <acronym>POM</acronym>. Tous les <acronym>POM</acronym>s de projet Maven étendent le Super <acronym>POM</acronym>
      qui définit un ensemble de valeurs par défaut partagé par tous les projets. Ce Super <acronym>POM</acronym> fait
      partie de l'installation de Maven, et se trouve dans le fichier
      <filename>maven-${maven.version}-uber.jar</filename> dans le répertoire <filename>\${M2_HOME}/lib</filename>. Si
      vous regardez ce fichier <acronym>JAR</acronym>, vous y trouverez un fichier <filename>pom-4.0.0.xml</filename>
      dans le package <package>org.apache.maven.project </package>. Le Super <acronym>POM</acronym> de Maven est
      présenté dans l'<xref linkend="ex-super-pom" />.</para>

      <example id="ex-super-pom">
        <title>Le Super POM</title>

        <programlisting>&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;name&gt;Maven Default Project&lt;/name&gt;

  &lt;repositories&gt;
    &lt;repository&gt;
      &lt;id&gt;central&lt;/id&gt;  <co id="coDef-super-1" linkends="coRef-super-1" />      &lt;name&gt;Maven Repository Switchboard&lt;/name&gt;
      &lt;layout&gt;default&lt;/layout&gt;
      &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt;
      &lt;snapshots&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;/snapshots&gt;
    &lt;/repository&gt;
  &lt;/repositories&gt;

  &lt;pluginRepositories&gt;
    &lt;pluginRepository&gt;
      &lt;id&gt;central&lt;/id&gt;   <co id="coDef-super-2" linkends="coRef-super-2" />      &lt;name&gt;Maven Plugin Repository&lt;/name&gt;
      &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt;
      &lt;layout&gt;default&lt;/layout&gt;
      &lt;snapshots&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;/snapshots&gt;
      &lt;releases&gt;
        &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;
      &lt;/releases&gt;
    &lt;/pluginRepository&gt;
  &lt;/pluginRepositories&gt;

  &lt;build&gt;  <co id="coDef-super-3" linkends="coRef-super-3" />    &lt;directory&gt;target&lt;/directory&gt;
    &lt;outputDirectory&gt;target/classes&lt;/outputDirectory&gt;
    &lt;finalName&gt;\${pom.artifactId}-\${pom.version}&lt;/finalName&gt;
    &lt;testOutputDirectory&gt;target/test-classes&lt;/testOutputDirectory&gt;
    &lt;sourceDirectory&gt;src/main/java&lt;/sourceDirectory&gt;
    &lt;scriptSourceDirectory&gt;src/main/scripts&lt;/scriptSourceDirectory&gt;
    &lt;testSourceDirectory&gt;src/test/java&lt;/testSourceDirectory&gt;
    &lt;resources&gt;
      &lt;resource&gt;
        &lt;directory&gt;src/main/resources&lt;/directory&gt;
      &lt;/resource&gt;
    &lt;/resources&gt;
    &lt;testResources&gt;
      &lt;testResource&gt;
        &lt;directory&gt;src/test/resources&lt;/directory&gt;
      &lt;/testResource&gt;
    &lt;/testResources&gt;
  &lt;/build&gt; <co id="coDef-super-4" linkends="coRef-super-4" />     &lt;pluginManagement&gt;
       &lt;plugins&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;
           &lt;version&gt;1.1&lt;/version&gt;
         &lt;/plugin&gt;       
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2-beta-1&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.3&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-ear-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.3.1&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-ejb-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.1&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.4&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-plugin-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.3&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-rar-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;                
           &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0-beta-7&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;                
           &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0-beta-6&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0.4&lt;/version&gt;
         &lt;/plugin&gt;         
         &lt;plugin&gt;
            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.4.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.1-alpha-1&lt;/version&gt;
         &lt;/plugin&gt;
       &lt;/plugins&gt;
     &lt;/pluginManagement&gt;
  
  &lt;reporting&gt;
    &lt;outputDirectory&gt;target/site&lt;/outputDirectory&gt;
  &lt;/reporting&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>Le Super <acronym>POM</acronym> définit des variables de configuration standards qui seront héritées par
      tous les projets. Les valeurs de ces variables sont définies dans les sections numérotées :</para>

      <calloutlist>
        <callout arearefs="coDef-super-1" id="coRef-super-1">
          <para>Le Super <acronym>POM</acronym> par défaut déclare un unique dépôt Maven distant ayant pour ID
          <literal>central</literal>. C'est ce dépôt central de Maven qui est configuré par défaut dans toutes les
          installations de Maven pour être interrogé. Cette configuration peut être surchargée par un fichier <filename
          moreinfo="none">settings.xml</filename> personnalisé. Attention, le Super <acronym>POM</acronym> par défaut a
          désactivé la récupération des artefacts snapshots depuis le dépôt central de Maven. Si vous avez besoin d'un
          dépôt snapshot, vous devrez configurer vos dépôts dans votre <filename moreinfo="none">pom.xml</filename> ou
          votre <filename moreinfo="none">settings.xml</filename>. Le fichier <filename>settings.xml</filename> et les
          profils sont traités dans le <xref linkend="profiles" /> ainsi que dans <xref
          linkend="appendix-settings-sect-details" />.</para>
        </callout>

        <callout arearefs="coDef-super-2" id="coRef-super-2">
          <para>Le dépôt central de Maven contient aussi des plugins Maven. Le dépôt de plugins est par défaut le dépôt
          central de Maven. La récupération des snapshots est désactivée par défaut et la règle de gestion des mises à
          jour indique "never", ce qui signifie que Maven ne met jamais automatiquement à jour un plugin si une nouvelle
          version est publiée.</para>
        </callout>

        <callout arearefs="coDef-super-3" id="coRef-super-3">
          <para>L'élément <sgmltag>build</sgmltag> définit les positions par défaut des répertoires selon la Disposition
          Maven Standard des Répertoires.</para>
        </callout>

        <callout arearefs="coDef-super-4" id="coRef-super-4">
          <para>Depuis la version 2.0.9 de Maven, les versions par défaut des plugins du cœursont définies dans le Super
          <acronym>POM</acronym>. Cela a été mis en place pour apporter une certaine stabilité aux utilisateurs qui ne
          précisent pas de version dans leurs <acronym>POM</acronym>s.</para>
        </callout>
      </calloutlist>

      <figure id="fig-super-always-base">
        <title>Le Super POM est toujours le parent racine</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/pom-relationships_pom-inherit-simple-super.png" />
          </imageobject>

          <imageobject role="print">
            <imagedata align="center" fileref="figs/print/pom-relationships_pom-inherit-simple-super.pdf" format="PDF"
                       scalefit="0" width="100%" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section id="pom-relationships-sect-simplest-pom">
      <title>Le POM le plus simple possible</title>

      <para>Tous les <acronym>POM</acronym>s Maven héritent leurs valeurs par défaut du Super <acronym>POM</acronym>
      (dont nous avons parlé dans la section <xref linkend="pom-relationships-sect-super-pom" />). Si vous écrivez un
      projet tout simple qui produit un <acronym>JAR</acronym> à partir de fichiers source se trouvant dans <filename
      moreinfo="none">src/main/java</filename>, que vous voulez exécutez des tests JUnit qui sont dans <filename
      moreinfo="none">src/test/java</filename>, et que vous voulez produire le site web de ce projet avec la commande
      <command moreinfo="none">mvn site</command>, vous n'avez rien à configurer. Vous n'avez besoin, dans ce cas, que
      du <acronym>POM</acronym> le plus simple possible, tel celui présenté dans <xref linkend="ex-simplest-pom" />. Ce
      <acronym>POM</acronym> définit un <varname>groupId</varname>, un <varname>artifactId</varname>, et une
      <varname>version</varname> : les trois coordonnées exigées pour tout projet.</para>

      <example id="ex-simplest-pom">
        <title>Le POM le plus simple possible</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.ch08&lt;/groupId&gt;
  &lt;artifactId&gt;simplest-project&lt;/artifactId&gt;
  &lt;version&gt;1&lt;/version&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>Un <acronym>POM</acronym> aussi simple serait plus qu'adéquat pour un projet très simple—par exempleg., une
      bibliothèque Java qui produirait un fichier <acronym>JAR</acronym>. Ce <acronym>POM</acronym> ne fait aucune
      référence à un autre projet, ne dépend de rien, et il lui manque des informations basiques comme un nom et une
      <acronym>URL</acronym>. Si vous créiez un tel fichier et un sous-répertoire <filename
      moreinfo="none">src/main/java</filename> contenant du code source, l'exécution de la commande <command
      moreinfo="none">mvn package</command> produirait un <acronym>JAR</acronym> dans <filename
      moreinfo="none">target/simple-project-1.jar</filename>.</para>
    </section>

    <section id="pom-relationships-sect-effective-pom">
      <title>Le POM effectif</title>

      <para>Ce <acronym>POM</acronym>, le plus simple qu'il soit, introduit le concept de <indexterm>
          <primary>effective POMs</primary>
        </indexterm> “<acronym>POM</acronym> effectif”. Comme les <acronym>POM</acronym>s héritent leur configuration
      d'autres <acronym>POM</acronym>s, vous devez toujours voir un <acronym>POM</acronym> Maven comme la combinaison du
      Super <acronym>POM</acronym>, plus tous les <acronym>POM</acronym>s parent intermédiaires, et enfin le
      <acronym>POM</acronym> du projet en cours. Maven commence par le Super <acronym>POM</acronym> et surcharge la
      configuration par défaut avec un ou plusieurs <acronym>POM</acronym>s parent. Puis il surcharge la configuration
      résultante avec les velurs du <acronym>POM</acronym> du projet. Au final, vous obtenez un <acronym>POM</acronym>
      effectif qui est le résultat du mélange de plusieurs <acronym>POM</acronym>s. Si vous voulez voir le
      <acronym>POM</acronym> effectif d'un projet, vous allez devoir exécuter le goal <varname>effective-pom</varname>
      du plugin Maven Help, dont nous avons parlé précédemment dans la section <xref
      linkend="installation-sect-help-plugin-install" />. Pour lancer le goal <varname>effective-pom</varname>, exécutez
      la commade suivante dans un répertoire contenant un fichier <filename moreinfo="none">pom.xml</filename> :</para>

      <screen>$ <command>mvn help:effective-pom</command></screen>

      <para>L'exécution du goal <varname>effective-pom</varname> devrait afficher un document <acronym>XML</acronym>
      résultant de la fusion du Super <acronym>POM</acronym> et du <acronym>POM</acronym> de <xref
      linkend="ex-simplest-pom" />.</para>
    </section>

    <section id="pom-relationships-sect-real-poms">
      <title>Véritables POMs</title>

      <para>Plutôt que de taper un ensemble de <acronym>POM</acronym>s convenus <indexterm>
          <primary>real POMs</primary>
        </indexterm> pour vous guider pas-à-pas, vous pouvez regarder les exemples fournis dans <xref
      linkend="part-example" />. Maven est un véritable caméléon ; vous pouvez choisir et prendre ce dont vous voulez
      profiter. Certains projets libres peuvent accorder de l'importance à la possibilité de lister les développeurs et
      les contributeurs, de pouvoir produire une documentation claire pour un projet, et de pouvoir gérer
      automatiquement les livraisons grâce au plugin Maven Release. D'un autre côté, pour quelqu'un qui travaille dans
      le contexte d'une petite équipe dans une entreprise, les capacités de Maven pour gérer les distributions ou lister
      les développeurs puvent avoir un intérêt moindre. La suite de ce chapitre va traiter les caractéristiques du
      <acronym>POM</acronym> en lui même. Au lieu de vous bombarder avec un listing de 10 pages contenant tout un
      ensemble de <acronym>POM</acronym>s , nous allons nous concentrer sur la création d'une bonne référence pour
      chacune des sections spécifiques du<acronym>POM</acronym>. Dans ce chapitre, nous allons parler des relations
      entre les <acronym>POM</acronym>s, mais nous n'allons pas illustrer cela par un projet exemple. Si vous rechercher
      un tel exemple vous le trouverez dans le <xref linkend="multimodule-web-spring" />.</para>
    </section>
  </section>

  <section id="pom-relationships-sect-pom-syntax">
    <title>Syntaxe de POM</title>

    <para>Le <acronym>POM</acronym> se trouve toujours <indexterm class="startofrange" id="pom2">
        <primary>POM (Project Object Model)</primary>

        <secondary>syntax</secondary>
      </indexterm>dans un fichier <filename moreinfo="none">pom.xml</filename> dans le répertoire racine d'un projet
    Maven. Ce document <acronym>XML</acronym> peut commencer par la déclaration <acronym>XML</acronym>, mais elle n'est
    pas obligatoire. Toutes les valeurs dans un <acronym>POM</acronym> se présentent sous la forme d'éléments
    <acronym>XML</acronym>.</para>

    <section id="pom-reationships-sect-versions">
      <title>Les versions d'un projet</title>

      <para>La balise <sgmltag>version</sgmltag> d'un projet Maven contient le numéro de<indexterm>
          <primary>major versions (projects)</primary>
        </indexterm><indexterm>
          <primary>minor versions (projects)</primary>
        </indexterm><indexterm>
          <primary>incremental versions (projects)</primary>
        </indexterm><indexterm>
          <primary>qualifiers for project versions</primary>
        </indexterm><indexterm>
          <primary>project versions, about</primary>

          <seealso>version attribute</seealso>
        </indexterm><indexterm>
          <primary>version attribute (pom.xml)</primary>
        </indexterm><indexterm>
          <primary>project versions, about</primary>
        </indexterm> version stable qui est utilisé pour regrouper et rdonner les distributions. Les versions dans Maven
      se décomposent ainsi : version majeure, version mineure, version incrémentale et qualifieur. Dans un numéro de
      version ces ifférents éléments se présentent selon le format suivant :</para>

      <screen>&lt;version majeure&gt;.&lt;version mineure&gt;.&lt;version incrémentale&gt;-&lt;qualifieur&gt;
</screen>

      <para>Par exemple, la version "1.3.5" correspond à la version majeure 1, de version mineure 3, et de version
      incrémentale 5. La version "5" correspond à la version majeure 5 sans version mineure ou incrémentale. Le
      qualifieur est utilisé pour les builds des étapes intermédiaires : distributions alpha ou beta, et il est séparé
      des autres éléments de version par un tiret. Par exemple, la version "1.3-beta-01" a une version majeure de 1, un
      version mineure de 3, et un qualifieur "beta-01".</para>

      <para>Suivre ces précaunisations pour les numéros de version prend tout son lorsque vous commencez à utiliser des
      intervalles pour vos versions dans les <acronym>POM</acronym>s. Les intervalles de versions, dont on parle dans la
      <xref linkend="pom-relationships-sect-version-ranges" />, vous permettent de spécifier une dépendence dont la
      version est comprise dans cet intervalle. Cela n'es possible que parce que Maven est capable de trier les versions
      en se basant sur le format de numéro de version dont nous venons de parler.</para>

      <para>Si votre numéro de version respecte le format
      <varname>&lt;majeure&gt;.</varname><varname>&lt;mineure&gt;.</varname><varname>&lt;incrémentale&gt;-&lt;qualifieur&gt;</varname>
      alors vos versions seront ordonnées correctement, "1.2.3" sera donc bien considérée comme plus récente que
      "1.0.2". La comparaison se fera en utilisant les valeurs numériques des versions majeure, mineure et incrémentale.
      Si votre numéro de version ne respecte pas ce standard, alors vos versions seront comparées comme des chaînes de
      caractères ; la chaîne "1.0.1b" sera comparée à la chaîne "1.2.0b".</para>

      <section id="pom-relationships-sect-version-build-numbers">
        <title>Numéro de version de build</title>

        <para>Un des problèmes avec les numéros de version est l'ordonnancement des<indexterm>
            <primary>ordering of version qualifiers</primary>
          </indexterm><indexterm>
            <primary>qualifiers for project versions</primary>

            <secondary>ordering of</secondary>
          </indexterm> qualifieurs. Prenez, par exemple, les numéros de version “1.2.3-alpha-2” et “1.2.3-alpha-10,” ou
        “<phrase role="keep-together">alpha-2</phrase>” correspond au second build alpha, et “alpha-10” au dixième build
        alpha. Même si “alpha-10” devrait être considéré comme plus récent que “alpha-2,” Maven va mettre “alpha-10”
        avant “alpha-2”. Ceci est du à un problème connu dans la façon dont Maven traite les numéros de version.</para>

        <para>Maven doit en théorie considèrer le nombre après le qualifieur comme le numéro du build. En d'autres
        termes, le qualifieur devrait être "alpha", et le numéro du build 2. Même si Maven a été conçu pour séparer le
        numéro du build du qualifieur, cette fonctionnalité ne fonctionne pas actuellement. En conséquence, "alpha-2" et
        "alpha-10" sont comparés en tant que chaînes, et donc "alpha-10" arrive avant "alpha-2" alphabétiquement. Pour
        contourner cette limitation, vous devez compléter à gauche vos numéros de version de build qualifiés. Si vous
        utilisez "alpha-02" et "alpha-10" vous n'aurez plus ce problème, et tout contniuera à bien onctionner le jour où
        Maven traitera correctement les numéros de version de build.</para>
      </section>

      <section id="pom-relationships-sect-snapshot-versions">
        <title>Les version SNAPSHOT</title>

        <para>Les numéros de versions dans Maven peuvent contenir une chaîne de caractères pour indiquer que le
        <indexterm>
            <primary>snapshot versions</primary>
          </indexterm>projet est en cours de développement. Si une version contient la chaîne “SNAPSHOT”, alors Maven va
        prendre en compte cette clef et la convertir en une valeur de type date et heure au format
        <acronym>UTC</acronym> (Coordinated Universal Time) quand vous installez ou publiez ce composant. Par exemple,
        si votre projet est en version “1.0-SNAPSHOT” et que vous déployez ses artefacts sur un dépôt Maven, Maven va
        alors convertir cette version en “1.0-20080207-230803-1” si vous réaliser votre déploiement le 7 Février 2008 à
        23:08 <acronym>UTC</acronym>. En d'autres mots, quand vous déployer un snapshot, vous ne livrez pas un composant
        logiciel ; vous livrez une photo d'un composant à un instant donné.</para>

        <para>Pourquoi utiliser cette fontionnalité ? Les versions SNAPSHOT sont utilisées pour les projets en cours de
        développement. Si votre projet dépend d'un composant logiciel en cours de développement, vous pouvez dépendre
        d'une version SNAPSHOT, Maven essayera alors de télécharger périodiquement la dernière version snapshot du dépôt
        lorsque vous lancerez votre build. De la même manière, si la prochaine livraison de votre système sera en
        version "1.4", tant que votre projet n'est pas livré définitivement il devrait être en version
        "1.4-SNAPSHOT".</para>

        <para>Par défaut, Maven ne va pas vérifier la présence de versions SNAPSHOT sur les dépôts distants, pour
        pouvoir dépendre de versions SNAPSHOT les utilisateurs doivent donc activer explicitement le téléchargement des
        snapshots au travers des balises XML <sgmltag>repository</sgmltag> ou <sgmltag>pluginRepository</sgmltag> dans
        le <acronym>POM</acronym>.</para>

        <para>Lorsque vous livrez un projet vos devriez remplacer toutes vos dépendances sur des versions SNAPSHOT par
        des dépendances vers des versions de projets livrés. Si un projet dépend d'un SNAPSHOT, il n'est pas stable car
        ses dépendances peuvent évoluer dans le temps. Les artefcts publiés sur les dépôts Maven stables comme <ulink
        url="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</ulink> ne peuvent pas dépendre de versions
        SNAPSHOT, le Super <acronym>POM</acronym> de Maven désactive la publication de snapshots sur le dépôt Central.
        Les versions SNAPSHOT sont utilisées uiquement pour le développement.</para>
      </section>

      <section id="pom-relationships-sect-latest-release">
        <title>Les versions LATEST et RELEASE</title>

        <para>Quand vous dépendez d'un plugin ou d'une bibliothèque, vous pouvez utiliser LATEST ou RELEASE comme
        numéroe de version. LATEST indique que la version correspond à la dernière version déployée d'un artefact sur un
        dépôt particulier, qu'il s'agisse d'une version stable ou d'une version snapshot. RELEASE indique la dernière
        version stable déployée sur le dépôt. En général, dépendre d'une version explicitée d'un artefact n'est pas une
        bonne pratique. Si vous êtes en train de développer un logiciel, vous pouvez être amené à utiliser RELEASE ou
        LATEST comme une facilité pour ne pas à mettre à jour les numéros de version lorsqu'une bibliothèque tierce est
        déployée. Quand vous livrer un logiciel, vous devriez toujours vous assurer que votre projet dépend de versions
        spéciques pour limiter l'impact sur votre build d'un déploiement d'artefacts hors de votre controle. Utilisez
        donc LATEST et RELEASE prudemment, voire pas du tout.</para>

        <para>Depuis la version 2.0.9 de Maven, les numéros de version des plugins qui constituent le cœur de Maven sont
        fixés dans le super POM pour lier un ensemble des principaux plugins de Maven à une version de Maven. Ce
        changement a été introduit à partir de la version 2.0.9 de Maven pour apporter de la stabilité et de la
        reproductibilité aux builds Maven. Avant Maven 2.0.9, Maven mettait automatiqument à jour les principaux plugins
        en utilisant la version LATEST. Ce comportement apportait son lot de surprises quand des bugs apparaissaient
        dans les plugin du cœur ou que leurs fonctionnement avaient changé ce qui faisait échouer le build. Quand Maven
        mettait automatiquement à jour ses plugins principaux, il n'y avait aucune garantie que les builds soient
        reproductibles puisque des plugins pouvaient avoir changé suite àau déploiement d'une nouvelle version sur le
        dépôt centrel. Depuis Maven 2.0.9, Maven, essentially, est livré avec des versions fixes des principaux plugins.
        Les plugins qui ne constituent pas le cœur de Maven ou dont le numéro de version n'est pas défini dans le Super
        POM, seront considérés comme utilisant la version LATEST lors de la récupération de leurs artefacts depuis le
        dépôt. C'est pour cette raison que vous devriez explicitement définir les numéros de version pour tous les
        plugins de votre build, qu'ils vous soient propres ou qu'ils ne fassent pas partie des principaux plugins de
        Maven.</para>
      </section>
    </section>

    <section id="pom-relationships-sect-property-refs">
      <title>Référence à une propriété</title>

      <para>Un <acronym>POM</acronym> peut contenir des références à des propriétés<indexterm>
          <primary>properties</primary>

          <secondary>referencing in pom.xml</secondary>
        </indexterm><indexterm>
          <primary>references to properties, in pom.xml</primary>
        </indexterm>, elles sont précédées par le signe dollar et entourées par des accolades. Par exemple, regardons le
      <acronym>POM</acronym> suivant :</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;build&gt;
    &lt;finalName&gt;\${project.groupId}-\${project.artifactId}&lt;/finalName&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>

      <para>Si vous écrivez ce <acronym>XML</acronym> dans un <filename>pom.xml</filename> et que vous exécutiez la
      commande <command>mvn help:effective-pom</command>, vous verrez le message suivant sur la sortie standard :</para>

      <programlisting language="xml">...
&lt;finalName&gt;org.sonatype.mavenbook-project-a&lt;/finalName&gt;
...</programlisting>

      <para>Quand Maven lit un <acronym>POM</acronym>, il remplace les références à des propriétés lorsqu'il charge le
      <acronym>XML</acronym> du <acronym>POM</acronym> . On rencontre fréquemment des propriétés dans un usage avancé de
      Maven. Ces propriétés sont similaires à celles que l'on trouve dans d'autres systèmes comme Ant ou Velocity. Il
      s'agit tout simplement de variabls délimitées par <varname>\${...</varname><varname>}</varname>. Maven fournit
      trois variables implicites qui peuvent être utilisées pour accéder aux variables d'environnement, aux informations
      du<acronym>POM</acronym>, and Maven Settings:</para>

      <variablelist>
        <varlistentry>
          <term>env</term>

          <listitem>
            <para>The <varname>env</varname> variable exposes environment <indexterm>
                <primary>env variable</primary>
              </indexterm><indexterm>
                <primary>implicit variables, list of</primary>
              </indexterm>variables exposed by your operating system or shell. For example, a reference to
            <varname>\${env.</varname><varname>PATH}</varname> in a Maven <acronym>POM</acronym> would be replaced by
            the <varname>\${PATH}</varname> environment variable (or <varname>%PATH%</varname> in Windows).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>project</term>

          <listitem>
            <para>The <varname>project</varname> variable exposes the<indexterm>
                <primary>project variable</primary>
              </indexterm> <acronym>POM</acronym>. You can use a dot-notated (.) path to reference the value of a
            <acronym>POM</acronym> element. For example, in this section we used the <varname>groupId</varname> and
            <varname>artifactId</varname> to set the <sgmltag>finalName</sgmltag> element in the build configuration.
            The syntax for this property reference was:
            <code>\${project.groupId}-\${project.</code><code>artifactId}</code>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>settings</term>

          <listitem>
            <para>The <varname>settings</varname> variable exposes Maven <indexterm>
                <primary>settings variable</primary>
              </indexterm>settings information. You can use a dot-notated (.) path to reference the value of an element
            in a <filename moreinfo="none">settings.xml</filename> file. For example,
            <varname>\${settings.offline}</varname> would reference the value of the <sgmltag>offline</sgmltag> element
            in <filename moreinfo="none">~/.m2/settings.xml</filename>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <note>
        <para>You may see older builds that use <varname>\${pom.xxx}</varname> or just <varname>\${xxx}</varname> to
        reference <acronym>POM</acronym> properties. These methods have been deprecated and only
        <varname>\${project.xxx}</varname> should be used.</para>
      </note>

      <para>In addition to the three implicit variables, you can reference <indexterm>
          <primary>system properties, referencing</primary>
        </indexterm>system properties and any custom properties set in the Maven <acronym>POM</acronym> or in a build
      profile:</para>

      <variablelist>
        <varlistentry>
          <term>Java System Properties</term>

          <listitem>
            <para>All properties accessible via<indexterm>
                <primary>Java system properties, referencing</primary>
              </indexterm> <methodname>getProperties() </methodname>on
            <classname>java.lang.</classname><classname>System</classname> are exposed as <acronym>POM</acronym>
            properties. Some examples of system properties are: <varname>\${user.name}</varname>, <varname
            role="keep-together">\${user.home}</varname>, <varname>\${java.home}</varname>, and
            <varname>\${os.name}</varname>. A full list of system properties can be found in the Javadoc for the
            <classname>java.lang.</classname><classname>System</classname> class.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>x</term>

          <listitem>
            <para>Arbitrary properties can be set with a<indexterm>
                <primary>arbitrary properties, referencing</primary>
              </indexterm> <varname>properties</varname> element in a <filename moreinfo="none">pom.xml</filename> or
            <filename moreinfo="none" role="keep-together">settings.xml</filename>, or properties can be loaded from
            external files. If you set a property named <varname>fooBar</varname> in your <filename
            moreinfo="none">pom.xml</filename>, that same property is referenced with <varname>\${fooBar}</varname>.
            Custom properties come in handy when you are building a system that filters resources and targets different
            deployment platforms. Here is the syntax for setting <literal>\${foo}=bar</literal> in a
            <acronym>POM</acronym>:</para>

            <programlisting language="xml">&lt;properties&gt;
  &lt;foo&gt;bar&lt;/foo&gt;
&lt;/properties&gt;</programlisting>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>For a more comprehensive list of available properties, see <xref linkend="resource-filtering" />.</para>
    </section>
  </section>

  <section id="pom-relationships-sect-project-dependencies">
    <title>Project Dependencies</title>

    <para>Maven can manage both internal and external dependencies. An<indexterm class="startofrange" id="pom3a">
        <primary>dependencies</primary>
      </indexterm><indexterm>
        <primary>POM (Project Object Model)</primary>

        <secondary>project dependencies</secondary>

        <see>dependencies</see>
      </indexterm><indexterm>
        <primary>project dependencies</primary>

        <see>dependencies</see>
      </indexterm><indexterm>
        <primary>external dependencies</primary>
      </indexterm><indexterm>
        <primary>internal dependencies</primary>

        <seealso>dependencies</seealso>
      </indexterm><indexterm>
        <primary>internal dependencies</primary>

        <seealso>dependencies</seealso>
      </indexterm> external dependency for a Java project might be a library such as Plexus, the Spring Framework, or
    Log4J. An internal dependency is illustrated by a web application project depending on another project that contains
    service classes, model objects, or persistence logic. <xref linkend="ex-dependency" /> shows some examples of
    project dependencies.</para>

    <para><example id="ex-dependency">
        <title>Project Dependencies</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.codehaus.xfire&lt;/groupId&gt;
      &lt;artifactId&gt;xfire-java5&lt;/artifactId&gt;
      &lt;version&gt;1.2.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
      &lt;version&gt;2.4&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  ...
&lt;/project&gt;
</programlisting>
      </example></para>

    <para>The first dependency is a compile dependency on the XFire <acronym>SOAP</acronym> library from Codehaus. You
    would use this type of dependency if your project depended on this library for compilation, testing, and during
    execution. The second dependency is a <literal>test</literal>-scoped dependency on JUnit. You would use a
    <literal>test</literal>-scoped dependency when you need to reference this library only during testing. The last
    dependency in <xref linkend="ex-dependency" /> is a dependency on the Servlet 2.4 <acronym>API</acronym>. The last
    dependency is scoped as a provided dependency. You would use a provided scope when the application you are
    developing needs a library for compilation and testing, but this library is supplied by a container at
    runtime.</para>

    <section id="pom-relationships-sect-dependency-scope">
      <title>Dependency Scope</title>

      <para><xref linkend="ex-dependency" /> briefly introduced three of the <indexterm>
          <primary>scope, dependency</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>scope of</secondary>
        </indexterm>five dependency scopes: <literal>compile</literal>, <literal>test</literal>, and
      <literal>provided</literal>. Scope controls which dependencies are available in which classpath, and which
      dependencies are included with an application. Let’s explore each scope in detail:</para>

      <variablelist>
        <varlistentry>
          <term>compile</term>

          <listitem>
            <para><literal>compile</literal> is the default scope; all dependencies are <indexterm>
                <primary>compile dependencies</primary>
              </indexterm><literal>compile</literal>-scoped if a scope is not supplied. <literal>compile</literal>
            dependencies are available in all classpaths, and they are packaged.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>provided</term>

          <listitem>
            <para><literal>provided</literal> dependencies are used when you expect the <acronym>JDK</acronym> or a
            container to provide them. For <indexterm>
                <primary>provided dependencies</primary>
              </indexterm>example, if you were developing a web application, you would need the Servlet
            <acronym>API</acronym> available on the compile classpath to compile a servlet, but you wouldn’t want to
            include the Servlet <acronym>API</acronym> in the packaged <acronym>WAR</acronym>; the Servlet
            <acronym>API</acronym> <acronym>JAR</acronym> is supplied by your application server or servlet container.
            <literal>provided</literal> dependencies are available on the compilation classpath (not runtime). They are
            not transitive, nor are they packaged.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>runtime</term>

          <listitem>
            <para><literal>runtime</literal> dependencies are required to execute and test the <indexterm>
                <primary>runtime dependencies</primary>
              </indexterm>system, but they are not required for compilation. For example, you may need a
            <acronym>JDBC</acronym> <acronym>API</acronym> <acronym>JAR</acronym> at compile time and the
            <acronym>JDBC</acronym> driver implementation only at runtime.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>test</term>

          <listitem>
            <para><literal>test</literal>-scoped dependencies are not required during the normal<indexterm>
                <primary>dependencies</primary>

                <secondary>test-scoped</secondary>
              </indexterm><indexterm>
                <primary>test-scoped dependencies</primary>
              </indexterm><indexterm>
                <primary>unit tests</primary>

                <secondary>test-scoped dependencies</secondary>
              </indexterm><indexterm>
                <primary>testing</primary>

                <secondary>using test-scoped dependencies</secondary>
              </indexterm> operation of an application, and they are available only during test compilation and
            execution phases. The <literal>test</literal> scope was previously introduced in <xref
            linkend="customizing-sect-test-scope" />.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>system</term>

          <listitem>
            <para>The <literal>system</literal> scope is similar to <literal>provided</literal> except that you have to
            <indexterm>
                <primary>system-scope dependencies</primary>
              </indexterm>provide an explicit path to the <acronym>JAR</acronym> on the local file system. This is
            intended to allow compilation against native objects that may be part of the system libraries. The artifact
            is assumed to always be available and is not looked up in a repository. If you declare the scope to be
            <literal>system</literal>, you must also provide the <sgmltag>systemPath</sgmltag> element. Note that this
            scope is not recommended (you should always try to reference dependencies in a public or custom Maven
            repository).</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section id="pom-relationships-sect-optional">
      <title>Optional Dependencies</title>

      <para>Assume that you are working on a library that provides caching <indexterm>
          <primary>optional dependencies</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>optional</secondary>
        </indexterm>behavior. Instead of writing a caching system from scratch, you want to use some of the existing
      libraries that provide caching on the file system and distributed caches. Also assume that you want to give the
      end user an option to cache on the file system or to use an in-memory distributed cache. To cache on the file
      system, you’ll want to use a freely available library called EHCache (<ulink
      url="http://ehcache.sourceforge.net/">http://ehcache.sourceforge.net/</ulink>), and to cache in a distributed
      <phrase role="keep-together">in-memory</phrase> cache, you want to use another freely available caching library
      named SwarmCache (<ulink url="http://swarmcache.sourceforge.net/">http://swarmcache.sourceforge.net/</ulink>).
      You’ll code an interface and create a library that can be configured to use either EHCache or SwarmCache, but you
      want to avoid adding a dependency on both caching libraries to any project that depends on your library.</para>

      <para>In other words, you need both libraries to compile this library project, but you don't want both libraries
      to show up as transitive runtime dependencies for the project that uses your library. You can accomplish this by
      using optional dependencies as shown in <xref linkend="ex-optional-depend" />.</para>

      <example id="ex-optional-depend">
        <title>Declaring Optional Dependencies</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;my-project&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
      &lt;artifactId&gt;ehcache&lt;/artifactId&gt;
      &lt;version&gt;1.4.1&lt;/version&gt;
      &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;swarmcache&lt;/groupId&gt;
      &lt;artifactId&gt;swarmcache&lt;/artifactId&gt;
      &lt;version&gt;1.0RC2&lt;/version&gt;
      &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j&lt;/artifactId&gt;
      &lt;version&gt;1.2.13&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>Once you've declared these dependencies as optional, you are required to include them explicitly in the
      project that depends on <varname>my-project</varname>. For example, if you were writing an application which
      depended on <varname>my-project</varname> and wanted to use the EHCache implementation, you would need to add the
      following <sgmltag>dependency</sgmltag> element to your project.</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;my-application&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
      &lt;artifactId&gt;my-project&lt;/artifactId&gt;
      &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
      &lt;artifactId&gt;swarmcache&lt;/artifactId&gt;
      &lt;version&gt;1.4.1&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>

      <para>In an ideal world, you wouldn’t have to use optional dependencies. Instead of having one large project with
      a series of optional dependencies, you would separate the <phrase role="keep-together">EHCache-specific</phrase>
      code to a <varname>my-project-ehcache</varname> submodule and the SwarmCache-specific code to a
      <varname>my-project-swarmcache</varname> submodule. This way, instead of requiring projects that reference
      <varname>my-project</varname> to specifically add a dependency, projects can just reference a particular
      implementation project and benefit from the transitive dependency.</para>
    </section>

    <section id="pom-relationships-sect-version-ranges">
      <title>Dependency Version Ranges</title>

      <para>You don’t just have to depend on a specific version of a<indexterm>
          <primary>version attribute (pom.xml)</primary>

          <secondary>dependency version ranges</secondary>
        </indexterm><indexterm>
          <primary>project versions, about</primary>

          <secondary>dependency version ranges</secondary>
        </indexterm><indexterm>
          <primary>ranges for dependency versions</primary>
        </indexterm> dependency; you can specify a range of versions that would satisfy a given dependency. For example,
      you can specify that your project depends on version 3.8 or greater of JUnit, or anything between versions 1.2.10
      and 1.2.14 of JUnit. You do this by surrounding one or more version numbers with the following characters:</para>

      <variablelist>
        <varlistentry>
          <term role="plain">(, )</term>

          <listitem>
            <para>Exclusive quantifiers</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term role="plain">[, ]</term>

          <listitem>
            <para>Inclusive quantifiers</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>For example, if you wished to access any <code>JUnit </code>version greater than or equal to 3.8 but less
      than 4.0, your dependency would be as shown in <xref linkend="ex-dep-range" />.</para>

      <para><example id="ex-dep-range">
          <title>Specifying a Dependency Range: JUnit 3.8 - JUnit 4.0</title>

          <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;junit&lt;/groupId&gt;
  &lt;artifactId&gt;junit&lt;/artifactId&gt;
  &lt;version&gt;[3.8,4.0)&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</programlisting>
        </example></para>

      <para>If you want to depend on any version of JUnit no higher than<indexterm>
          <primary>upper boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>inclusive boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>lower boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>exclusive boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>boundaries for version ranges, specifying</primary>
        </indexterm> 3.8.1, you would specify only an upper inclusive boundary, as shown in <xref
      linkend="ex-dep-range-2" />.</para>

      <example id="ex-dep-range-2">
        <title>Specifying a Dependency Range: JUnit &lt;= 3.8.1</title>

        <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;junit&lt;/groupId&gt;
  &lt;artifactId&gt;junit&lt;/artifactId&gt;
  &lt;version&gt;[,3.8.1]&lt;/version&gt;ex-de
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</programlisting>
      </example>

      <para>A version before or after the comma is not required, and means +/- infinity. For example, "[4.0,)" means any
      version greater than or equal to 4.0. "(,2.0)" is any version less than 2.0. "[1.2]" means only version 1.2, and
      nothing else.</para>

      <note>
        <para>When declaring a "normal" version such as 3.8.2 for Junit, internally this is represented as "allow
        anything, but prefer 3.8.2." This means that when a conflict is detected, Maven is allowed to use the conflict
        algorithms to choose the best version. If you specify [3.8.2], it means that only 3.8.2 will be used and nothing
        else. If somewhere else there is a dependency that specifies [3.8.1], you would get a build failure telling you
        of the conflict. We point this out to make you aware of the option, but use it sparingly and only when really
        needed. The preferred way to resolve this is via <sgmltag>dependencyManagement</sgmltag>.</para>
      </note>
    </section>

    <section id="pom-relationships-sect-transitive">
      <title>Transitive Dependencies</title>

      <para>A transitive dependency is a dependency of a dependency. If<indexterm>
          <primary>transitive dependencies</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>transitive</secondary>

          <see>transitive dependencies</see>
        </indexterm> <varname>project-a</varname> depends on <varname>project-b</varname>, which in turn depends on
      <varname>project-c</varname>, then <varname>project-c</varname> is considered a transitive dependency of
      <varname>project-a</varname>. If <varname>project-c</varname> depended on <varname>project-d</varname>, then
      <varname>project-d</varname> would also be considered a transitive dependency of <varname>project-a</varname>.
      Part of Maven’s appeal is that it can manage transitive dependencies and shield the developer from having to keep
      track of all of the dependencies required to compile and run an application. You can just depend on something like
      the Spring Framework and not have to worry about tracking down every last dependency of the Spring
      Framework.</para>

      <para>Maven accomplishes this by building a graph of dependencies and dealing with any conflicts and overlaps that
      might occur. For example, if Maven sees that two projects depend on the same <varname>groupId</varname> and
      <varname>artifactId</varname>, it will sort out which dependency to use automatically, always favoring the more
      recent version of a dependency. Although this sounds convenient, there are some edge cases where transitive
      dependencies can cause some configuration issues. For these scenarios, you can use a dependency exclusion.</para>

      <section id="pom-relationships-sect-transitive-scope">
        <title>Transitive Dependencies and Scope</title>

        <para>Each of the scopes outlined earlier in the section <xref
        linkend="pom-relationships-sect-dependency-scope" /> affects not just the scope of <indexterm>
            <primary>scope, dependency</primary>

            <secondary>transitive dependencies and</secondary>
          </indexterm>the dependency in the declaring project, but also how it acts as a transitive dependency. The
        easiest way to convey this information is through a table, as in <xref
        linkend="table-transitive-dep-and-scope" />. Scopes in the top row represent the scope of a transitive
        dependency. Scopes in the leftmost column represent the scope of a direct dependency. The intersection of the
        row and column is the scope that is assigned to a transitive dependency. A blank cell in this table means that
        the transitive dependency will be omitted.</para>

        <para><table id="table-transitive-dep-and-scope">
            <title>How Scope Affects Transitive Dependencies</title>

            <tgroup cols="5">
              <thead>
                <row>
                  <entry>Direct Scope</entry>

                  <entry>Transitive Scope</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry></entry>

                  <entry><emphasis>compile</emphasis></entry>

                  <entry><emphasis>provided</emphasis></entry>

                  <entry><emphasis>runtime</emphasis></entry>

                  <entry><emphasis>test</emphasis></entry>
                </row>

                <row>
                  <entry><emphasis>compile</emphasis></entry>

                  <entry>compile</entry>

                  <entry>-</entry>

                  <entry>runtime</entry>

                  <entry>-</entry>
                </row>

                <row>
                  <entry><emphasis>provided</emphasis></entry>

                  <entry>provided</entry>

                  <entry>provided</entry>

                  <entry>provided</entry>

                  <entry>-</entry>
                </row>

                <row>
                  <entry><emphasis>runtime</emphasis></entry>

                  <entry>runtime</entry>

                  <entry>-</entry>

                  <entry>runtime</entry>

                  <entry>-</entry>
                </row>

                <row>
                  <entry><emphasis>test</emphasis></entry>

                  <entry>test</entry>

                  <entry>-</entry>

                  <entry>test</entry>

                  <entry>-</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>

        <para>To illustrate the relationship of transitive dependency scope to direct dependency scope, consider the
        following example. If <varname>project-a</varname> contains a test scoped dependency on
        <varname>project-b</varname> which contains a compile scoped dependency on <varname>project-c</varname>.
        <varname>project-c</varname> would be a test-scoped transitive dependency of
        <varname>project-a</varname>.</para>

        <para>You can think of this as a transitive boundary which acts as a filter on dependency scope. Transitive
        dependencies which are provided and test scope usually do not affect a project. The exception to this rule is
        that a provided scoped transitive dependency to a provided scope direct dependency is still a provided
        dependency of a project. Transitive dependencies which are compile and runtime scoped usually affect a project
        regardless of the scope of a direct dependency. Transitive dependencies which are compile scoped will have the
        same scope regardless of the scope of the direct dependency. Transitive dependencies which are runtime scoped
        will generally have the same scope of the direct dependency except when the direct dependency has a scope of
        compile. When a transitive dependency is runtime scoped and a direct is compile scoped the direct dependency the
        transitive dependency will have an effective scope of runtime.</para>
      </section>
    </section>

    <section id="pom-relationships-sect-conflict">
      <title>Conflict Resolution</title>

      <para>There will be times when you need to exclude a transitive<indexterm>
          <primary>conflict, dependency</primary>
        </indexterm><indexterm>
          <primary>resolving dependency conflicts</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>conflicts with, resolving</secondary>
        </indexterm><indexterm>
          <primary>transitive dependencies</primary>

          <secondary>resolving conflicts with</secondary>
        </indexterm><indexterm>
          <primary>excluding transitive dependencies</primary>
        </indexterm><indexterm>
          <primary>replacing transitive dependencies</primary>
        </indexterm> dependency, such as when you are depending on a project that depends on another project, but you
      would like to either exclude the dependency altogether or replace the transitive dependency with another
      dependency that provides the same functionality. <xref linkend="ex-exclude" /> shows an example of a dependency
      element that adds a dependency on <varname>project-a</varname>, but excludes the transitive dependency
      <varname>project-b</varname>.</para>

      <para><example id="ex-exclude">
          <title>Excluding a Transitive Dependency</title>

          <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;exclusions&gt;
    &lt;exclusion&gt;
      &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
      &lt;artifactId&gt;project-b&lt;/artifactId&gt;
    &lt;/exclusion&gt;
  &lt;/exclusions&gt;
&lt;/dependency&gt;</programlisting>
        </example></para>

      <para>Often, you will want to replace a transitive dependency with another implementation. For example, if you are
      depending on a library that depends on the Sun <acronym>JTA</acronym> <acronym>API</acronym>, you may want to
      replace the declared transitive dependency. Hibernate is one example. Hibernate depends on the Sun
      <acronym>JTA</acronym> <acronym>API</acronym> <acronym>JAR</acronym>, which is not available in the central Maven
      repository because it cannot be freely redistributed. Fortunately, the Apache Geronimo project has created an
      independent implementation of this library that can be freely redistributed. To replace a transitive dependency
      with another dependency, you would exclude the transitive dependency and declare a dependency on the project you
      wanted instead. <xref linkend="ex-exclude-replace" /> shows an example of a such replacement.</para>

      <example id="ex-exclude-replace">
        <title>Excluding and Replacing a Transitive Dependency</title>

        <programlisting language="xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate&lt;/artifactId&gt;
    &lt;version&gt;3.2.5.ga&lt;/version&gt;
    &lt;exclusions&gt;
      &lt;exclusion&gt;
        &lt;groupId&gt;javax.transaction&lt;/groupId&gt;
        &lt;artifactId&gt;jta&lt;/artifactId&gt;
      &lt;/exclusion&gt;
    &lt;/exclusions&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;
    &lt;artifactId&gt;geronimo-jta_1.1_spec&lt;/artifactId&gt;
    &lt;version&gt;1.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting>
      </example>

      <para>In <xref linkend="ex-exclude-replace" />, there is nothing marking the dependency on
      <varname>geronimo-jta_1.1_spec</varname> as a replacement, it just happens to be a library which provides the same
      <acronym>API</acronym> as the original <acronym>JTA</acronym> dependency. Here are some other reasons you might
      want to exclude or replace transitive dependencies:</para>

      <orderedlist>
        <listitem>
          <para>The <varname>groupId</varname> or <varname>artifactId</varname> of the artifact has changed, where the
          current project requires an alternately named version from a dependency's version - resulting in 2 copies of
          the same project in the classpath. Normally Maven would capture this conflict and use a single version of the
          project, but when <varname>groupId</varname> or <varname>artifactId</varname> are different, Maven will
          consider this to be two different libraries.</para>
        </listitem>

        <listitem>
          <para>An artifact is not used in your project and the transitive dependency has not been marked as an optional
          dependency. In this case, you might want to exclude a dependency because it isn't something your system needs
          and you are trying to cut down on the number of libraries distributed with an application.</para>
        </listitem>

        <listitem>
          <para>An artifact which is provided by your runtime container thus should not be included with your build. An
          example of this is if a dependency depends on something like the Servlet API and you want to make sure that
          the dependency is not included in a web application's <filename>WEB-INF/lib</filename> directory.</para>
        </listitem>

        <listitem>
          <para>To exclude a dependency which might be an <acronym>API</acronym> with multiple implementations. This is
          the situation illustrated by <xref linkend="ex-exclude-replace" />; there is a Sun <acronym>API</acronym>
          which requires click-wrap licensing and a time-consuming manual install into a custom repository (Sun's
          <acronym>JTA</acronym> <acronym>JAR</acronym>) versus a freely distributed version of the same
          <acronym>API</acronym> available in the central Maven repository (Geronimo's <acronym>JTA</acronym>
          implementation).</para>
        </listitem>
      </orderedlist>
    </section>

    <section id="pom-relationships-sect-dep-manage">
      <title>Dependency Management</title>

      <para>Once you've adopted Maven at your super complex enterprise and you have two hundred and twenty inter-related
      Maven projects, you are going to start wondering if there is a better way to get a handle on dependency versions.
      If every single project that uses a dependency like the MySQL Java connector needs to independently list the
      version number of the dependency, you are going to run into problems when you need to upgrade to a new version.
      Because the version numbers are distributed throughout your project tree, you are going to have to manually edit
      each of the <filename>pom.xml</filename> files that reference a dependency to make sure that you are changing the
      version number everywhere. Even with <command>find</command>, <command>xargs</command>, and
      <command>awk</command>, you are still running the risk of missing a single <acronym>POM</acronym>.</para>

      <para>Luckily, Maven provides a way for you to consolidate dependency version numbers in the
      <sgmltag>dependencyManagement</sgmltag> element. You'll usually see the <sgmltag>dependencyManagement</sgmltag>
      element in a top-level parent <acronym>POM</acronym> for an organization or project. Using the
      <sgmltag>dependencyManagement</sgmltag> element in a <filename>pom.xml</filename> allows you to reference a
      dependency in a child project without having to explicitly list the version. Maven will walk up the parent-child
      hierarchy until it finds a project with a <sgmltag>dependencyManagement</sgmltag> element, it will then use the
      version specified in this <sgmltag>dependencyManagement</sgmltag> element.</para>

      <para>For example, if you have a large set of projects which make use of the MySQL Java connector version 5.1.2,
      you could define the following <sgmltag>dependencyManagement</sgmltag> element in your multi-module project's
      top-level <acronym>POM</acronym>.</para>

      <para><example>
          <title>Defining Dependency Versions in a Top-level POM</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  ...
  &lt;dependencyManagement&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.2&lt;/version&gt;
      &lt;/dependency&gt;
      ...
    &lt;dependencies&gt;
  &lt;/dependencyManagement&gt;
</programlisting>

          <para>Then, in a child project, you can add a dependency to the MySQL Java Connector using the following
          dependency <acronym>XML</acronym>:</para>

          <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
    &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>

          <para>You should notice that the child project did not have to explicitly list the version of the
          <varname>mysql-connector-java</varname> dependency. Because this dependency was defined in the top-level
          <acronym>POM</acronym>'s <sgmltag>dependencyManagement</sgmltag> element, the version number is going to
          propagate to the child project's dependency on <varname>mysql-connector-java</varname>. Note that if this
          child project did define a version, it would override the version listed in the top-level
          <acronym>POM</acronym>'s <sgmltag>dependencyManagement</sgmltag> section. That is, the
          <sgmltag>dependencyManagement</sgmltag> version is only used when the child does not declare a version
          directly.</para>

          <para>Dependency management in a top-level <acronym>POM</acronym> is different from just defining a dependency
          on a widely shared parent <acronym>POM</acronym>. For starters, all dependencies are inherited. If
          <varname>mysql-connector-java</varname> were listed as a dependency of the top-level parent project, every
          single project in the hierarchy would have a reference to this dependency. Instead of adding in unnecessary
          dependencies, using <sgmltag>dependencyManagement</sgmltag> allows you to consolidate and centralize the
          management of dependency versions without adding dependencies which are inherited by all children. In other
          words, the <sgmltag>dependencyManagement</sgmltag> element is equivalent to an environment variable which
          allows you to declare a dependency anywhere below a project without specifying a version number.</para>
        </example></para>
    </section>
  </section>

  <section id="pom-relationships-sect-project-relationships">
    <title>Project Relationships</title>

    <para>One of the compelling reasons to use Maven is that it makes the process of tracking down dependencies (and
    dependencies of dependencies) very easy. When a project depends on an artifact produced by another project we say
    that this artifact is a dependency. In the case of a Java project, this can be as simple as a project depending on
    an external dependency like Log4J or JUnit. While dependencies can model external dependencies, they can also manage
    the dependencies between a set of related projects, if <varname>project-a</varname> depends on
    <varname>project-b</varname>, Maven is smart enough to know that <varname>project-b</varname> must be built before
    <varname>project-a</varname>.</para>

    <para>Relationships are not only about dependencies and figuring out what one project needs to be able to build an
    artifact. Maven can model the relationship of a project to a parent, and the relationship of a project to
    submodules. This section gives an overview of the various relationships between projects and how such relationships
    are configured.</para>

    <section id="pom-relationships-sect-more-coordinates">
      <title>More on Coordinates</title>

      <para>Coordinates define a unique location for a project, they were first introduced in <xref
      linkend="simple-project" />. Projects are related to one another using Maven Coordinates. project-a doesn't just
      depend on project-b; a project with a groupId, artifactId, and version depends on another project with a groupId,
      artifactId, and version. To review, a Maven Coordinate is made up of three components:</para>

      <variablelist>
        <varlistentry>
          <term>groupId</term>

          <listitem>
            <para>A <varname>groupId</varname> groups a set of related artifacts. Group identifiers generally resemble a
            Java package name. For example, the <varname>groupId</varname>
            <varname>org.</varname><varname>apache.maven</varname> is the base groupId for all artifacts produced by the
            Apache Maven project. Group identifiers are translated into paths in the Maven Repository; for example, the
            org.apache.maven groupId can be found in <filename>/maven2/org/apache/maven</filename> on <ulink
            url="http://repo1.maven.org/maven2/org/apache/maven">repo1.maven.org</ulink>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>artifactId</term>

          <listitem>
            <para>The <varname>artifactId</varname> is the project's main identifier. When you generate an artifact,
            this artifact is going to be named with the <varname>artifactId</varname>. When you refer to a project, you
            are going to refer to it using the <varname>artifactId</varname>. The <varname>artifactId</varname>,
            <varname>groupId</varname> combination must be unique. In other words, you can't have two separate projects
            with the same <varname>artifactId</varname> and <varname>groupId</varname>; <varname>artifactId</varname>s
            are unique within a particular <varname>groupId</varname>.</para>

            <note>
              <para>While '.'s are commonly used in <varname>groupId</varname>s, you should try to avoid using them in
              <varname>artifactId</varname>s. This can cause issues when trying to parse a fully qualified name down
              into the subcomponents.</para>
            </note>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>version</term>

          <listitem>
            <para>When an artifact is released, it is released with a version number. This version number is a numeric
            identifier such as "1.0", "1.1.1", or "1.1.2-alpha-01". You can also use what is known as a snapshot
            version. A snapshot version is a version for a component which is under development, snapshot version
            numbers always end in SNAPSHOT; for example, "1.0-SNAPSHOT", "1.1.1-SNAPSHOT", and "1-SNAPSHOT". <xref
            linkend="pom-relationships-sect-version-build-numbers" /> introduces versions and version ranges.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>There is a fourth, less-used qualifier:</para>

      <variablelist>
        <varlistentry>
          <term>classifier</term>

          <listitem>
            <para>You would use a classifier if you were releasing the same code but needed to produce two separate
            artifacts for technical reasons. For example, if you wanted to build two separate artifacts of a
            <acronym>JAR</acronym>, one compiled with the Java 1.4 compiler and another compiled with the Java 6
            compiler, you might use the classifier to produce two separate <acronym>JAR</acronym> artifacts under the
            same groupId:artifactId:version combination. If your project uses native extensions, you might use the
            classifier to produce an artifact for each target platform. Classifiers are commonly used to package up an
            artifact's sources, JavaDocs or binary assemblies.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>When we talk of dependencies in this book, we often use the following shorthand notation to describe a
      dependency: <varname>groupId</varname>:<varname>artifactId</varname>:<varname>version</varname>. To refer to the
      2.5 release of the Spring Framework, we would refer to it as
      <varname>org.</varname><varname>springframework:</varname><varname>spring:</varname><varname>2.5</varname>. When
      you ask Maven to print out a list of dependencies with the Maven Dependency plugin, you will also see that Maven
      tends to print out log messages with this shorthand dependency notation.</para>
    </section>

    <section id="pom-relationships-sect-multi-module">
      <title>Multi-module Projects</title>

      <para>Multi-module projects are projects which contain a list of modules to build. A multi-module project always
      has a packaging of pom, and rarely produces an artifact. A multi-module project exists only to group projects
      together in a build. <xref linkend="fig-multiproject" /> shows a project hierarchy which includes two parent
      projects with packaging of <varname>pom</varname>, and three projects with packaging of
      <varname>jar</varname>.</para>

      <para><figure id="fig-multiproject">
          <title>Multi-module Project Relationships</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/pom_multimodule.png" />
            </imageobject>

            <imageobject role="print">
              <imagedata align="center" fileref="figs/print/pom_multimodule.pdf" format="PDF" scalefit="0" width="100%" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>The directory structure on the file system would also mirror the module relationships. A set of projects
      illustrated by <xref linkend="fig-multiproject" /> would have the following directory structure:</para>

      <programlisting>top-parent-project/pom.xml
top-parent-project/subparent-parent-project/pom.xml
top-parent-project/subparent-parent-project/project-a/pom.xml
top-parent-project/subparent-parent-project/project-b/pom.xml
top-parent-project/project-c/pom.xml</programlisting>

      <para>The projects are related to one another because <varname>top-parent-project</varname> and
      <varname>subparent-parent-project</varname> are referencing <varname>sub-modules</varname> in a
      <acronym>POM</acronym>. For example, the
      <varname>org.sonatype.mavenbook:</varname><varname>top-parent-project</varname> project is a multi-module project
      with packaging of type <varname>pom</varname>. <varname>top-parent-project</varname>'s
      <filename>pom.xml</filename> would include the following modules element:</para>

      <example>
        <title>top-parent-project modules element</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;top-parent-project&lt;/artifactId&gt;
  ...
  &lt;modules&gt;
    &lt;module&gt;subparent-parent-project&lt;/module&gt;
    &lt;module&gt;project-c&lt;/module&gt;
  &lt;/modules&gt;
  ...
&lt;/project&gt;</programlisting>
      </example>

      <para>When Maven is reading <varname>top-parent-project</varname> <acronym>POM</acronym> it will look at the
      modules element and see that <varname>top-parent-project</varname> references the projects
      <varname>subparent-parent-project</varname> and <varname>project-c</varname>. Maven will then look for a
      <filename>pom.xml</filename> in each of these subdirectories. Maven repeats this process for each of the
      submodules: it will read the <filename>subparent-parent-project/pom.xml</filename> and see that the
      <varname>subparent-parent-project</varname> project references two projects with the following modules
      element:</para>

      <example>
        <title>subparent-parent-project modules element</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;modules&gt;
    &lt;module&gt;project-a&lt;/module&gt;
    &lt;module&gt;project-b&lt;/module&gt;
  &lt;/modules&gt;
  ...
&lt;/project&gt;</programlisting>
      </example>

      <para>Note that we call the projects under the multi-module projects "modules" and not "children" or "child
      projects". This is purposeful, so as not to confuse projects grouped by multi-module projects with projects that
      inherit <acronym>POM</acronym> information from each other.</para>
    </section>

    <section id="pom-relationships-sect-project-inheritance">
      <title>Project Inheritance</title>

      <para>There are going to be times when you want a project to inherit values from a parent POM. You might be
      building a large system, and you don't want to have to repeat the same dependency elements over and over again.
      You can avoid repeating yourself if your projects make use of inheritance via the parent element. When a project
      specifies a parent, it inherits the information in the parent project's POM. It can then override and add to the
      values specified in this parent POM.</para>

      <para>All Maven <acronym>POM</acronym>s inherit values from a parent <acronym>POM</acronym>. If a
      <acronym>POM</acronym> does not specify a direct parent using the <sgmltag>parent</sgmltag> element, that
      <acronym>POM</acronym> will inherit values from the Super <acronym>POM</acronym>. <xref
      linkend="ex-inheritance" /> shows the <sgmltag>parent</sgmltag> element of <varname>project-a</varname> which
      inherits the <acronym>POM</acronym> defined by the <varname>a-parent</varname> project.</para>

      <example id="ex-inheritance">
        <title>Project Inheritance</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;groupId&gt;com.training.killerapp&lt;/groupId&gt;
    &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  ...
&lt;/project&gt;
</programlisting>
      </example>

      <para>Running <command>mvn help:effective-pom</command> in <varname>project-a</varname> would show a
      <acronym>POM</acronym> that is the result of merging the Super <acronym>POM</acronym> with the
      <acronym>POM</acronym> defined by <varname>a-parent</varname> and the <acronym>POM</acronym> defined in
      <varname>project-a</varname>. The implicit and explicit inheritance relationships for <varname>project-a</varname>
      are shown in <xref linkend="fig-inheritance" />. <figure id="fig-inheritance">
          <title>Project Inheritance for a-parent and project-a</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/pom_inheritance.png" />
            </imageobject>

            <imageobject role="print">
              <imagedata align="center" fileref="figs/print/pom_inheritance.pdf" format="PDF" scalefit="0" width="100%" />
            </imageobject>
          </mediaobject>
        </figure>When a project specifies a parent project, Maven uses that parent <acronym>POM</acronym> as a starting
      point before it reads the current project's <acronym>POM</acronym>. It inherits everything, including the
      <varname>groupId</varname> and <varname>version</varname> number. You'll notice that <varname>project-a</varname>
      does not specify either, both <varname>groupId</varname> and <varname>version</varname> are inherited from
      <varname>a-parent</varname>. With a parent element, all a <acronym>POM</acronym> really needs to define is an
      <varname>artifactId</varname>. This isn't mandatory, <varname>project-a</varname> could have a different
      <varname>groupId</varname> and <varname>version</varname>, but by not providing values, Maven will use the values
      specified in the parent <acronym>POM</acronym>. If you start using Maven to manage and build large multi-module
      projects, you will often be creating many projects which share a common <varname>groupId</varname> and
      <varname>version</varname>.</para>

      <para>When you inherit a <acronym>POM</acronym>, you can choose to live with the inherited <acronym>POM</acronym>
      information or to selectively override it. The following is a list of items a Maven <acronym>POM</acronym>
      inherits from its parent <acronym>POM</acronym>:</para>

      <itemizedlist>
        <listitem>
          <para>identifiers (at least one of <varname>groupId</varname> or <varname>artifactId</varname> must be
          overridden.)</para>
        </listitem>

        <listitem>
          <para>dependencies</para>
        </listitem>

        <listitem>
          <para>developers and contributors</para>
        </listitem>

        <listitem>
          <para>plugin lists</para>
        </listitem>

        <listitem>
          <para>reports lists</para>
        </listitem>

        <listitem>
          <para>plugin executions (executions with matching ids are merged)</para>
        </listitem>

        <listitem>
          <para>plugin configuration</para>
        </listitem>
      </itemizedlist>

      <para>When Maven inherits dependencies, it will add dependencies of child projects to the dependencies defined in
      parent projects. You can use this feature of Maven to specify widely used dependencies across all projects which
      inherit from a top-level <acronym>POM</acronym>. For example, if your system makes universal use of the Log4J
      logging framework, you can list this dependency in your top-level <acronym>POM</acronym>. Any projects which
      inherit <acronym>POM</acronym> information from this project will automatically have Log4J as a dependency.
      Similarly, if you need to make sure that every project is using the same version of a Maven plugin, you can list
      this Maven plugin version explicitly in a top-level parent <acronym>POM</acronym>'s
      <sgmltag>pluginManagement</sgmltag> section.</para>

      <para>Maven assumes that the parent <acronym>POM</acronym> is available from the local repository, or available in
      the parent directory (<filename>../pom.xml</filename>) of the current project. If neither location is valid this
      default behavior may be overridden via the <sgmltag>relativePath</sgmltag> element. For example, some
      organizations prefer a flat project structure where a parent project's <filename>pom.xml</filename> isn't in the
      parent directory of a child project. It might be in a sibling directory to the project. If your child project were
      in a directory <filename>./project-a</filename> and the parent project were in a directory named
      <filename>./a-parent</filename>, you could specify the relative location of <varname>parent-a</varname>'s
      <acronym>POM</acronym> with the following configuration:</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
    &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;relativePath&gt;../a-parent/pom.xml&lt;/relativePath&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
&lt;/project&gt;</programlisting>
    </section>
  </section>

  <section id="pom-relationships-sect-pom-best-practice">
    <title>POM Best Practices</title>

    <para>Maven can be used to manage everything from simple, single-project systems to builds that involve hundreds of
    inter-related submodules. Part of the learning process with Maven isn't just figuring out the syntax for configuring
    Maven, it is learning the "Maven Way"—the current set of best practices for organizing and building projects using
    Maven. This section attempts to distill some of this knowledge to help you adopt best practices from the start
    without having to wade through years of discussions on the Maven mailing lists.</para>

    <section id="pom-relationships-sect-grouping-deps">
      <title>Grouping Dependencies</title>

      <para>If you have a set of dependencies which are logically grouped together. You can create a project with pom
      packaging that groups dependencies together. For example, let's assume that your application uses Hibernate, a
      popular Object-Relational mapping framework. Every project which uses Hibernate might also have a dependency on
      the Spring Framework and a MySQL <acronym>JDBC</acronym> driver. Instead of having to include these dependencies
      in every project that uses Hibernate, Spring, and MySQL you could create a special <acronym>POM</acronym> that
      does nothing more than declare a set of common dependencies. You could create a project called
      <varname>persistence-deps</varname> (short for Persistence Dependencies), and have every project that needs to do
      persistence depend on this convenience project:</para>

      <para><example>
          <title>Consolidating Dependencies in a Single POM Project</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;persistence-deps&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate&lt;/artifactId&gt;
      &lt;version&gt;\${hibernateVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
      &lt;version&gt;\${hibernateAnnotationsVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-hibernate3&lt;/artifactId&gt;
      &lt;version&gt;\${springVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
      &lt;version&gt;\${mysqlVersion}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;properties&gt;
    &lt;mysqlVersion&gt;(5.1,)&lt;/mysqlVersion&gt;
    &lt;springVersion&gt;(2.0.6,)&lt;/springVersion&gt;
    &lt;hibernateVersion&gt;3.2.5.ga&lt;/hibernateVersion&gt;
    &lt;hibernateAnnotationsVersion&gt;3.3.0.ga&lt;/hibernateAnnotationsVersion&gt;
  &lt;/properties&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>If you create this project in a directory named <varname>persistence-deps</varname>, all you need to do is
      create this <filename>pom.xml</filename> and run <command>mvn install</command>. Since the packaging type is
      <varname>pom</varname>, this POM is installed in your local repository. You can now add this project as a
      dependency and all of its dependencies will be added to your project. When you declare a dependency on this
      persistence-deps project, don't forget to specify the dependency type as pom.</para>

      <para><example>
          <title>Declaring a Dependency on a POM</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;description&gt;This is a project requiring JDBC&lt;/description&gt;
  ...
  &lt;dependencies&gt;
    ...
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
      &lt;artifactId&gt;persistence-deps&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>If you later decide to switch to a different <acronym>JDBC</acronym> driver (for example,
      <acronym>JTDS</acronym>), just replace the dependencies in the <varname>persistence-deps</varname> project to use
      <varname>net.</varname><varname>sourceforge.</varname><varname>jtds:</varname><varname>jtds</varname> instead of
      <varname>mysql:</varname><varname>mysql-java-connector</varname> and update the version number. All projects
      depending on <varname>persistence-deps</varname> will use <acronym>JTDS</acronym> if they decide to update to the
      newer version. Consolidating related dependencies is a good way to cut down on the length of
      <filename>pom.xml</filename> files that start having to depend on a large number of dependencies. If you need to
      share a large number of dependencies between projects, you could also just establish parent-child relationships
      between projects and refactor all common dependencies to the parent project, but the disadvantage of the
      parent-child approach is that a project can have only one parent. Sometimes it makes more sense to group similar
      dependencies together and reference a <literal>pom</literal> dependency. This way, your project can reference as
      many of these consolidated dependency <acronym>POM</acronym>s as it needs.</para>

      <note>
        <para>Maven uses the depth of a dependency in the tree when resolving conflicts using a nearest-wins approach.
        Using the dependency grouping technique above pushes those dependencies one level down in the tree. Keep this in
        mind when choosing between grouping in a pom or using <sgmltag>dependencyManagement</sgmltag> in a parent
        <acronym>POM</acronym></para>
      </note>
    </section>

    <section id="pom-relationships-sect-multi-vs-inherit">
      <title>Multi-module vs. Inheritance</title>

      <para>There is a difference between inheriting from a parent project and<indexterm>
          <primary>multimodule projects, in general</primary>

          <secondary>inheritance versus</secondary>
        </indexterm><indexterm>
          <primary>project inheritance</primary>

          <secondary>choosing multimodule projects instead of</secondary>
        </indexterm><indexterm>
          <primary>inheritance between projects or modules</primary>

          <secondary>choosing multimodule projects instead of</secondary>
        </indexterm><indexterm>
          <primary>module inheritance</primary>

          <secondary>choosing multimodule projects instead of</secondary>
        </indexterm> being managed by a multimodule project. A parent project is one that passes its values to its
      children. A multimodule project simply manages a group of other subprojects or modules. The multimodule
      relationship is defined from the topmost level downwards. When setting up a multimodule project, you are simply
      telling a project that its build should include the specified modules. Multimodule builds are to be used to group
      modules together in a single build. The parent-child relationship is defined from the leaf node upwards. The
      parent-child relationship deals more with the definition of a particular project. When you associate a child with
      its parent, you are telling Maven that a project’s <acronym>POM</acronym> is derived from another.</para>

      <para>To illustrate the decision process that goes into choosing a design that uses inheritance vs. multi-module
      or both approaches consider the following two examples: the Maven project used to generate this book and a
      hypothetical project that contains a number of logically grouped modules.</para>

      <section id="pom-relationships-sect-simple-project">
        <title>Simple Project</title>

        <para>First, let's take a look at the maven-book project. The inheritance and multi-module relationships are
        shown in <xref linkend="fig-maven-book" />.</para>

        <figure id="fig-maven-book">
          <title>maven-book Multi-module vs. Inheritance</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/pom_book-example.png" />
            </imageobject>

            <imageobject role="print">
              <imagedata align="center" fileref="figs/print/pom_book-example.pdf" format="PDF" scalefit="0" width="100%" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>When we build this Maven book you are reading, we run <command>mvn package</command> in a multi-module
        project named <varname>maven-book</varname>. This multi-module project includes two submodules:
        <varname>book-examples</varname> and <varname>book-chapters</varname>. Neither of these projects share the same
        parent, they are related only in that they are modules in the <varname>maven-book</varname> project.
        <varname>book-examples</varname> builds the <acronym>ZIP</acronym> and <acronym>TGZ</acronym> archives you
        downloaded to get this book's example. When we run the <varname>book-examples</varname> build from
        <filename>book-examples/</filename> directory with <command>mvn package</command>, it has no knowledge that it
        is a part of the larger <varname>maven-book</varname> project. <varname>book-examples</varname> doesn't really
        care about <varname>maven-book</varname>, all it knows in life is that its parent is the top-most
        <varname>sonatype</varname> <acronym>POM</acronym> and that it creates an archive of examples. In this case, the
        <varname>maven-book</varname> project exists only as a convenience and as a aggregator of modules.</para>

        <para>Each of the three projects: <varname>maven-book</varname>, <varname>book-examples</varname>, and
        <varname>book-chapters</varname> all list a shared "corporate" parent — <varname>sonatype</varname>. This is a
        common practice in organizations which have adopted Maven, instead of having every project extend the Super
        <acronym>POM</acronym> by default, some organizations define a top-level corporate <acronym>POM</acronym> that
        serves as the default parent when a project doesn't have any good reason to depend on another. In this book
        example, there is no compelling reason to have <varname>book-examples</varname> and
        <varname>book-chapters</varname> share the same parent <acronym>POM</acronym>, they are entirely different
        projects which have a different set of dependencies, a different build configuration, and use drastically
        different plugins to create the content you are now reading. The <varname>sonatype</varname>
        <acronym>POM</acronym> gives the organization a change to customize the default behavior of Maven and supply
        some organization-specific information to configure deployment settings and build profiles.</para>
      </section>

      <section id="pom-relationships-sect-multi-module-enterprise">
        <title>Multi-module Enterprise Project</title>

        <para>Let's take a look at an example that provides a more accurate picture of a real-world project where
        inheritance and multi-module relationships exist side by side. <xref linkend="fig-multi-module" /> shows a
        collection of projects that resemble a typical set of projects in an enterprise application. There is a
        top-level <acronym>POM</acronym> for the corporation with an <varname>artifactId</varname> of
        <varname>sonatype</varname>. There is a multi-module project named <varname>big-system</varname> which
        references sub-modules <varname>server-side</varname> and <varname>client-side</varname>.</para>

        <figure id="fig-multi-module">
          <title>Enterprise Multi-module vs. Inheritance</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/pom_real_multi.png" />
            </imageobject>

            <imageobject role="print">
              <imagedata align="center" fileref="figs/print/pom_real_multi.pdf" format="PDF" scalefit="0" width="100%" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>What's going on here? Let's try to deconstruct this confusing set of arrows. First, let's take a look at
        <varname>big-system</varname>. The <varname>big-system</varname> might be the project that you would run
        <command>mvn package</command> on to build and test the entire system. <varname>big-system</varname> references
        submodules <varname>client-side</varname> and <varname>server-side</varname>. Each of these projects effectively
        rolls up all of the code that runs on either the server or on the client. Let's focus on the
        <varname>server-side</varname> project. Under the <varname>server-side</varname> project we have a project
        called <varname>server-lib</varname> and a multi-module project named <varname>web-apps</varname>. Under
        <varname>web-apps</varname> we have two Java web applications: <varname>client-web</varname> and
        <varname>admin-web</varname>.</para>

        <para>Let's start with the parent/child relationships from <varname>client-web</varname> and
        <varname>admin-web</varname> to <varname>web-apps</varname>. Since both of the web applications are implemented
        in the same web application framework (let's say Wicket), both projects would share the same set of core
        dependencies. The dependencies on the Servlet <acronym>API</acronym>, the <acronym>JSP</acronym>
        <acronym>API</acronym>, and Wicket would all be captured in the <varname>web-apps</varname> project. Both
        <varname>client-web</varname> and <varname>admin-web</varname> also need to depend on
        <varname>server-lib</varname>, this dependency would be defined as a dependency between
        <varname>web-apps</varname> and <varname>server-lib</varname>. Because <varname>client-web</varname> and
        <varname>admin-web</varname> share so much configuration by inheriting from <varname>web-apps</varname>, both
        <varname>client-web</varname> and <varname>admin-web</varname> will have very small <acronym>POM</acronym>s
        containing little more than identifiers, a parent declaration, and a final build name.</para>

        <para>Next we focus on the parent/child relationship from <varname>web-apps</varname> and
        <varname>server-lib</varname> to <varname>server-side</varname>. In this case, let's just assume that there is a
        separate working group of developers which work on the server-side code and another group of developers that
        work on the client-side code. The list of developers would be configured in the <varname>server-side</varname>
        POM and inherited by all of the child projects underneath it: <varname>web-apps</varname>,
        <varname>server-lib</varname>, <varname>client-web</varname>, and <varname>admin-web</varname>. We could also
        imagine that the <varname>server-side</varname> project might have different build and deployment settings which
        are unique to the development for the server side. The <varname>server-side</varname> project might define a
        build profile that only makes sense for all of the <varname>server-side</varname> projects. This build profile
        might contain the database host and credentials, or the <varname>server-side</varname> project's
        <acronym>POM</acronym> might configure a specific version of the Maven Jetty plugin which should be universal
        across all projects that inherit the <varname>server-side</varname> <acronym>POM</acronym>.</para>

        <para>In this example, the main reason to use parent/child relationships is shared dependencies and common
        configuration for a group of projects which are logically related. All of the projects below
        <varname>big-system</varname> are related to one another as submodules, but not all submodules are configured to
        point back to parent project that included it as a submodule. Everything is a submodule for reasons of
        convenience, to build the entire system just go to the <varname>big-system</varname> project directory and run
        <command>mvn package</command>. Look more closely at the figure and you'll see that there is no parent/child
        relationship between <varname>server-side</varname> and <varname>big-system</varname>. Why is this?
        <acronym>POM</acronym> inheritance is very powerful, but it can be overused. When it makes sense to share
        dependencies and build configuration, a parent/child relationship should be used. When it doesn't make sense is
        when there are distinct differences between two projects. Take, for example, the <varname>server-side</varname>
        and <varname>client-side</varname> projects. It is possible to create a system where
        <varname>client-side</varname> and <varname>server-side</varname> inherited a common <acronym>POM</acronym> from
        <varname>big-system</varname>, but as soon as a significant divergence between the two child projects develops,
        you then have to figure out creative ways to factor out common build configuration to
        <varname>big-system</varname> without affecting all of the children. Even though <varname>client-side</varname>
        and <varname>server-side</varname> might both depend on Log4J, they also might have distinct plugin
        configurations.</para>

        <para>There's a certain point defined more by style and experience where you decide that minimal duplication of
        configuration is a small price to pay for allowing projects like <varname>client-side</varname> and
        <varname>server-side</varname> to remain completely independent. Designing a huge set of thirty plus projects
        which all inherit five levels of POM configuration isn't always the best idea. In such a setup, you might not
        have to duplicate your Log4J dependency more than once, but you'll also end up having to wade through five
        levels of POM just figure out how Maven calculated your effective POM. All of this complexity to avoid
        duplicating five lines of dependency declaration. In Maven, there is a "Maven Way", but there are also many ways
        to accomplish the same thing. It all boils down to preference and style. For the most part, you won't go wrong
        if all of your submodules turn out to define back-references to the same project as a parent, but your use of
        Maven may evolve over time.</para>
      </section>
    </section>
  </section>
</chapter>
