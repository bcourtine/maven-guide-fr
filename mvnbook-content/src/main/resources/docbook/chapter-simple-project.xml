<?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="simple-project"><title>Mon Premier Projet avec Maven</title>  <section id="simple-project-sect-intro"><title>Introduction</title> <para>Dans ce chapitre, nous introduisons un projet simple créé à partir de rien en utilisant le plugin Maven Archetype. Cette application basique va nous fournir l'occasion de discuter certains des concepts au coeur de Maven tout en suivant le développement du projet.</para> <para>Avant de se lancer dans l'utilisation de Maven sur des builds complexes avec plusieurs modules, nous allons commencer par les bases. Si vous avez déjà utilisé Maven auparavant, vous noterez qui fait bien son travail en s'occupant des détails. Vos builds tendent à "fonctionner correctement", et vous n'avez à vous plonger dans les détails de Maven que lorsque vous voulez personnaliser un comportement par défaut ou écrire votre propre plugin. Cependant, quand vous devez vous plonger dans ces détails, une bonne compéhension des concepts principaux est essentielle. Ce chapitre a pour but de vous présenter le projet Maven le plus simple possible puis vous montrer les concepts principaux de Maven qui en font une solide plateforme de build. Une fois que vous l'aurez lu, vous aurez une compréhension fondamentale du cycle de vie du build, des dépôts Maven et du Project Object Model (<acronym>POM</acronym>). </para> <section id="simple-project-sect-downloading-example"><title>Télécharger l'Exemple de ce Chapitre</title> <para>Ce chapitre développe un exemple très simple qui sera utilisé pour explorer les concepts principaux de Maven. Si vous suivez les étapes décrites dans ce chapitre, vous ne devriez pas avoir besoin de télécharger les exemples pour recréer le code produit par Maven. Nous allons utiliser le plugin Maven Archetype pour créer ce simple projet que ce chapitre ne modifie en rien. Si vous préferrez lire ce chapitre avec le code source final de l'exemple, le projet qui sert d'exemple dans ce chapitre peut être téléchargé avec le code source des exemples du livre depuis <ulink
      url="http://www.sonatype.com/book/mvn-examples-1.0.zip">http://www.sonatype.com/book/mvn-examples-1.0.zip</ulink> ou <ulink
      url="http://www.sonatype.com/book/mvn-examples-1.0.tar.gz">http://www.sonatype.com/book/mvn-examples-1.0.tar.gz</ulink>. Décompressez cette archive dans n'importe quel répertoire, puis allez dans le répertoire <filename>ch03/</filename>. Dans le répertoire<filename>ch03/</filename> vous trouverez un répertoire <filename>simple/</filename> qui contient le code source de ce chapitre. Si vous souhaitez suivre avec le code de cet exemple dans un navigateur web, allez à <ulink
      url="http://www.sonatype.com/book/examples-1.0">http://www.sonatype.com/book/examples-1.0</ulink> et cliquez sur le répertoire <filename>ch03/</filename>. </para> </section> </section> <section id="simple-project-sect-create-simple"><title>Création d'un Simple Projet</title> <para>Pour commencer un nouveau projet Maven, utilisez le plugin Maven Archetype plugin depuis la ligne de commande. </para><screen><command>$ mvn archetype:create -DgroupId=org.sonatype.mavenbook.ch03 \
                                         -DartifactId=simple \
                                         -DpackageName=org.sonatype.mavenbook
</command>[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'archetype'.               
[INFO] artifact org.apache.maven.plugins:maven-archetype-plugin: checking for 
       updates from central
[INFO] -----------------------------------------------------------------------
[INFO] Building Maven Default Project
[INFO]    task-segment: [archetype:create] (aggregator-style)
[INFO] --------------------------------------------------------------------
[INFO] [archetype:create]
[INFO] artifact org.apache.maven.archetypes:maven-archetype-quickstart: \
       checking for updates from central
[INFO] Parameter: groupId, Value: org.sonatype.mavenbook.ch03
[INFO] Parameter: packageName, Value: org.sonatype.mavenbook
[INFO] Parameter: basedir, Value: /Users/tobrien/svnw/sonatype/examples
[INFO] Parameter: package, Value: org.sonatype.mavenbook
[INFO] Parameter: version, Value: 1.0-SNAPSHOT
[INFO] Parameter: artifactId, Value: simple
[INFO] * End of debug info from resources from generated POM *
[INFO] Archetype created in dir: /Users/tobrien/svnw/sonatype/examples/simple
</screen> <para><command>mvn</command> c'est l'instruction pour Maven 2. <varname>archetype:</varname><varname>create</varname> est un goal Maven. Si vous connaissez <indexterm> <primary>goals</primary> <secondary>à propos</secondary> </indexterm><indexterm> <primary>Maven goals, à propos</primary> </indexterm><indexterm> <primary>parent POM</primary> <seealso>POM</seealso> </indexterm><indexterm> <primary>racine POM</primary> <seealso>POM</seealso> </indexterm> Apache Ant, un goal Maven est analogue à une target Ant; tous les deux décrivent une unité de tâche à accomplir lors d'un build. La paire <varname>-Dname=value</varname> représente un argument passé au goal sous la forme de propriétés <varname>-D</varname>, comme pour les propriétés système que vous pourriez passer à la Machine Virtuelle Java via la ligne de commande. Le but du goal <varname>archetype:</varname><varname>create</varname> est de créé rapidement un projet à partir d'un archétype. Dans ce contexte, un<indexterm> <primary sortas="archetypes">archétypes, definition</primary> </indexterm> archétype se défini comme " un  modèle original ou idéal d'après lequel sont bâtis un ouvrage, une ɶuvre; un prototype."<footnote
        id="foot-archetype-def"> <para><emphasis>Selon l'American Heritage Dictionary of the English Language</emphasis>. </para> </footnote>Il existe un grand nombre d'archétypes disponibles pour Maven, depuis une application Swing simplr jusqu'à une application web complexe. Dans ce chapitre, nous allons utiliser l'archétype le plus basique pour créer un simple squelette projet de démarrage. Le préfixe <literal>archetype</literal> correspond au plugin, et <literal>create</literal> correspond au goal.</para> <para>Une fois ce projet généré, allons regarder la structure de répertoire Maven qui a été créée sous le répertoire simple. </para><screen>simple/
<co id="coDef-simple-fs-root"
        linkends="coRef-simple-fs-root" />simple/pom.xml <co id="coDef-simple-fs-pom" linkends="coRef-simple-fs-pom" />/src/ /src/main/ <co id="coDef-simple-fs-main" linkends="coRef-simple-fs-main" />/main/java /src/test/ <co id="coDef-simple-fs-test" linkends="coRef-simple-fs-test" />/test/java</screen> <para>Ce répertoire suit les recommandations de Disposition Maven Standard des Répertoires<indexterm> <primary>Standard Directory Layout</primary> </indexterm><indexterm> <primary>Maven Standard Directory Layout</primary> </indexterm>. Nous détaillerons cela plus tard dans ce chapitre, pour l'instant essayons de comprendre ces quelques <phrase role="keep-together">répertoires</phrase>:</para> <calloutlist> <callout arearefs="coDef-simple-fs-root" id="coRef-simple-fs-root"> <para>Le plugin Maven Archetype crée un répertoire dont le nom correspond à l'<varname>artifactId</varname>. Simple. C'est ce qu'on appele le répertoire racine <indexterm> <primary>base directory</primary> </indexterm> du projet.</para> </callout> <callout arearefs="coDef-simple-fs-pom" id="coRef-simple-fs-pom"> <para>Chaque projet Maven possède ce qu'on appele un Project Object Model (<acronym>POM</acronym>) dans un fichier <filename>pom.xml</filename>. Ce fichier décrit le projet, configure les plugins, et déclare les dépendances.</para> </callout> <callout arearefs="coDef-simple-fs-main" id="coRef-simple-fs-main"> <para>Les sources et les ressources de notre projet se retrouvent sous le répertoire <filename>src/main</filename>. Dans le cas de notre simple projet Java cela consistera en quelques classes Java et fichiers de propriétés. Pour un autre projet, on pourrait y trouver le répertoire racine d'une application web ou les fichiers de configuration d'un serveur d'application. Dans un projet Java, les classes Java sont dans <filename>src/main/java</filename> et les ressources disponibles dans le classpath vont dans <filename>src/main/resources</filename>.</para> </callout> <callout arearefs="coDef-simple-fs-test" id="coRef-simple-fs-test"> <para>Les tests de notre pojet vont dans <filename>src/test</filename>. Dans ce réperoire, les classes Java, comme par exemple les tests JUnit ou TestNG, sont dans <filename>src/test/java</filename>, et les ressources du classpath pour les tests vont dans <filename>src/test/resources</filename>.</para> </callout> </calloutlist> <para>Le plugin Maven Archetype a produit une classe unique <classname>org.sonatype.mavenbook.</classname><classname>App</classname>, qui contient 13 lignes de Java avec une fonction static main qui affiche le message: </para><programlisting language="java">package org.sonatype.mavenbook;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        System.out.println( "Hello World!" );
    }
}
</programlisting> <para>Le plus simple des archétypes Maven produit le programme le plus simple possible: un programme qui affiche "Hello World!" sur la sortie standard. </para> </section> <section id="simple-project-sect-building-simple"><title>Construire un Simple Project</title> <para>Une fois le projet créé grâce au plugin Maven Archetype suivant les instructions de la section précédente (<xref linkend="simple-project-sect-create-simple" />) il faut maintenant construire et  packager l'application. Afin d'y parvenir, exécutez <command>mvn install</command> depuis<indexterm> <primary>mvn install command</primary> </indexterm><indexterm> <primary>building applications</primary> </indexterm><indexterm> <primary>packaging applications</primary> </indexterm><indexterm> <primary>applications, building and packaging</primary> </indexterm> le répertoire qui contient le <filename>pom.xml</filename>: </para><screen><command>$ mvn install
</command>[INFO] Scanning for projects...
[INFO] ----------------------------------------------------------------------
[INFO] Building simple
[INFO]    task-segment: [install]
[INFO] ----------------------------------------------------------------------
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Compiling 1 source file to /simple/target/classes
[INFO] [resources:testResources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:testCompile]
[INFO] Compiling 1 source file to /simple/target/test-classes
[INFO] [surefire:test]
[INFO] Surefire report directory: /simple/target/surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running org.sonatype.mavenbook.AppTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.105 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO] [jar:jar]
[INFO] Building jar: /simple/target/simple-1.0-SNAPSHOT.jar
[INFO] [install:install]
[INFO] Installing /simple/target/simple-1.0-SNAPSHOT.jar to \
  ~/.m2/repository/com/sonatype/maven/ch03/simple/1.0-SNAPSHOT/ \
  simple-1.0-SNAPSHOT.jar
</screen> <para>Vous venez juste de créer, compiler, tester, packager et installer le projet Maven le plus simple possible. Pour vous prouvez que ce programme fonctionne, exécutez le depuis la ligne de commande. </para><screen><command>$ java -cp target/simple-1.0-SNAPSHOT.jar org.sonatype.mavenbook.App
</command>Hello World!
</screen>  </section> <section id="simple-project-sect-pom"><title>Simple Project Object Model</title> <para>Lors de son exécution Maven lit dans le Project Object Model <indexterm> <primary>POM (Project Object Model)</primary> </indexterm><indexterm> <primary>Project Object Model</primary> <see>POM; pom.xml file</see> </indexterm><indexterm> <primary>pom.xml file</primary> </indexterm> les informations sur le projet. Le <acronym>POM</acronym> répond aux questions telles que: De quel type de projet s'agit il ? Quel est le nom du projet? Ce projet a t il été personnalisé? <xref linkend="example_simple-project-pom" /> montre le fichier <filename>pom.xml</filename> par défaut créé par le goal create du plugin Maven Archetype. </para> <example id="example_simple-project-pom"><title>Simple project's <filename>pom.xml</filename> file</title> <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.ch03&lt;/groupId&gt;
  &lt;artifactId&gt;simple&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;name&gt;simple&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting> </example> <para>Ce fichier <filename>pom.xml</filename> est le plus basique <acronym>POM</acronym> que vous rencontrerez dans un projet Maven, la plupart du temps un fichier<acronym>POM</acronym> fest considérablement plus complexe: il définit de nombreuses dépendances et personnalise le comportement des plugins. Les premiers éléments&mdash;<sgmltag>groupId</sgmltag>, <sgmltag>artifactId</sgmltag>, <sgmltag>packaging</sgmltag>, <sgmltag>version</sgmltag>&mdash;sont ce qu'on appele les coordonnées Maven qui identifient de manière unique un projet. <sgmltag>name</sgmltag> et <sgmltag>url</sgmltag> sont des éléments descriptifs du  <acronym>POM</acronym> donnant un nom compréhensible par un être humain et associant le projet à un site web. L'élément <sgmltag>dependencies</sgmltag> définit une dépendance unique, dans le scope test, sur un framework de test appelé JUnit. Nous reverons ces sujets par la suite dans <xref linkend="simple-project-sect-simple-core" />, tout ce que vous devez savoir, en ce moment, c'est le que le <filename>pom.xml</filename> est le fichier qui permet l'exécution de Maven.</para> <para>Maven s'exécute toujours selon un <acronym>POM</acronym> effectif, une combinaison de la configuration du <filename>pom.xml</filename> de ce projet, de l'ensemble des  <acronym>POM</acronym>s parent, d'un super-<acronym>POM</acronym> défini dans Maven, de la configuration de l'utilisateur, et des profils actifs. Tous les projets étendent au final le super-<acronym>POM</acronym>,qui définit une configuration par défaut raisonnable et qui est compètement expliqué dans <xref linkend="pom-relationships" />. Même si votre projet a un <filename>pom.xml</filename> minimal, le contenu du <acronym>POM</acronym> de votre projet est interpolé à partir des conenus des <acronym>POM</acronym>s parent, de la configuration de ul'tilisateur, et de tout profil actif. Pour voir ce <acronym>POM</acronym>  "effectif", exécutez la commande suivante depuis le répertoire racine de votre simple projet. </para><screen>$ <command>mvn help:effective-pom</command></screen> <para>Lorsque vous exécutez cette commande, vous pouvez voir un <acronym>POM</acronym> nettement plus consistent qui montre la configuration par défaut de Maven. Ce goal devient vite pratique lorsque vous essayez de débugger un build et que vous voulez voir comment les POMs des parents de ce projet contribuent au POM effectif. Pour plus d'informations sur le plugin Maven Help, regardez <xref linkend="installation-sect-help-plugin-install" />. </para> </section> <section id="simple-project-sect-simple-core"><title>Les Principaux Concepts</title> <para>Maintenant que nous avons exécuté Maven pour la première fois, il est temps de s'intéresser aux  concepts qui sont au coeur de Maven. Dans l'exemple précédent, vous avez généré un projet qui consistait en un <acronym>POM</acronym> et un peu de code respectant la disposition Maven standard des répertoires. Puis vous exécutez Maven en lui passant une phase de son cycle de vie ce qui a demandé à Maven d'exécuter toute une série de goals de plugins Maven. Enfin, vous avez installé l'artéfact Maven dans votre dépôt local. Une minute? Qu'est ce que le "cycle de vie"? Qu'est donc un "dépôt local"? La section qui suit définit certains des concepts au coeur de Maven. </para> <section id="simple-project-sect-plugins-goals"><title>Plugins Maven Plugins et Goals</title> <para>Dans la section précédente, nous avons exécuté Maven  en ligne de commande avec deux types d'<indexterm> <primary>Maven plugins</primary> <see>plugins</see> </indexterm><indexterm> <primary>goals</primary> <seealso>plugins</seealso> </indexterm> command-line <phrase role="keep-together">arguments</phrase> différents. La première commande appelait uniquement un goal d'un plugin, le goal <varname>create</varname> du plugin Archetype. La deuxième exécution de Maven était une phase du cycle de vie, <varname>install</varname>. Pour<indexterm> <primary>executing goals</primary> </indexterm><indexterm> <primary>executing goals</primary> <seealso>goals</seealso> </indexterm> exécuter un unique goal d'un plugin Maven, nous avons utilisé la syntaxe <command>mvn archetype:create</command>, où <varname>archetype</varname> est l'identifiant du plugin et <varname>create</varname> l'identifiant du goal. Lorsque Maven exécute le goal d'un plugin, il affiche l'identifiant du plugin et l'identifiant du goal sur la sortie standard: </para><screen><command>$ mvn archetype:create -DgroupId=org.sonatype.mavenbook.ch03 \
                                        -DartifactId=simple \
                                        -DpackageName=org.sonatype.mavenbook
</command>...
<emphasis>[INFO] [archetype:create]</emphasis>
[INFO] artifact org.apache.maven.archetypes:maven-archetype-quickstart: \
       checking for updates from central
...
</screen> <para>Un Plugin Maven se compose de un ou plusieurs goals. On peut prendre comme exemples de plugins Maven, de simples plugins qui composent le ceur de Maven comme le plugin Jar qui possède les goals pour créer des fichiers <acronym>JAR</acronym> files, le plugin Compiler qui lui possède les goals pour compiler le code source et le code des tests unitaires, ou le plugin Surefire dont les goals permettent l'exécution des tests unitaires et la production des rapports. On trouve aussi d'autres plugins, plus spécialisés, comme le plugin Hibernate3 pour l'intégration de la bibliothèque très connue de persitence Hibernate, le plugin JRuby qui permet l'exécution de code Ruby durant un build Maven ou l'écriture de plugins Maven en Ruby. Maven permet aussi de définir ses propres plugins. Vous pouvez écrire votre propre plugin en Java ou dans de nombreux autres langages dont Ant, Groovy, Beanshell et, comme indiqué plus haut, Ruby. </para> <figure><title>Un Plugin Possède des Goals</title> <mediaobject> <imageobject> <imagedata fileref="figs/web/simple-project_plugin.png"
                       width="5in" /> </imageobject> </mediaobject> </figure> <para>Un goal est une tâche spécifique qui peut être exécuté individuellement <indexterm> <primary>goals</primary> <secondary>defined</secondary> </indexterm> ou combiné à d'autres goals pour un build plus large. Un goal est une "tâche unitaire" dans Maven. On peut prendre comme exemples de goals le goal <varname>compile</varname> du plugin Compiler, qui compile tout le code source du projet, ou le goal <varname>test</varname> du plugin Surefire, qui exécute les tests unitaires. La configuration des goals se fait au travers de propriétés qui sont utilisées pour personnaliser le comportement. Par exemple, le goal <varname>compile</varname> du plugin Compiler définit un ensemble de <phrase role="keep-together">paramètres</phrase> de configuration qui vous permettent de préciser la version du JDK cible ou les options d'optimisation du compilateur. Dans l'exemple précédent, nous avons passé les paramètres de configuration <varname>groupId</varname> et <varname>artifactId</varname> au goal <varname>create</varname> du plugin Archetype via les paramètres de la ligne de commande <command>-DgroupId=org.sonatype.mavenbook.ch03</command> et <command>-DartifactId=simple</command>. Nous avons <phrase role="keep-together">aussi</phrase> passé le paramètre <varname>packageName</varname> au goal <literal>create</literal> avec la valeur <package>org.sonatype.mavenbook</package>. Si nous n'avions pas précisé le paramètre <varname>packageName</varname>, le nom du package aurait été par défaut <package>org.sonatype.mavenbook.ch03</package>.</para> <para><note> <para>Lorsque l'on fait référence au goal d'un plugin, il est courant d'utiliser le raccourci: <replaceable>pluginId</replaceable><literal>:</literal><replaceable>goalId</replaceable>. Par exemple, pour utiliser le goal <literal>create</literal> du plugin Archetype plugin, nous pouvons écrire <varname>archetype:</varname><varname>create</varname>.</para> </note></para> <para>Les goals ont des paramètres qui peuvent avoir des valeurs par défaut raisonnables. Dans l'exemple de <varname>archetype:</varname><varname>create</varname>, nous n'avons pas précisé, via la ligne de commande, quel type d'archétype devait être utilisé pour créer le projet; nous avons simplement indiqué un <varname>groupId</varname> et un <varname>artifactId</varname>. C'est notre premier contact avec le concept<indexterm> <primary>convention over configuration</primary> </indexterm> <emphasis> de convention plutôt que configuration</emphasis>. La convention, ou le comportoment par défaut, pour le goal <varname>create</varname> est de créer un projet simple à partir de l'archétype Quickstart. Le goal <varname>create</varname> définit une propriété de configuration <varname>archetypeArtifactId</varname> dont la valeur par défaut est <varname>maven-archetype-</varname><varname>quickstart</varname>. L'archétype Quickstart génère la coquille d'un projet minimal qui contient un <acronym>POM</acronym> et une unique classe. Le plugin Archetype est bien plus puissant que cet exemple ne le laisse croirer, mais cest une façon efficace de commencer rapidement de nouveaux projets. Plus tard dans ce livre, nous vous montrerons comment il est possible d'utiliser le plugin Archetype pour produiredes projets complexes, comme des applications web, et comment utiliser le plugin  Archetype pour définir vos propres structures de projets.</para> <para>Le coeur de Maven n'intervient que très peu dans les tâches spécifiques qui composent le build de votre projet. Maven, tout seul, ignore comment compiler votre code ou produire un fichier <acronym>JAR</acronym>. Il délègue tout cela à des plugins Maven comme le plugin Compiler et le plugin Jar, qui sont téléchargés selon les besoins et mis à jour régulièrement depuis le dépôt central de Maven. Lorsque vous téléchargez Maven, vous n'obtenez que le coeur de la plateforme qui ne sait que parser une ligne de commande, gérer un classpath, parser un fichier <acronym>POM</acronym>, et télécharger des plugins Maven selon les besoins. Les utilisateurs ont facilement accès aux dernières options du compilateur grâce à Maven qui maintient à part le le plugin Compiler de son coeur et fournit un mécanisme de mise à jour. Ainsi, les plugins Maven fournissent une logique de build réutilisable universellement. Vous ne définissez pas la tâche de compilation dans un fichier de build,; vous utilisez le plugin  Compiler plugin qui est partagé par tous les utilisateurs de Maven. Si le plugin Compiler est amélioré, tout projet qui utilise Maven en bénéficie immédiatement. (Et, si n'aimez pas le plugin Compiler, vous pouvez le remplacer par votre propre implémentation.) </para> </section> <section id="simple-project-sect-lifecycle"><title>Le Cylde de VIe deMaven</title> <para>La deuxième commande que nous avons exécutée dans la section précédente <indexterm> <primary>Maven lifecycle</primary> <see>build lifecycle</see> </indexterm><indexterm> <primary>lifecycle, Maven</primary> <see>build lifecycle</see> </indexterm><indexterm class="startofrange" id="buildlife"> <primary>build lifecycle</primary> </indexterm><indexterm> <primary>phases, lifecycle</primary> <see>build lifecycle</see> </indexterm> était <command>mvn install</command>. Cette commande n'appele pas le goal d'un plugin, mais une phase du cycle de vie de Maven. Une phase est une des étapes de ce que Maven appele "le cycle de vie du build".Le cycle de vie du build est une suite ordonnée de phases aboutissant à la construction d'un projet. Maven peut supporter différents cycle de vie, mais celui qui est le plus utilisé est le ccycle de vie <indexterm> <primary>default Maven lifecycle</primary> </indexterm><indexterm> <primary>build lifecycle</primary> <secondary>default Maven lifecycle</secondary> </indexterm> par défaut de Maven lifecycle, qui commence par une phase de validation de l'intégrité du projet et se termine par une phase qui déploie un projet en production. Les phases du cycle de vie sont laissées vagues intentionnellement, définies comme validation, test, ou déploiement elles peuvent avoir un sens différent selon le contexte des projets. Par exemple, la phase <varname>package</varname> dans un projet qui produit un <acronym>JAR</acronym>, signifiemeans "package ce projet sous la forme d'un JAR"; pour un projet qui produit une application web, cette phase <varname>package</varname> peut produire un fichier <acronym>WAR</acronym>.</para> <para>Les goals des plugins peuvent être rattachés <indexterm> <primary>plugin goals</primary> <see>goals</see> </indexterm><indexterm> <primary>goals</primary> <secondary>attaching to lifecycle phases</secondary> </indexterm> à une phase du cycle de vie. Pendant que Maven parcourt les phases du cycle de vie, il exécute les goals rattachés à chacune d'entre elles. Chaque phase peut avoir de zéro à plusieurs goals rattachés. Dans la section précédente, quand vous avez exécuté <command>mvn install</command>, il se peut que vous ayez remarqué que plus d'un goal était exécuté. Regardez la sortie après avoir exécuté <command>mvn install</command> et relevez les différents goals qui ont été exécutés. Lorsque ce simple exemple atteint la phase <varname>package</varname>, il exécute le goal <varname>jar</varname> du plugin Jar. Puisque notre projet Quickstart a (par défaut) un packaging de type <varname>jar</varname>, le the goal <varname>jar:</varname><varname>jar</varname> est rattaché à la phase <varname>package</varname>. </para> <para><figure><title>Liens entre un Goal et une Phase</title> <mediaobject> <imageobject> <imagedata fileref="figs/web/simple-project_phasebinding.png" /> </imageobject> </mediaobject> </figure></para> <para>Nous savons que la phase <varname>package</varname> va créer un fichier <acronym>JAR</acronym> pour un projet ayant un packaging de type <varname>jar</varname>. Mais qu'en est il des goals qui la précèdent, comme <varname>compiler:</varname><varname>compile</varname> et <varname
      role="keep-together">surefire:</varname><varname
      role="keep-together">test</varname>? Ces goals s'exécutent lors des phases qui précèdent la phase <varname>package</varname> selon le<indexterm> <primary>executing lifecycle phases</primary> </indexterm> cycle de vie deMaven; exécuter une phase provoque l'exécution de l'ensemble des phases qui la précèdent,le tout se terminant par la phase spécifiée sur la ligne de commande. Chaque phase se compose de zéro à plusieurs goals, et puisque nous n'avons configuré ou personnalisé aucun plugin, cet exemple rattache un ensemble de goals standards au cycle de vie par défaut. Les goals suivants ont été exécuté dans l'ordre pendant que Maven parcourait le cycle de vie par défaut jusqu'à la phase<varname>package</varname>: </para> <variablelist> <varlistentry><term><varname>resources:resources</varname></term> <listitem> <para>Le goal <varname>resources</varname> du plugin <indexterm> <primary>Resources plugin</primary> <secondary>resources goal</secondary> </indexterm> Resources est rattaché à la phase <varname>process-resources</varname>. Ce goal copie toutes les ressources du répertoire <filename>src/main/resources</filename> et des autres répertoires configurés comme contenant des ressources dans le répertoire de résultat. </para> </listitem> </varlistentry> <varlistentry><term><varname>compiler:compile</varname></term> <listitem> <para>Le goal <varname>compile</varname> du plugin Compiler <indexterm> <primary>compile:compile goal</primary> </indexterm><indexterm> <primary>Compiler plugin</primary> <secondary>compile goal</secondary> </indexterm> est lié à la phase <varname>compile</varname>. Ce goal compile tout le source code du répertoire <filename>src/main/java</filename> et des autres répertoires configurés comme contenant du code source dans le répertoire de résultat. </para> </listitem> </varlistentry> <varlistentry><term><varname>resources:testResources</varname></term> <listitem> <para>Le goal <varname>testResources</varname> du plugin Resources<indexterm> <primary>Resources plugin</primary> <secondary>testResources goal</secondary> </indexterm> est lié à la phase <varname>process-test-resources</varname>. Ce goal copie toutes les ressourcesdu répertoire <filename>src/test/resources</filename> et des autres répertoires configurés comme contenant des ressources de test dans le répertoire de résultat de test. </para> </listitem> </varlistentry> <varlistentry><term><varname>compiler:testCompile</varname></term> <listitem> <para>Le goal <varname>testCompile</varname> du plugin Compiler<indexterm> <primary>Compiler plugin</primary> <secondary>testCompile goal</secondary> </indexterm> est rattaché à la phase <varname>test-compile</varname>. Ce goal compile les tests unitaires du répertoire <filename>src/test/java</filename> et des autres répertoires configurés comme contenant du code source de test dans le répertoire de résultat de test. </para> </listitem> </varlistentry> <varlistentry><term><varname>surefire:test</varname></term> <listitem> <para>Le goal <varname>test</varname> du plugin Surefire est<indexterm> <primary>Surefire plugin</primary> <secondary>test goal</secondary> </indexterm><indexterm> <primary>Maven Surefire plugin</primary> <secondary>test goal</secondary> </indexterm><indexterm> <primary>testing</primary> <secondary>Surefire:test goal</secondary> </indexterm> rattaché à la phase <varname>test</varname>. Ce goal exécute tous les tests et produit des fichiers contenant leurs résultats détaillés. Par défaut, en cas d'échec de l'un des tests le goal arrêtera le build. </para> </listitem> </varlistentry> <varlistentry><term><varname>jar:jar</varname></term> <listitem> <para>Le goal <varname>jar</varname> du  plugin Jar est lié <indexterm> <primary>jar:jar goal</primary> </indexterm> à la phase <varname>package</varname>. Ce goal packages le contenu du répertoire de  résultat en un fichier JAR. </para> </listitem> </varlistentry> </variablelist> <para><figure><title>Les Goals Rattachés sont lancés à l'Exécution de leurs Phases</title> <mediaobject> <imageobject> <imagedata fileref="figs/web/simple-project_lifecyclebinding.png" /> </imageobject> </mediaobject> </figure></para> <para>Pour résumer, lorsque nous avons exécuté <command>mvn install</command>, Maven execute toutes les phases jusqu'à la phase install, et pour cela il parcourt toutes les phases du cycle de vie, exécutant tous les goals liés à chacune de ces phases. Au lieu d'exécuter une des phases du cycle de vie de Maven, ous pourriez obtenir le même résultat en spécifiant une liste de goals de plugin de la manière suivante: </para><screen><command>mvn resources:resources \
    compiler:compile \
    resources:testResources \
    compiler:testCompile \
    surefire:test \
    jar:jar \
    install:install</command> 
</screen> <para>Il est beaucoup plus simple d'exécuter les phases du cycle de vi plutôt que de lister explicitement les goals à exécuter en lign de commande, de plus, ce cycle de vie commun permet à chaque projet utilisant Maven d'adhérer à un ensemble de standards bien définis. C'est ce cycle de vie qui permet à un développeur de passer d'un projet à l'autre sans connaitre tous les détails du build de chacun d'entre eux. Si vous savez construire un projet Maven, vous savez tous les construire. </para> </section> <section id="simple-project-sect-maven-coordinates"><title>Les Coordonnées Maven</title> <para>Le plugin Archetype a créé un projet avec un fichier <indexterm class="startofrange" id="coord1"> <primary>Maven coordinates</primary> </indexterm><indexterm class="startofrange" id="coord2"> <primary>coordinates</primary> </indexterm> <filename>pom.xml</filename>. Ceci est le Project Object Model (<acronym>POM</acronym>), une description déclarative d'un projet. Quand Maven exécute un goal, ccelui-ci a accès aux informations définies dans le <acronym>POM</acronym> du projet. Lorsque le goal <varname>jar:</varname><varname>jar</varname> veut créer un fichier <acronym>JAR</acronym>, il va chercher dans le <acronym>POM</acronym> le nom du fichier JAR. Quand le goal <varname>compiler:</varname><varname>compile</varname> compile le source code Java en bytecode, il va regarder dans le <acronym>POM</acronym> pour voir si on a précisé des options de compilation. Les goals s'exécutent dans le contexte d'un <acronym>POM</acronym>. Les goas sont des actions que nous voulons faire sur un projet, et un projet est défini par un  <acronym>POM</acronym>. Le <acronym>POM</acronym> donne son nom au projet, il fournit un ensemble d'identifiants uniques (les coordonnées) du projet, et précise les  relations entre ce projet et d'autres qu'il s'agisse  de dépendances, de parents ou de prérequis. Un <acronym>POM</acronym> permet aussi de personnaliser le comportement d'un plugin, et de fournir des informations sur la communauté et les développeurs du projet.</para> <para>Les  Coordonnées Maven définissent un ensemble d'identifiants qui permettent d'identifier de manière unique un projet, une dépendance, ou un plugin dans un <acronym>POM</acronym> Maven. Regardez le <acronym>POM</acronym> qui va suivre. </para> <para><figure><title>Coordonnées d'un Projet Maven</title> <mediaobject> <imageobject> <imagedata fileref="figs/web/simple-project_annopom.png"
                         width="6in" /> </imageobject> </mediaobject> </figure></para> <para>Nous avons surligné les cooronnées Maven de ce projet: les <varname>groupId</varname>, <varname>artifactId</varname>, <varname>version</varname> et <varname>packaging</varname>. Ces identifiants combinés forment ce qu'on appele les coordonnées d'un projet.<footnote
          id="foot-simple-classify"> <para>Il existe une cinquième coordonnée, plus rarement utilisée, appelée <varname>classifier</varname> dont nous parlerons plus tard dans le livre. Vous pouvez ignorer la coordonnée classifier pour l'instant.</para> </footnote>Dans dans tout système à coordonnées, les coordonnées Maven permettent de définir un point spécifique dans "l'espace": du global au local. Maven identifie un projet via ses coordonnées lorsqu'un projet est relié à un autre en tant que dépendance, plugin ou comme projet parent. Les coordonnées Maven sont souvent écrites en utilisant les deux points comme séparateur selon le format suivant: <code>groupId:artifactId:packaging:version</code>. Dans le fichier <filename>pom.xml</filename> ci-dessus, les coordonnées de notre projet sont les suivantes: <code>mavenbook:my-app:jar:1.0-SNAPSHOT</code>. Cette notation s'applique aussi pour les dépendances d'un projet, notre projet qui a besoin de la version 3.8.1 de JUnit, contient une dépendance à <varname>junit:</varname><varname>junit:</varname><varname>jar:</varname><varname>3.8.1</varname>. </para> <variablelist> <varlistentry><term><varname>groupId</varname></term> <listitem> <para>Le groupe, l'entreprise, l'équipe, l'oraganisation, le projet ou autre
<indexterm> <primary>groupId attribute (pom.xml)</primary> </indexterm> groupe. La convention pour les identifiants du groupe est qu'ils commencent par le nom de domaine inversé de l'organisation qui crée le projet. Les projets de Sonatype devrait avoir un <varname>groupId</varname> qui commence par <package>com.sonatype</package>, et les projets de l'Apache Software Foundation devraient avoir un <varname>groupId</varname> qui commence par <package>org.apache</package>. </para> </listitem> </varlistentry> <varlistentry><term><varname>artifactId</varname></term> <listitem> <para>IUn identifiant unique sous le <varname>groupId</varname> qui<indexterm> <primary>artifactId attribute (pom.xml)</primary> </indexterm> représente un projet unique. </para> </listitem> </varlistentry> <varlistentry><term><varname>version</varname></term> <listitem> <para>La version spécifique d'un projet. Lesprojets qui ont été <indexterm> <primary>version attribute (pom.xml)</primary> </indexterm> livrés ont un identifiant de version fixe qui fait référence à une version bien spécifique du projet. Les projects en cours de développement peuvent utiliser un identifiant de version qui indique que cette version n'est pas stable :<varname>SNAPSHOT</varname>.</para> </listitem> </varlistentry> </variablelist> <para>Le format de packaging est aussi un composant important des coordonnées Maven, mais il fait pas partie des identifiants uniques d'un projet. L'ensemble <varname>groupId:</varname><varname>artifactId:</varname><varname>version</varname> d'un projet identifie de manière unique un projet; vous ne pouvez pas avoir un projet avec les mêmes trois identifiants <varname>groupId</varname>, <varname>artifactId</varname>, et <varname>version</varname>. </para> <variablelist> <varlistentry><term><varname>packaging</varname></term> <listitem> <para>Le type du projet, <varname>jar</varname> par défaut,<indexterm> <primary>packaging attribute (pom.xml)</primary> </indexterm> décrit le résultat packagé produit par le projet. Un projet avec un packaging <varname>jar</varname> produit une archive <acronym>JAR</acronym>; un projet avec un packaging <varname>war</varname> produit, quant à lui, une application web.</para> </listitem> </varlistentry> </variablelist> <para>Ces quatres éléments sont la clef pour trouver et utiliser un projet particulier dans le vaste monde des projets "Mavenisés". Les dépôts Maven (publiques,<indexterm> <primary>repositories</primary> </indexterm><indexterm> <primary>Maven repositories</primary> </indexterm> privés, et locaux) sont organisés autour de ces identifiants. Lorsque ce projet est installé dans le dépôt Maven local, il devient immédiatement disponible pour tout autre projet qui voudrait l'utiliser. Tout ce que vous avez à faire est de l'ajouter comme dépendance à un autre projet <indexterm class="endofrange" startref="coord1"></indexterm><indexterm class="endofrange" startref="coord2"></indexterm> en utilisant les coordonnées Maven uniques pour un artéfact spécifique. </para> <para><figure><title>L'Espace Maven est un système de projets à coordonnées</title>  <mediaobject> <imageobject> <imagedata fileref="figs/web/simple-project_mavenspace.png"
                         width="6in" /> </imageobject> </mediaobject> </figure></para> </section> <section id="simple-project-section-simple-repo"><title>Les Dépôts Maven</title> <para>Lors de sa première exécution, vous allez vous apercevoir que Maven télécharge un grand nombre de fichiers depuis un dépôt Maven distant. Si vous exécutez Maven pour la première fois pour ce simple projet, la première chose qu'il va faire est de télécharger la dernière version du plugin Resources lorsqu'il va déclencher le goal <varname>resources:</varname><varname>resource</varname>. Avec Maven, artéfacts et plugins sont téléchargés depuis des dépôts distants au moment où on e a besoin. Une des raisons pour lesquelles Maven est si léger à télécharger (1.5 MiB) est que cette version initiale ne vient qu'avec très peu de plugins. Maven est livré avec le strict minimum et récupère de dépôts distants ce dont il a besoin quand il en a besoin. Maven est livré avec l'emplacement d'un dépôt distant par défaut (<ulink
      url="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</ulink>) qu'il utilise pour télécharger les principaux plugins et les dépendances Maven.</para> <para>Souvent vous aurez des projets qui dépendent de bibliothèques propriétaires ou non disponibles publiquement. Dans ce cas vous devrez installer votre propre dépôt au sein du réseau de votre organisation, ou télécharger et installer ces dépendances manuellement. Les déps distants par défaut peuvent être remplacés ou complétées par des références à des dépôts Maven personnalisés gérés par votre organisation. Il existe de nombreux produits sur le marché pour permettre à des organisations de gérer et maintenir des miroirs des dépôts Maven publiques.</para> <para>Qu'est ce qui fait d'un dépôt Maven un dépôt Maven? The Maven repository is defined by structure, a repository is a collection of project artifacts stored in a structure and format which can be easily understood by Maven. In a Maven repository everything is stored in a directory structure that closely matches a project's Maven coordinates. You can see this structure by opening up a web browser and browsing the central Maven repository at <ulink
      url="http://repo1.maven.org/maven2/">http://repo1.maven.org/maven2/</ulink>. You will see that an artifact with the coordinates <varname>org.</varname><varname>apache.commons:</varname><varname>commons-email:</varname><varname>1.1</varname> is available under the directory <filename>/org/apache/commons/commons-email/1.1/</filename> in a file named <filename>commons-email-1.1.jar</filename>. The standard for a Maven repository is to store an artifact in the following directory relative to the root of the repository: <screen>/&lt;<varname>groupId</varname>&gt;/&lt;<varname>artifactId</varname>&gt;/&lt;<varname>version</varname>&gt;/&lt;<varname>artifactId</varname>&gt;-&lt;version&gt;.&lt;<varname>packaging</varname>&gt;</screen></para> <para>Maven downloads artifacts and plugins from a remote repository to your local machine and stores these artifacts in your local Maven repository. Once Maven has downloaded an artifact from the remote Maven repository it never needs to download that artifact again as Maven will always look for the artifact in the local repository before looking elsewhere. On Windows XP, your local repository is likely in <filename>C:\Documents and Settings\USERNAME\.m2\repository</filename>, and on Windows Vista, your local repository is in <filename>C:\Users\USERNAME\.m2\repository</filename>. On Unix systems, your local Maven repository is available in <filename>~/.m2/repository</filename>. When you build a project like the simple project you created in the previous section, the <varname>install</varname> phase executes a goal which installs your project's artifacts in your local Maven repository.</para> <para>In your local repository, you should be able to see the artifact created by our simple project. If you run the <command>mvn
      install</command> command, Maven will install our project's artifact in your local repository. Try it. </para><screen>$ <command>mvn install</command>
...
[INFO] [install:install]
[INFO] Installing .../simple-1.0-SNAPSHOT.jar to \
       ~/.m2/repository/com/sonatype/maven/simple/1.0-SNAPSHOT/ \
       simple-1.0-SNAPSHOT.jar
...</screen> <para>As you can see from the output of this command, Maven installed our project's <acronym>JAR</acronym> file into our local Maven repository. Maven uses the local repository to share dependencies across local projects. If you develop two projects—project A and project B—with project B depending on the artifact produced by project A. Maven will retrieve project A's artifact from your local repository when it is building project B. Maven repositories are both a local cache of artifacts downloaded from a remote repository and a mechanism for allowing your projects to depend on each other. </para> </section> <section id="simple-project-sect-dep-management"><title>Maven's Dependency Management</title> <para>In this chapter's simple example, Maven resolved the coordinates of the JUnit dependency—<varname>junit:</varname><varname>junit:</varname><varname>3.8.1</varname>—to a path in a Maven repository <filename>/junit/junit/3.8.1/junit-3.8.1.jar</filename>. The ability to locate an artifact in a repository based on Maven coordinates gives us the ability to define dependencies in a project's <acronym>POM</acronym>. If you examine the simple project's <filename>pom.xml</filename> file, you will see that there is a section which deals with <sgmltag>dependencies</sgmltag>, and that this section contains a single dependency—JUnit.</para> <para>A more complex project would contain more than one dependency, or it might contain dependencies that depend on other artifacts. Support<indexterm> <primary>transitive dependencies</primary> <secondary>support for</secondary> </indexterm> for transitive dependencies is one of Maven’s most powerful features. Let’s say your project depends on a library that, in turn, depends on 5 or 10 other libraries (Spring or Hibernate, for example). Instead of having to track down all of these dependencies and list them in your <filename>pom.xml</filename> explicitly, you can simply depend on the library you are interested in and Maven will add the dependencies of this library to your project’s dependencies implicitly. Maven will also take care of working out conflicts between dependencies, and provides you with the ability to customize the default behavior and exclude certain transitive dependencies.</para> <para>Let's take a look at a dependency which was downloaded to your local repository when you ran the previous example. Look in your local repository path under <filename>~/.m2/repository/junit/junit/3.8.1/</filename>. If you have been following this chapter's examples, there will be a file named <filename>junit-3.8.1.jar</filename> and a <filename>junit-3.8.1.pom</filename> file in addition to a few checksum files which Maven uses to verify the authenticity of a downloaded artifact. Note that Maven doesn't just download the JUnit<acronym> JAR</acronym> file, Maven also downloads a <acronym>POM</acronym> file for the JUnit dependency. The fact that Maven downloads <acronym>POM</acronym> files in addition to artifacts is central to Maven's support for transitive dependencies.</para> <para>When you install your project’s artifact in the local repository, you will also notice that Maven publishes a slightly modified version of the project’s <filename>pom.xml</filename> file in the same directory as the <acronym>JAR</acronym> file. Storing a <acronym>POM</acronym> file in the repository gives other projects information about this project, most importantly what dependencies it has. If Project B depends on Project A, it also depends on Project A’s dependencies. When Maven resolves a dependency artifact from a set of Maven coordinates, it also retrieves the <acronym>POM</acronym> and consults the dependencies <acronym>POM</acronym> to find any transitive dependences. These transitive dependencies are then added as dependencies of the current project.</para> <para>A dependency in Maven isn’t just a <acronym>JAR</acronym> file; it’s a <acronym>POM</acronym> file that, in turn, may declare dependencies on other artifacts. These dependencies of dependencies are called transitive dependencies, and they are made possible by the fact that the Maven repository stores more than just bytecode; it stores metadata about artifacts. </para> <figure><title>Maven Resolves Transitive Dependencies</title> <mediaobject> <imageobject> <imagedata fileref="figs/web/simple-project_depgraph.png"
                       width="6in" /> </imageobject> </mediaobject> </figure> <para>In the previous figure, project A depends on projects B and C. Project B depends on project D, and project C depends on project E. The full set of direct and transitive dependencies for project A would be projects B, C, D, and E, but all project A had to do was define a dependency on B and C. Transitive dependencies can come in handy when your project relies on other projects with several small dependencies (like Hibernate, Apache Struts, or the Spring Framework). Maven also provides you with the ability to exclude transitive dependencies from being included in a project's classpath.</para> <para>Maven also provides for different dependency scopes. The simple<indexterm> <primary>scope, dependency</primary> </indexterm> project’s <filename>pom.xml</filename> contains a single dependency—<varname>junit:</varname><varname>junit:</varname><varname>jar:</varname><varname>3.8.1</varname>—with a scope of <varname>test</varname>. When a dependency has a scope of <varname>test</varname>, it will not be available to the <varname>compile</varname> goal of the Compiler plugin. It will be added to the classpath for only the <varname>compiler:</varname><varname>testCompile</varname> and <varname>surefire:</varname><varname>test</varname> goals.</para> <para>When you create a <acronym>JAR</acronym> for a project, dependencies are not bundled with the generated artifact; they are used only for compilation. When you use Maven to create a <acronym>WAR</acronym> or an <acronym>EAR</acronym> file, you can configure Maven to bundle dependencies with the generated artifact, and you can also configure it to exclude certain dependencies from the <acronym>WAR</acronym> file using the <varname>provided</varname> scope. The <varname>provided</varname> scope tells Maven that a dependency is needed for compilation, but should not be bundled with the output of a build. This scope comes in handy when you are developing a web application. You’ll need to compile your code against the Servlet specification, but you don’t want to include the Servlet <acronym>API</acronym> <acronym>JAR</acronym> in your web application’s <filename>WEB-INF/lib</filename> directory. </para> </section> <section id="simple-project-sect-site-generation"><title>Site Generation and Reporting</title> <para>Another important feature of Maven is its ability to generate<indexterm> <primary>documentation generation</primary> </indexterm><indexterm> <primary>site generation</primary> </indexterm><indexterm> <primary>report generation</primary> </indexterm><indexterm> <primary>site lifecycle phase</primary> </indexterm> documentation and reports. In your simple project’s directory, execute the following command: </para><screen>$ <command>mvn site</command>
</screen> <para>This will execute the <varname>site</varname> lifecycle phase. Unlike the default build lifecycle that manages generation of code, manipulation of resources, compilation, packaging, etc., this lifecycle is concerned solely with processing site content under the <filename>src/site</filename> directories and generating reports. After this command executes, you should see a project web site in the <filename>target/site</filename> directory. Load <filename>target/site/index.html</filename> and you should see a basic shell of a project site. This shell contains some reports under “Project Reports” in the lefthand navigation menu, and it also contains information about the project, the dependencies, and developers associated with it under “Project Information.” The simple project’s web site is mostly empty, since the <acronym>POM</acronym> contains very little information about itself beyond a coordinate, a name, a <acronym>URL</acronym>, and a single test dependency.</para> <para>On this site, you’ll notice that some default reports are available. A unit test report communicates the success and failure of all unit tests in the project. Another report generates Javadoc for the project’s <acronym>API</acronym>. Maven provides a full range of configurable reports, such as the Clover report that examines unit test coverage, the <acronym>JXR</acronym> report that generates cross-referenced <acronym>HTML</acronym> source code listings useful for code reviews, the <acronym>PMD</acronym> report that analyzes source code for various coding problems, and the JDepend report that analyzes the dependencies between packages in a codebase. You can customize site reports by configuring which reports are included in a build via the <filename>pom.xml</filename> file. </para> </section> </section> <section id="simple-project-sect-summary"><title>Summary</title> <para>In this chapter, we have created a simple project, packaged the project into a JAR file, installed that JAR into the Maven repository for use by other projects, and generated a site with documentation. We accomplished this without writing a single line of code or touching a single configuration file. We also took some time to develop definitions for some of the core concepts of Maven. In the next chapter, we’ll start customizing and modifying our project <filename>pom.xml</filename> file to add dependencies and configure unit tests.</para> </section>
</chapter>
