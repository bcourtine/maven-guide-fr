<?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="simple-project"><title>Mon Premier Projet avec Maven</title>  <section id="simple-project-sect-intro"><title>Introduction</title> <para>Dans ce chapitre, nous introduisons un projet simple créé à partir de rien en utilisant le plugin Maven Archetype. Cette application basique va nous fournir l'occasion de discuter certains des concepts au coeur de Maven tout en suivant le développement du projet.</para> <para>Avant de se lancer dans l'utilisation de Maven sur des builds complexes avec plusieurs modules, nous allons commencer par les bases. Si vous avez déjà utilisé Maven auparavant, vous noterez qui fait bien son travail en s'occupant des détails. Vos builds tendent à "fonctionner correctement", et vous n'avez à vous plonger dans les détails de Maven que lorsque vous voulez personnaliser un comportement par défaut ou écrire votre propre plugin. Cependant, quand vous devez vous plonger dans ces détails, une bonne compéhension des concepts principaux est essentielle. Ce chapitre a pour but de vous présenter le projet Maven le plus simple possible puis vous montrer les concepts principaux de Maven qui en font une solide plateforme de build. Une fois que vous l'aurez lu, vous aurez une compréhension fondamentale du cycle de vie du build, des dépôts Maven et du Project Object Model (<acronym>POM</acronym>). </para> <section id="simple-project-sect-downloading-example"><title>Télécharger l'Exemple de ce Chapitre</title> <para>Ce chapitre développe un exemple très simple qui sera utilisé pour explorer les concepts principaux de Maven. Si vous suivez les étapes décrites dans ce chapitre, vous ne devriez pas avoir besoin de télécharger les exemples pour recréer le code produit par Maven. Nous allons utiliser le plugin Maven Archetype pour créer ce simple projet que ce chapitre ne modifie en rien. Si vous préferrez lire ce chapitre avec le code source final de l'exemple, le projet qui sert d'exemple dans ce chapitre peut être téléchargé avec le code source des exemples du livre depuis <ulink
      url="http://www.sonatype.com/book/mvn-examples-1.0.zip">http://www.sonatype.com/book/mvn-examples-1.0.zip</ulink> ou <ulink
      url="http://www.sonatype.com/book/mvn-examples-1.0.tar.gz">http://www.sonatype.com/book/mvn-examples-1.0.tar.gz</ulink>. Décompressez cette archive dans n'importe quel répertoire, puis allez dans le répertoire <filename>ch03/</filename>. Dans le répertoire<filename>ch03/</filename> vous trouverez un répertoire <filename>simple/</filename> qui contient le code source de ce chapitre. Si vous souhaitez suivre avec le code de cet exemple dans un navigateur web, allez à <ulink
      url="http://www.sonatype.com/book/examples-1.0">http://www.sonatype.com/book/examples-1.0</ulink> et cliquez sur le répertoire <filename>ch03/</filename>. </para> </section> </section> <section id="simple-project-sect-create-simple"><title>Création d'un Simple Projet</title> <para>Pour commencer un nouveau projet Maven, utilisez le plugin Maven Archetype plugin depuis la ligne de commande. </para><screen><command>$ mvn archetype:create -DgroupId=org.sonatype.mavenbook.ch03 \
                                         -DartifactId=simple \
                                         -DpackageName=org.sonatype.mavenbook
</command>[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'archetype'.               
[INFO] artifact org.apache.maven.plugins:maven-archetype-plugin: checking for 
       updates from central
[INFO] -----------------------------------------------------------------------
[INFO] Building Maven Default Project
[INFO]    task-segment: [archetype:create] (aggregator-style)
[INFO] --------------------------------------------------------------------
[INFO] [archetype:create]
[INFO] artifact org.apache.maven.archetypes:maven-archetype-quickstart: \
       checking for updates from central
[INFO] Parameter: groupId, Value: org.sonatype.mavenbook.ch03
[INFO] Parameter: packageName, Value: org.sonatype.mavenbook
[INFO] Parameter: basedir, Value: /Users/tobrien/svnw/sonatype/examples
[INFO] Parameter: package, Value: org.sonatype.mavenbook
[INFO] Parameter: version, Value: 1.0-SNAPSHOT
[INFO] Parameter: artifactId, Value: simple
[INFO] * End of debug info from resources from generated POM *
[INFO] Archetype created in dir: /Users/tobrien/svnw/sonatype/examples/simple
</screen> <para><command>mvn</command> c'est l'instruction pour Maven 2. <varname>archetype:</varname><varname>create</varname> est un goal Maven. Si vous connaissez <indexterm> <primary>goals</primary> <secondary>à propos</secondary> </indexterm><indexterm> <primary>Maven goals, à propos</primary> </indexterm><indexterm> <primary>parent POM</primary> <seealso>POM</seealso> </indexterm><indexterm> <primary>racine POM</primary> <seealso>POM</seealso> </indexterm> Apache Ant, un goal Maven est analogue à une target Ant; tous les deux décrivent une unité de tâche à accomplir lors d'un build. La paire <varname>-Dname=value</varname> représente un argument passé au goal sous la forme de propriétés <varname>-D</varname>, comme pour les propriétés système que vous pourriez passer à la Machine Virtuelle Java via la ligne de commande. Le but du goal <varname>archetype:</varname><varname>create</varname> est de créé rapidement un projet à partir d'un archétype. Dans ce contexte, un<indexterm> <primary sortas="archetypes">archétypes, definition</primary> </indexterm> archétype se défini comme " un  modèle original ou idéal d'après lequel sont bâtis un ouvrage, une ɶuvre; un prototype."<footnote
        id="foot-archetype-def"> <para><emphasis>Selon l'American Heritage Dictionary of the English Language</emphasis>. </para> </footnote>Il existe un grand nombre d'archétypes disponibles pour Maven, depuis une application Swing simplr jusqu'à une application web complexe. Dans ce chapitre, nous allons utiliser l'archétype le plus basique pour créer un simple squelette projet de démarrage. Le préfixe <literal>archetype</literal> correspond au plugin, et <literal>create</literal> correspond au goal.</para> <para>Une fois ce projet généré, allons regarder la structure de répertoire Maven qui a été créée sous le répertoire simple. </para><screen>simple/
<co id="coDef-simple-fs-root"
        linkends="coRef-simple-fs-root" />simple/pom.xml <co id="coDef-simple-fs-pom" linkends="coRef-simple-fs-pom" />/src/ /src/main/ <co id="coDef-simple-fs-main" linkends="coRef-simple-fs-main" />/main/java /src/test/ <co id="coDef-simple-fs-test" linkends="coRef-simple-fs-test" />/test/java</screen> <para>Ce répertoire suit les recommandations pour le Standard Maven de Disposition des Répertoires<indexterm> <primary>Standard Directory Layout</primary> </indexterm><indexterm> <primary>Maven Standard Directory Layout</primary> </indexterm>. Nous détaillerons cela plus tard dans ce chapitre, pour l'instant essayons de comprendre ces quelques <phrase role="keep-together">répertoires</phrase>:</para> <calloutlist> <callout arearefs="coDef-simple-fs-root" id="coRef-simple-fs-root"> <para>Le plugin Maven Archetype crée un répertoire dont le nom correspond à l'<varname>artifactId</varname>. Simple. C'est ce qu'on appele le répertoire racine <indexterm> <primary>base directory</primary> </indexterm> du projet.</para> </callout> <callout arearefs="coDef-simple-fs-pom" id="coRef-simple-fs-pom"> <para>Chaque projet Maven possède ce qu'on appele un Project Object Model (<acronym>POM</acronym>) dans un fichier <filename>pom.xml</filename>. Ce fichier décrit le projet, configure les plugins, et déclare les dépendances.</para> </callout> <callout arearefs="coDef-simple-fs-main" id="coRef-simple-fs-main"> <para>Les sources et les ressources de notre projet se retrouvent sous le répertoire <filename>src/main</filename>. Dans le cas de notre simple projet Java cela consistera en quelques classes Java et fichiers de propriétés. Pour un autre projet, on pourrait y trouver le répertoire racine d'une application web ou les fichiers de configuration d'un serveur d'application. Dans un projet Java, les classes Java sont dans <filename>src/main/java</filename> et les ressources disponibles dans le classpath vont dans <filename>src/main/resources</filename>.</para> </callout> <callout arearefs="coDef-simple-fs-test" id="coRef-simple-fs-test"> <para>Les tests de notre pojet vont dans <filename>src/test</filename>. Dans ce réperoire, les classes Java, comme par exemple les tests JUnit ou TestNG, sont dans <filename>src/test/java</filename>, et les ressources du classpath pour les tests vont dans <filename>src/test/resources</filename>.</para> </callout> </calloutlist> <para>Le plugin Maven Archetype a produit une classe unique <classname>org.sonatype.mavenbook.</classname><classname>App</classname>, qui contient 13 lignes de Java avec une fonction static main qui affiche le message: </para><programlisting language="java">package org.sonatype.mavenbook;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        System.out.println( "Hello World!" );
    }
}
</programlisting> <para>Le plus simple des archétypes Maven produit le programme le plus simple possible: un programme qui affiche "Hello World!" sur la sortie standard. </para> </section> <section id="simple-project-sect-building-simple"><title>Construire un Simple Project</title> <para>Une fois le projet créé grâce au plugin Maven Archetype suivant les instructions de la section précédente (<xref linkend="simple-project-sect-create-simple" />) il faut maintenant construire et  packager l'application. Afin d'y parvenir, exécutez <command>mvn install</command> depuis<indexterm> <primary>mvn install command</primary> </indexterm><indexterm> <primary>building applications</primary> </indexterm><indexterm> <primary>packaging applications</primary> </indexterm><indexterm> <primary>applications, building and packaging</primary> </indexterm> le répertoire qui contient le <filename>pom.xml</filename>: </para><screen><command>$ mvn install
</command>[INFO] Scanning for projects...
[INFO] ----------------------------------------------------------------------
[INFO] Building simple
[INFO]    task-segment: [install]
[INFO] ----------------------------------------------------------------------
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Compiling 1 source file to /simple/target/classes
[INFO] [resources:testResources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:testCompile]
[INFO] Compiling 1 source file to /simple/target/test-classes
[INFO] [surefire:test]
[INFO] Surefire report directory: /simple/target/surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running org.sonatype.mavenbook.AppTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.105 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO] [jar:jar]
[INFO] Building jar: /simple/target/simple-1.0-SNAPSHOT.jar
[INFO] [install:install]
[INFO] Installing /simple/target/simple-1.0-SNAPSHOT.jar to \
  ~/.m2/repository/com/sonatype/maven/ch03/simple/1.0-SNAPSHOT/ \
  simple-1.0-SNAPSHOT.jar
</screen> <para>Vous venez juste de créer, compiler, tester, packager et installer le projet Maven le plus simple possible. Pour vous prouvez que ce programme fonctionne, exécutez le depuis la ligne de commande. </para><screen><command>$ java -cp target/simple-1.0-SNAPSHOT.jar org.sonatype.mavenbook.App
</command>Hello World!
</screen>  </section> <section id="simple-project-sect-pom"><title>Simple Project Object Model</title> <para>Lors de son exécution Maven lit dans le Project Object Model <indexterm> <primary>POM (Project Object Model)</primary> </indexterm><indexterm> <primary>Project Object Model</primary> <see>POM; pom.xml file</see> </indexterm><indexterm> <primary>pom.xml file</primary> </indexterm> les informations sur le projet. Le <acronym>POM</acronym> répond aux questions telles que: De quel type de projet s'agit il ? Quel est le nom du projet? Ce projet a t il été personnalisé? <xref linkend="example_simple-project-pom" /> montre le fichier <filename>pom.xml</filename> par défaut créé par le goal create du plugin Maven Archetype. </para> <example id="example_simple-project-pom"><title>Simple project's <filename>pom.xml</filename> file</title> <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.ch03&lt;/groupId&gt;
  &lt;artifactId&gt;simple&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;name&gt;simple&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting> </example> <para>Ce fichier <filename>pom.xml</filename> est le plus basique <acronym>POM</acronym> que vous rencontrerez dans un projet Maven, la plupart du temps un fichier<acronym>POM</acronym> fest considérablement plus complexe: il définit de nombreuses dépendances et personnalise le comportement des plugins. Les premiers éléments&mdash;<sgmltag>groupId</sgmltag>, <sgmltag>artifactId</sgmltag>, <sgmltag>packaging</sgmltag>, <sgmltag>version</sgmltag>&mdash;sont ce qu'on appele les coordonnées Maven qui identifient de manière unique un projet. <sgmltag>name</sgmltag> et <sgmltag>url</sgmltag> sont des éléments descriptifs du  <acronym>POM</acronym> donnant un nom compréhensible par un être humain et associant le projet à un site web. L'élément <sgmltag>dependencies</sgmltag> définit une dépendance unique, dans le scope test, sur un framework de test appelé JUnit. Nous reverons ces sujets par la suite dans <xref linkend="simple-project-sect-simple-core" />, tout ce que vous devez savoir, en ce moment, c'est le que le <filename>pom.xml</filename> est le fichier qui permet l'exécution de Maven.</para> <para>Maven s'exécute toujours selon un <acronym>POM</acronym> effectif, une combinaison de la configuration du <filename>pom.xml</filename> de ce projet, de l'ensemble des  <acronym>POM</acronym>s parent, d'un super-<acronym>POM</acronym> défini dans Maven, de la configuration de l'utilisateur, et des profils actifs. Tous les projets étendent au final le super-<acronym>POM</acronym>,qui définit une configuration par défaut raisonnable et qui est compètement expliqué dans <xref linkend="pom-relationships" />. Même si votre projet a un <filename>pom.xml</filename> minimal, le contenu du <acronym>POM</acronym> de votre projet est interpolé à partir des conenus des <acronym>POM</acronym>s parent, de la configuration de ul'tilisateur, et de tout profil actif. Pour voir ce <acronym>POM</acronym>  "effectif", exécutez la commande suivante depuis le répertoire racine de votre simple projet. </para><screen>$ <command>mvn help:effective-pom</command></screen> <para>Lorsque vous exécutez cette commande, vous pouvez voir un <acronym>POM</acronym> nettement plus consistent qui montre la configuration par défaut de Maven. Ce goal devient vite pratique lorsque vous essayez de débugger un build et que vous voulez voir comment les POMs des parents de ce projet contribuent au POM effectif. Pour plus d'informations sur le plugin Maven Help, regardez <xref linkend="installation-sect-help-plugin-install" />. </para> </section> <section id="simple-project-sect-simple-core"><title>Les Principaux Concepts</title> <para>Maintenant que nous avons exécuté Maven pour la première fois, il est temps de s'intéresser aux  concepts qui sont au coeur de Maven. Dans l'exemple précédent, vous avez généré un projet qui consistait en un <acronym>POM</acronym> et un peu de code respectant la disposition Maven standard des répertoires. Puis vous exécutez Maven en lui passant une phase de son cycle de vie ce qui a demandé à Maven d'exécuter toute une série de goals de plugins Maven. Enfin, vous avez installé l'artéfact Maven dans votre dépôt local. Une minute? Qu'est ce que le "cycle de vie"? Qu'est donc un "dépôt local"? La section qui suit définit certains des concepts centraux de Maven. </para> <section id="simple-project-sect-plugins-goals"><title>Plugins Maven Plugins et Goals</title> <para>Dans la section précédente, nous avons exécuté Maven  en ligne de commande avec deux types d'<indexterm> <primary>Maven plugins</primary> <see>plugins</see> </indexterm><indexterm> <primary>goals</primary> <seealso>plugins</seealso> </indexterm> command-line <phrase role="keep-together">arguments</phrase> différents. La première commande appelait un unique goal d'un plugin, le goal <varname>create</varname> du plugin Archetype. La deuxième exécutionde Maven était une phase du cycle de vie, <varname>install</varname>. Pour<indexterm> <primary>executing goals</primary> </indexterm><indexterm> <primary>executing goals</primary> <seealso>goals</seealso> </indexterm> exécuter un unique goal d'un plugin Maven, nous avons utilisé la syntaxe <command>mvn archetype:create</command>, où <varname>archetype</varname> est l'identifiant du plugin et <varname>create</varname> l'identifiant du goal. Lorsque Maven exécute le goal d'un plugin, il affiche l'identifiant du plugin et l'identifiant du goal sur la sortie standard: </para><screen><command>$ mvn archetype:create -DgroupId=org.sonatype.mavenbook.ch03 \
                                        -DartifactId=simple \
                                        -DpackageName=org.sonatype.mavenbook
</command>...
<emphasis>[INFO] [archetype:create]</emphasis>
[INFO] artifact org.apache.maven.archetypes:maven-archetype-quickstart: \
       checking for updates from central
...
</screen> <para>Un Plugin Maven se compose de un ou plusieurs goals. On peut prendre comme exemples de plugins Maven, de simples plugins qui composent le ceur de Maven comme le plugin Jar qui possède les goals pour créer des fichiers <acronym>JAR</acronym> files, le plugin Compiler qui lui possède les goals pour compiler le code source et le code des tests unitaires, ou le plugin Surefire dont les goals permettent l'exécution des tests unitaires et la production des rapports. On trouve aussi d'autres plugins, plus spécialisés, comme le plugin Hibernate3 pour l'intégration de la bibliothèque très connue de persitence Hibernate, le plugin JRuby qui permet l'exécution de code Ruby durant un build Maven ou l'écriture de plugins Maven en Ruby. Maven permet aussi de définir ses propres plugins. Vous pouvez écrire votre propre plugin en Java ou dans de nombreux autres langages dont Ant, Groovu, Beanshell et, comme indiqué plus haut, Ruby. </para> <figure><title>Un Plugin Possède des Goals</title> <mediaobject> <imageobject> <imagedata fileref="figs/web/simple-project_plugin.png"
                       width="5in" /> </imageobject> </mediaobject> </figure> <para>Un goal est une tâche spécifique qui peut être exécuté individuellement <indexterm> <primary>goals</primary> <secondary>defined</secondary> </indexterm> ou combiné à d'autres goals pour un build plus large. Un goal est une "tâche unitaire" dans Maven. On peut prendre comme exemples de goals le goal <varname>compile</varname> du plugin Compiler, qui compile tout le code source du projet, ou le goal <varname>test</varname> du plugin Surefire, qui exécute les tests unitaires. La configuration des goals se fait au travers de propriétés qui sont utilisées pour personnaliser le comportement. Par exemple, le goal <varname>compile</varname> du plugin Compiler définit un ensemble de <phrase role="keep-together">paramètres</phrase> de configuration qui vous permettent de préciser la version du JDK cible ou les options d'optimisation du compilateur. In the previous example, we passed in the configuration parameters <varname>groupId</varname> and <varname>artifactId</varname> to the <varname>create</varname> goal of the Archetype plugin via the command-line parameters <command>-DgroupId=org.sonatype.mavenbook.ch03</command> and <command>-DartifactId=simple</command>. We <phrase role="keep-together">also</phrase> passed the <varname>packageName</varname> parameter to the <literal>create</literal> goal as <package>org.sonatype.mavenbook</package>. If we had omitted the <varname>packageName</varname> parameter, the package name would have defaulted to <package>org.sonatype.mavenbook.ch03</package>.</para> <para><note> <para>When referring to a plugin goal, we frequently use the shorthand notation: <replaceable>pluginId</replaceable><literal>:</literal><replaceable>goalId</replaceable>. For example, when referring to the <literal>create</literal> goal in the Archetype plugin, we write <varname>archetype:</varname><varname>create</varname>.</para> </note></para> <para>Goals define parameters that can define sensible default values. In the <varname>archetype:</varname><varname>create</varname> example, we did not specify what kind of archetype the goal was to create on our command line; we simply passed in a <varname>groupId</varname> and an <varname>artifactId</varname>. This is our first brush with<indexterm> <primary>convention over configuration</primary> </indexterm> <emphasis>convention over configuration</emphasis>. The convention, or default, for the <varname>create</varname> goal is to create a simple project called Quickstart. The <varname>create</varname> goal defines a configuration property <varname>archetypeArtifactId</varname> that has a default value of <varname>maven-archetype-</varname><varname>quickstart</varname>. The Quickstart archetype generates a minimal project shell that contains a <acronym>POM</acronym> and a single class. The Archetype plugin is far more powerful than this first example suggests, but it is a great way to get new projects started fast. Later in this book, we’ll show you how the Archetype plugin can be used to generate more complex projects such as web applications, and how you can use the Archetype plugin to define your own set of projects.</para> <para>The core of Maven has little to do with the specific tasks involved in your project’s build. By itself, Maven doesn’t know how to compile your code or even how to make a <acronym>JAR</acronym> file. It delegates all of this work to Maven plugins like the Compiler plugin and the Jar plugin, which are downloaded on an as-needed basis and periodically updated from the central Maven repository. When you download Maven, you are getting the core of Maven, which consists of a very basic shell that knows only how to parse the command line, manage a classpath, parse a <acronym>POM</acronym> file, and download Maven plugins as needed. By keeping the Compiler plugin separate from Maven’s core and providing for an update mechanism, Maven makes it easier for users to have access to the latest options in the compiler. In this way, Maven plugins allow for universal reusability of common build logic. You are not defining the compile task in a build file; you are using a Compiler plugin that is shared by every user of Maven. If there is an improvement to the Compiler plugin, every project that uses Maven can immediately benefit from this change. (And, if you don’t like the Compiler plugin, you can override it with your own implementation.) </para> </section> <section id="simple-project-sect-lifecycle"><title>Maven Lifecycle</title> <para>The second command we ran in the previous section<indexterm> <primary>Maven lifecycle</primary> <see>build lifecycle</see> </indexterm><indexterm> <primary>lifecycle, Maven</primary> <see>build lifecycle</see> </indexterm><indexterm class="startofrange" id="buildlife"> <primary>build lifecycle</primary> </indexterm><indexterm> <primary>phases, lifecycle</primary> <see>build lifecycle</see> </indexterm> was <command>mvn install</command>. This command didn’t specify a plugin goal; instead, it specified a Maven lifecycle phase. A phase is a step in what Maven calls the “build lifecycle.” The build lifecycle is an ordered sequence of phases involved in building a project. Maven can support a number of different lifecycles, but the one that’s most often used is the default<indexterm> <primary>default Maven lifecycle</primary> </indexterm><indexterm> <primary>build lifecycle</primary> <secondary>default Maven lifecycle</secondary> </indexterm> Maven lifecycle, which begins with a phase to validate the basic integrity of the project and ends with a phase that involves deploying a project to production. Lifecycle phases are intentionally vague, defined solely as validation, testing, or deployment, and they may mean different things to different projects. For example, the <varname>package</varname> phase in a project that produces a <acronym>JAR</acronym>, means “package this project into a JAR”; in a project that produces a web application, the <varname>package</varname> phase may produce a <acronym>WAR</acronym> file.</para> <para>Plugin goals can be attached<indexterm> <primary>plugin goals</primary> <see>goals</see> </indexterm><indexterm> <primary>goals</primary> <secondary>attaching to lifecycle phases</secondary> </indexterm> to a lifecycle phase. As Maven moves through the phases in a lifecycle, it will execute the goals attached to each particular phase. Each phase may have zero or more goals bound to it. In the previous section, when you ran <command>mvn install</command>, you might have noticed that more than one goal was executed. Examine the output after running <command>mvn install</command> and take note of the various goals that are executed. When this simple example reached the <varname>package</varname> phase, it executed the <varname>jar</varname> goal in the Jar plugin. Since our simple Quickstart project has (by default) a <varname>jar</varname> packaging type, the <varname>jar:</varname><varname>jar</varname> goal is bound to the <varname>package</varname> phase. </para> <para><figure><title>A Goal Binds to a Phase</title> <mediaobject> <imageobject> <imagedata fileref="figs/web/simple-project_phasebinding.png" /> </imageobject> </mediaobject> </figure></para> <para>We know that the <varname>package</varname> phase is going to create a <acronym>JAR</acronym> file for a project with <varname>jar</varname> packaging. But what of the goals preceding it, such as <varname>compiler:</varname><varname>compile</varname> and <varname
      role="keep-together">surefire:</varname><varname
      role="keep-together">test</varname>? These goals are executed as Maven steps through the phases preceding <varname>package</varname> in the<indexterm> <primary>executing lifecycle phases</primary> </indexterm> Maven lifecycle; executing a phase will first execute all preceding phases in order, ending with the phase specified on the command line. Each phase corresponds to zero or more goals, and since we haven’t performed any plugin configuration or customization, this example binds a set of standard plugin goals to the default lifecycle. The following goals are executed in order when Maven walks through the default lifecycle ending with <varname>package</varname>: </para> <variablelist> <varlistentry><term><varname>resources:resources</varname></term> <listitem> <para>The <varname>resources</varname> goal of the Resources<indexterm> <primary>Resources plugin</primary> <secondary>resources goal</secondary> </indexterm> plugin is bound to the <varname>process-resources</varname> phase. This goal copies all of the resources from <filename>src/main/resources</filename> and any other configured resource directories to the output directory. </para> </listitem> </varlistentry> <varlistentry><term><varname>compiler:compile</varname></term> <listitem> <para>The <varname>compile</varname> goal of the Compiler plugin<indexterm> <primary>compile:compile goal</primary> </indexterm><indexterm> <primary>Compiler plugin</primary> <secondary>compile goal</secondary> </indexterm> is bound to the <varname>compile</varname> phase. This goal compiles all of the source code from <filename>src/main/java</filename> or any other configured source directories to the output directory. </para> </listitem> </varlistentry> <varlistentry><term><varname>resources:testResources</varname></term> <listitem> <para>The <varname>testResources</varname> goal of the Resources<indexterm> <primary>Resources plugin</primary> <secondary>testResources goal</secondary> </indexterm> plugin is bound to the <varname>process-test-resources</varname> phase. This goal copies all of the resources from <filename>src/test/resources</filename> and any other configured test resource directories to a test output directory. </para> </listitem> </varlistentry> <varlistentry><term><varname>compiler:testCompile</varname></term> <listitem> <para>The <varname>testCompile</varname> goal of the Compiler<indexterm> <primary>Compiler plugin</primary> <secondary>testCompile goal</secondary> </indexterm> plugin is bound to the <varname>test-compile</varname> phase. This goal compiles test cases from <filename>src/test/java</filename> and any other configured test source directories to a test output directory. </para> </listitem> </varlistentry> <varlistentry><term><varname>surefire:test</varname></term> <listitem> <para>The <varname>test</varname> goal of the Surefire plugin is<indexterm> <primary>Surefire plugin</primary> <secondary>test goal</secondary> </indexterm><indexterm> <primary>Maven Surefire plugin</primary> <secondary>test goal</secondary> </indexterm><indexterm> <primary>testing</primary> <secondary>Surefire:test goal</secondary> </indexterm> bound to the <varname>test</varname> phase. This goal executes all of the tests and creates output files that capture detailed results. By default, this goal will terminate a build if there is a test failure. </para> </listitem> </varlistentry> <varlistentry><term><varname>jar:jar</varname></term> <listitem> <para>The <varname>jar</varname> goal of the Jar plugin is bound<indexterm> <primary>jar:jar goal</primary> </indexterm> to the <varname>package</varname> phase. This goal packages the output directory into a JAR file. </para> </listitem> </varlistentry> </variablelist> <para><figure><title>Bound Goals are Run when Their Phases Execute</title> <mediaobject> <imageobject> <imagedata fileref="figs/web/simple-project_lifecyclebinding.png" /> </imageobject> </mediaobject> </figure></para> <para>To summarize, when we executed <command>mvn install</command>, Maven executes all phases up to the install phase, and in the process of stepping through the life cycle phases it executes all goals bound to each phase. Instead of executing a Maven lifecycle goal you could achieve the same results by specifying a sequence of plugin goals as follows: </para><screen><command>mvn resources:resources \
    compiler:compile \
    resources:testResources \
    compiler:testCompile \
    surefire:test \
    jar:jar \
    install:install</command> 
</screen> <para>It is much easier to execute lifecycle phases that it is to specify explicit goals on the command line, and the common lifecycle allows every project that uses Maven to adhere to a well-defined set of standards. The lifecycle is what allows a developer to jump from one Maven project to another without having to know very much about the details of each particular project's build. If you can build one Maven project, you can build them all. </para> </section> <section id="simple-project-sect-maven-coordinates"><title>Maven Coordinates</title> <para>The Archetype plugin created a project with a file named<indexterm class="startofrange" id="coord1"> <primary>Maven coordinates</primary> </indexterm><indexterm class="startofrange" id="coord2"> <primary>coordinates</primary> </indexterm> <filename>pom.xml</filename>. This is the Project Object Model (<acronym>POM</acronym>), a declarative description of a project. When Maven executes a goal, each goal has access to the information defined in a project’s <acronym>POM</acronym>. When the <varname>jar:</varname><varname>jar</varname> goal needs to create a <acronym>JAR</acronym> file, it looks to the <acronym>POM</acronym> to find out what the JAR file’s name is. When the <varname>compiler:</varname><varname>compile</varname> task compiles Java source code into bytecode, it looks to the <acronym>POM</acronym> to see if there are any parameters for the compile goal. Goals execute in the context of a <acronym>POM</acronym>. Goals are actions we wish to take upon a project, and a project is defined by a <acronym>POM</acronym>. The <acronym>POM</acronym> names the project, provides a set of unique identifiers (coordinates) for a project, and defines the relationships between this project and others through dependencies, parents, and prerequisites. A <acronym>POM</acronym> can also customize plugin behavior and supply information about the community and developers involved in a project.</para> <para>Maven Coordinates define a set of identifiers which can be used to uniquely identify a project, a dependency, or a plugin in a Maven <acronym>POM</acronym>. Take a look at the following <acronym>POM</acronym>. </para> <para><figure><title>A Maven Project's Coordinates</title> <mediaobject> <imageobject> <imagedata fileref="figs/web/simple-project_annopom.png"
                         width="6in" /> </imageobject> </mediaobject> </figure></para> <para>We've highlighted the Maven coordinates for this project: the <varname>groupId</varname>, <varname>artifactId</varname>, <varname>version</varname> and <varname>packaging</varname>. These combined identifiers make up a project's coordinates.<footnote
          id="foot-simple-classify"> <para>There is a fifth, seldom-used coordinate named <varname>classifier</varname> which we will introduce later in the book. You can feel free to ignore classifiers for now.</para> </footnote>Just like in any other coordinate system, a Maven coordinate is an address for a specific point in "space": from general to specific. Maven pinpoints a project via its coordinates when one project relates to another, either as a dependency, a plugin, or a parent project reference. Maven coordinates are often written using a colon as a delimiter in the following format: <code>groupId:artifactId:packaging:version</code>. In the above <filename>pom.xml</filename> file for our current project, its coordinate is represented as <code>mavenbook:my-app:jar:1.0-SNAPSHOT</code>. This notation also applies to project dependencies, our project relies on JUnit version 3.8.1, it contains a dependency on <varname>junit:</varname><varname>junit:</varname><varname>jar:</varname><varname>3.8.1</varname>. </para> <variablelist> <varlistentry><term><varname>groupId</varname></term> <listitem> <para>The group, company, team, organization, project, or other<indexterm> <primary>groupId attribute (pom.xml)</primary> </indexterm> group. The convention for group identifiers is that they begin with the reverse domain name of the organization that creates the project. Projects from Sonatype would have a <varname>groupId</varname> that begins with <package>com.sonatype</package>, and projects in the Apache Software Foundation would have a <varname>groupId</varname> that starts with <package>org.apache</package>. </para> </listitem> </varlistentry> <varlistentry><term><varname>artifactId</varname></term> <listitem> <para>A unique identifier under <varname>groupId</varname> that<indexterm> <primary>artifactId attribute (pom.xml)</primary> </indexterm> represents a single project. </para> </listitem> </varlistentry> <varlistentry><term><varname>version</varname></term> <listitem> <para>A specific release of a project. Projects that have been<indexterm> <primary>version attribute (pom.xml)</primary> </indexterm> released have a fixed version identifier that refers to a specific version of the project. Projects undergoing active development can use a special identifier that marks a version as a <varname>SNAPSHOT</varname>.</para> </listitem> </varlistentry> </variablelist> <para>The packaging format of a project is also an important component in the Maven coordinates, but it isn't a part of a project's unique identifier. A project's <varname>groupId:</varname><varname>artifactId:</varname><varname>version</varname> make that project unique; you can't have a project with the same three <varname>groupId</varname>, <varname>artifactId</varname>, and <varname>version</varname> identifiers. </para> <variablelist> <varlistentry><term><varname>packaging</varname></term> <listitem> <para>The type of project, defaulting to <varname>jar</varname>,<indexterm> <primary>packaging attribute (pom.xml)</primary> </indexterm> describing the packaged output produced by a project. A project with packaging <varname>jar</varname> produces a <acronym>JAR</acronym> archive; a project with packaging <varname>war</varname> produces a web application.</para> </listitem> </varlistentry> </variablelist> <para>These four elements become the key to locating and using one particular project in the vast space of other “Mavenized” projects . Maven repositories (public,<indexterm> <primary>repositories</primary> </indexterm><indexterm> <primary>Maven repositories</primary> </indexterm> private, and local) are organized according to these identifiers. When this project is installed into the local Maven repository, it immediately becomes locally available to any other project that wishes to use it. All you must do is add it as a dependency of another project <indexterm class="endofrange" startref="coord1"></indexterm><indexterm class="endofrange" startref="coord2"></indexterm>using the unique Maven coordinates for a specific artifact. </para> <para><figure><title>Maven Space is a coordinate system of projects</title>  <mediaobject> <imageobject> <imagedata fileref="figs/web/simple-project_mavenspace.png"
                         width="6in" /> </imageobject> </mediaobject> </figure></para> </section> <section id="simple-project-section-simple-repo"><title>Maven Repositories</title> <para>When you run Maven for the first time, you will notice that Maven downloads a number of files from a remote Maven repository. If the simple project was the first time you ran Maven, the first thing it will do is download the latest release of the Resources plugin when it triggers the <varname>resources:</varname><varname>resource</varname> goal. In Maven, artifacts and plugins are retrieved from a remote repository when they are needed. One of the reasons the initial Maven download is so small (1.5 MiB) is due to the fact that Maven doesn't ship with much in the way of plugins. Maven ships with the bare minimum and fetches from a remote repository when it needs to. Maven ships with a default remote repository location (<ulink
      url="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</ulink>) which it uses to download the core Maven plugins and dependencies.</para> <para>Often you will be writing a project which depends on libraries that are neither free nor publicly distributed. In this case you will need to either setup a custom repository inside your organization's network or download and install the dependencies manually. The default remote repositories can be replaced or augmented with references to custom Maven repositories maintained by your organization. There are multiple products available to allow organizations to manage and maintain mirrors of the public Maven repositories.</para> <para>What makes a Maven repository a Maven repository? The Maven repository is defined by structure, a repository is a collection of project artifacts stored in a structure and format which can be easily understood by Maven. In a Maven repository everything is stored in a directory structure that closely matches a project's Maven coordinates. You can see this structure by opening up a web browser and browsing the central Maven repository at <ulink
      url="http://repo1.maven.org/maven2/">http://repo1.maven.org/maven2/</ulink>. You will see that an artifact with the coordinates <varname>org.</varname><varname>apache.commons:</varname><varname>commons-email:</varname><varname>1.1</varname> is available under the directory <filename>/org/apache/commons/commons-email/1.1/</filename> in a file named <filename>commons-email-1.1.jar</filename>. The standard for a Maven repository is to store an artifact in the following directory relative to the root of the repository: <screen>/&lt;<varname>groupId</varname>&gt;/&lt;<varname>artifactId</varname>&gt;/&lt;<varname>version</varname>&gt;/&lt;<varname>artifactId</varname>&gt;-&lt;version&gt;.&lt;<varname>packaging</varname>&gt;</screen></para> <para>Maven downloads artifacts and plugins from a remote repository to your local machine and stores these artifacts in your local Maven repository. Once Maven has downloaded an artifact from the remote Maven repository it never needs to download that artifact again as Maven will always look for the artifact in the local repository before looking elsewhere. On Windows XP, your local repository is likely in <filename>C:\Documents and Settings\USERNAME\.m2\repository</filename>, and on Windows Vista, your local repository is in <filename>C:\Users\USERNAME\.m2\repository</filename>. On Unix systems, your local Maven repository is available in <filename>~/.m2/repository</filename>. When you build a project like the simple project you created in the previous section, the <varname>install</varname> phase executes a goal which installs your project's artifacts in your local Maven repository.</para> <para>In your local repository, you should be able to see the artifact created by our simple project. If you run the <command>mvn
      install</command> command, Maven will install our project's artifact in your local repository. Try it. </para><screen>$ <command>mvn install</command>
...
[INFO] [install:install]
[INFO] Installing .../simple-1.0-SNAPSHOT.jar to \
       ~/.m2/repository/com/sonatype/maven/simple/1.0-SNAPSHOT/ \
       simple-1.0-SNAPSHOT.jar
...</screen> <para>As you can see from the output of this command, Maven installed our project's <acronym>JAR</acronym> file into our local Maven repository. Maven uses the local repository to share dependencies across local projects. If you develop two projects—project A and project B—with project B depending on the artifact produced by project A. Maven will retrieve project A's artifact from your local repository when it is building project B. Maven repositories are both a local cache of artifacts downloaded from a remote repository and a mechanism for allowing your projects to depend on each other. </para> </section> <section id="simple-project-sect-dep-management"><title>Maven's Dependency Management</title> <para>In this chapter's simple example, Maven resolved the coordinates of the JUnit dependency—<varname>junit:</varname><varname>junit:</varname><varname>3.8.1</varname>—to a path in a Maven repository <filename>/junit/junit/3.8.1/junit-3.8.1.jar</filename>. The ability to locate an artifact in a repository based on Maven coordinates gives us the ability to define dependencies in a project's <acronym>POM</acronym>. If you examine the simple project's <filename>pom.xml</filename> file, you will see that there is a section which deals with <sgmltag>dependencies</sgmltag>, and that this section contains a single dependency—JUnit.</para> <para>A more complex project would contain more than one dependency, or it might contain dependencies that depend on other artifacts. Support<indexterm> <primary>transitive dependencies</primary> <secondary>support for</secondary> </indexterm> for transitive dependencies is one of Maven’s most powerful features. Let’s say your project depends on a library that, in turn, depends on 5 or 10 other libraries (Spring or Hibernate, for example). Instead of having to track down all of these dependencies and list them in your <filename>pom.xml</filename> explicitly, you can simply depend on the library you are interested in and Maven will add the dependencies of this library to your project’s dependencies implicitly. Maven will also take care of working out conflicts between dependencies, and provides you with the ability to customize the default behavior and exclude certain transitive dependencies.</para> <para>Let's take a look at a dependency which was downloaded to your local repository when you ran the previous example. Look in your local repository path under <filename>~/.m2/repository/junit/junit/3.8.1/</filename>. If you have been following this chapter's examples, there will be a file named <filename>junit-3.8.1.jar</filename> and a <filename>junit-3.8.1.pom</filename> file in addition to a few checksum files which Maven uses to verify the authenticity of a downloaded artifact. Note that Maven doesn't just download the JUnit<acronym> JAR</acronym> file, Maven also downloads a <acronym>POM</acronym> file for the JUnit dependency. The fact that Maven downloads <acronym>POM</acronym> files in addition to artifacts is central to Maven's support for transitive dependencies.</para> <para>When you install your project’s artifact in the local repository, you will also notice that Maven publishes a slightly modified version of the project’s <filename>pom.xml</filename> file in the same directory as the <acronym>JAR</acronym> file. Storing a <acronym>POM</acronym> file in the repository gives other projects information about this project, most importantly what dependencies it has. If Project B depends on Project A, it also depends on Project A’s dependencies. When Maven resolves a dependency artifact from a set of Maven coordinates, it also retrieves the <acronym>POM</acronym> and consults the dependencies <acronym>POM</acronym> to find any transitive dependences. These transitive dependencies are then added as dependencies of the current project.</para> <para>A dependency in Maven isn’t just a <acronym>JAR</acronym> file; it’s a <acronym>POM</acronym> file that, in turn, may declare dependencies on other artifacts. These dependencies of dependencies are called transitive dependencies, and they are made possible by the fact that the Maven repository stores more than just bytecode; it stores metadata about artifacts. </para> <figure><title>Maven Resolves Transitive Dependencies</title> <mediaobject> <imageobject> <imagedata fileref="figs/web/simple-project_depgraph.png"
                       width="6in" /> </imageobject> </mediaobject> </figure> <para>In the previous figure, project A depends on projects B and C. Project B depends on project D, and project C depends on project E. The full set of direct and transitive dependencies for project A would be projects B, C, D, and E, but all project A had to do was define a dependency on B and C. Transitive dependencies can come in handy when your project relies on other projects with several small dependencies (like Hibernate, Apache Struts, or the Spring Framework). Maven also provides you with the ability to exclude transitive dependencies from being included in a project's classpath.</para> <para>Maven also provides for different dependency scopes. The simple<indexterm> <primary>scope, dependency</primary> </indexterm> project’s <filename>pom.xml</filename> contains a single dependency—<varname>junit:</varname><varname>junit:</varname><varname>jar:</varname><varname>3.8.1</varname>—with a scope of <varname>test</varname>. When a dependency has a scope of <varname>test</varname>, it will not be available to the <varname>compile</varname> goal of the Compiler plugin. It will be added to the classpath for only the <varname>compiler:</varname><varname>testCompile</varname> and <varname>surefire:</varname><varname>test</varname> goals.</para> <para>When you create a <acronym>JAR</acronym> for a project, dependencies are not bundled with the generated artifact; they are used only for compilation. When you use Maven to create a <acronym>WAR</acronym> or an <acronym>EAR</acronym> file, you can configure Maven to bundle dependencies with the generated artifact, and you can also configure it to exclude certain dependencies from the <acronym>WAR</acronym> file using the <varname>provided</varname> scope. The <varname>provided</varname> scope tells Maven that a dependency is needed for compilation, but should not be bundled with the output of a build. This scope comes in handy when you are developing a web application. You’ll need to compile your code against the Servlet specification, but you don’t want to include the Servlet <acronym>API</acronym> <acronym>JAR</acronym> in your web application’s <filename>WEB-INF/lib</filename> directory. </para> </section> <section id="simple-project-sect-site-generation"><title>Site Generation and Reporting</title> <para>Another important feature of Maven is its ability to generate<indexterm> <primary>documentation generation</primary> </indexterm><indexterm> <primary>site generation</primary> </indexterm><indexterm> <primary>report generation</primary> </indexterm><indexterm> <primary>site lifecycle phase</primary> </indexterm> documentation and reports. In your simple project’s directory, execute the following command: </para><screen>$ <command>mvn site</command>
</screen> <para>This will execute the <varname>site</varname> lifecycle phase. Unlike the default build lifecycle that manages generation of code, manipulation of resources, compilation, packaging, etc., this lifecycle is concerned solely with processing site content under the <filename>src/site</filename> directories and generating reports. After this command executes, you should see a project web site in the <filename>target/site</filename> directory. Load <filename>target/site/index.html</filename> and you should see a basic shell of a project site. This shell contains some reports under “Project Reports” in the lefthand navigation menu, and it also contains information about the project, the dependencies, and developers associated with it under “Project Information.” The simple project’s web site is mostly empty, since the <acronym>POM</acronym> contains very little information about itself beyond a coordinate, a name, a <acronym>URL</acronym>, and a single test dependency.</para> <para>On this site, you’ll notice that some default reports are available. A unit test report communicates the success and failure of all unit tests in the project. Another report generates Javadoc for the project’s <acronym>API</acronym>. Maven provides a full range of configurable reports, such as the Clover report that examines unit test coverage, the <acronym>JXR</acronym> report that generates cross-referenced <acronym>HTML</acronym> source code listings useful for code reviews, the <acronym>PMD</acronym> report that analyzes source code for various coding problems, and the JDepend report that analyzes the dependencies between packages in a codebase. You can customize site reports by configuring which reports are included in a build via the <filename>pom.xml</filename> file. </para> </section> </section> <section id="simple-project-sect-summary"><title>Summary</title> <para>In this chapter, we have created a simple project, packaged the project into a JAR file, installed that JAR into the Maven repository for use by other projects, and generated a site with documentation. We accomplished this without writing a single line of code or touching a single configuration file. We also took some time to develop definitions for some of the core concepts of Maven. In the next chapter, we’ll start customizing and modifying our project <filename>pom.xml</filename> file to add dependencies and configure unit tests.</para> </section>
</chapter>
