<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="simple-project" lang="fr">
  <title>Mon premier projet avec Maven</title>

  <section id="simple-project-sect-intro">
    <title>Introduction</title>

    <para>Dans ce chapitre, nous présentons un projet simple créé à partir de rien en utilisant le plugin Maven
    Archetype. Cette application basique va nous fournir l'occasion de discuter certains des concepts au cœur de Maven
    tout en suivant le développement du projet.</para>

    <para>Avant de nous lancer dans l'utilisation de Maven sur des builds complexes avec plusieurs modules, nous allons
    commencer par les bases. Si vous avez déjà utilisé Maven auparavant, vous verrez qu'il fait bien son travail et
    s'occupe des détails. Vos builds tendent à "fonctionner correctement" et vous n'avez à vous plonger dans les
    détails de Maven que lorsque vous voulez personnaliser un comportement par défaut ou écrire votre propre plugin.
    Cependant, quand vous devez vous plonger dans ces détails, une bonne compréhension des principaux concepts est
    essentielle. Ce chapitre a pour but de vous présenter le projet Maven le plus simple possible puis de vous montrer
    les principaux concepts de Maven qui en font une solide plateforme de build. Une fois que vous l'aurez lu, vous
    aurez une compréhension fondamentale du cycle de vie du build, des dépôts Maven et du Project Object Model 
    (<acronym>POM</acronym>).</para>

    <section id="simple-project-sect-downloading-example">
      <title>Télécharger l'exemple de ce chapitre</title>

      <para>Ce chapitre développe un exemple très simple qui sera utilisé pour explorer les principaux concepts de
      Maven. Si vous suivez les étapes décrites dans ce chapitre, vous ne devriez pas avoir besoin de télécharger les
      exemples pour recréer le code produit par Maven. Nous allons utiliser le plugin Maven Archetype pour créer ce
      projet simple que ce chapitre ne modifie en rien. Si vous préférez lire ce chapitre avec le code source final de
      l'exemple, le projet qui sert d'exemple dans ce chapitre peut être téléchargé avec le code source des exemples du
      livre depuis : </para>
      
      <screen>${examples.download.url}</screen>

      <para>Décompressez cette archive dans le répertoire de votre choix, puis allez dans le répertoire
      <filename>ch-simple/</filename>. Vous y trouverez un répertoire <filename>simple/</filename> qui contient le code
      source de ce chapitre.</para>
    </section>
  </section>

  <section id="simple-project-sect-create-simple">
    <title>Création du projet Simple</title>

    <para>Pour commencer un nouveau projet Maven, utilisez le plugin Maven Archetype depuis la ligne de commande.
    Exécutez le goal <varname>archetype:generate</varname>, sélectionnez l'archetype numéro 15, et tapez "Y" pour
    confirmer et produire le nouveau projet :</para>

    <screen><command>$ mvn archetype:generate -DgroupId=org.sonatype.mavenbook.simple \
                                    -DartifactId=simple \
                                    -DpackageName=org.sonatype.mavenbook \
                                    -Dversion=1.0-SNAPSHOT
</command>[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'archetype'.
[INFO] ------------------------------------------------------------------------
[INFO] Building Maven Default Project
[INFO] task-segment: [archetype:generate] (aggregator-style)
[INFO] ------------------------------------------------------------------------
[INFO] Preparing archetype:generate
[INFO] No goals needed for project - skipping
[INFO] Setting property: velocimacro.messages.on =&gt; 'false'.
[INFO] Setting property: resource.loader =&gt; 'classpath'.
[INFO] Setting property: resource.manager.logwhenfound =&gt; 'false'.
[INFO] [archetype:generate {execution: default-cli}]
[INFO] Generating project in Interactive mode
[INFO] No archetype defined. Using maven-archetype-quickstart \
       (org.apache.maven.archetypes:maven-archetype-quickstart:1.0)
Choose archetype:
...
12: internal -&gt; maven-archetype-mojo (A Maven Java plugin development project)
13: internal -&gt; maven-archetype-portlet (A simple portlet application)
14: internal -&gt; maven-archetype-profiles ()
15: internal -&gt; maven-archetype-quickstart ()
16: internal -&gt; maven-archetype-site-simple (A simple site generation project)
17: internal -&gt; maven-archetype-site (A more complex site project)
18: internal -&gt; maven-archetype-webapp (A simple Java web application)
19: internal -&gt; jini-service-archetype (Archetype for Jini service project creation)
Choose a number: (...) 15: : <emphasis>15</emphasis>
Confirm properties configuration:
groupId: org.sonatype.mavenbook.simple
artifactId: simple
version: 1.0-SNAPSHOT
package: org.sonatype.mavenbook.simple
 Y: : <emphasis>Y</emphasis>
...
[INFO] Parameter: groupId, Value: org.sonatype.mavenbook.simple
[INFO] Parameter: packageName, Value: org.sonatype.mavenbook.simple
[INFO] Parameter: package, Value: org.sonatype.mavenbook.simple
[INFO] Parameter: artifactId, Value: simple
[INFO] Parameter: basedir, Value: /private/tmp
[INFO] Parameter: version, Value: 1.0-SNAPSHOT
[INFO] BUILD SUCCESSFUL</screen>

    <para>La commande <command>mvn</command> correspond à l'instruction d'exécution de Maven 2.
    L'élément <varname>archetype:generate</varname> correspond à un goal Maven. Si vous connaissez<indexterm>
        <primary>goals</primary>
        <secondary>à propos</secondary>
      </indexterm><indexterm>
        <primary>Maven goals, à propos</primary>
      </indexterm><indexterm>
        <primary>parent POM</primary>
        <seealso>POM</seealso>
      </indexterm><indexterm>
        <primary>racine POM</primary>
        <seealso>POM</seealso>
      </indexterm> Apache Ant, un goal Maven est analogue à une target Ant ; tous les deux décrivent une unité de tâche à
    accomplir lors d'un build. La paire <varname>-Dname=value</varname> représente un argument passé au goal sous la
    forme de propriété <varname>-D</varname>, comme pour les propriétés système que vous pourriez passer à la Machine
    Virtuelle Java via la ligne de commande. Le but du goal <varname>archetype:generate</varname> est de créer
    rapidement un projet à partir d'un archétype. Dans ce contexte, un <indexterm>
        <primary sortas="archetypes">archétypes, définition</primary>
      </indexterm> archétype se défini comme "un modèle original ou idéal d'après lequel sont bâtis un ouvrage, une
    œuvre ; un prototype<footnote id="foot-archetype-def">
        <para><emphasis>Selon l'American Heritage Dictionary of the English Language</emphasis>.</para>
      </footnote>". Il existe un grand nombre d'archétypes disponibles pour Maven, depuis une simple application Swing
    jusqu'à une application web complexe. Le goal <varname>archetype:generate</varname> propose de choisir parmi environ
    40 archétypes. Dans ce chapitre, nous allons utiliser l'archétype le plus basique pour créer un simple squelette
    de projet permettant de démarrer. Le préfixe <literal>archetype</literal> correspond au plugin, et <literal>generate</literal>
    correspond au goal.</para>

    <para>Une fois ce projet généré, allons regarder la structure de répertoire Maven qui a été créée sous le répertoire
    simple.</para>

    <screen>simple/<co id="coDef-simple-fs-root"
        linkends="coRef-simple-fs-root" />
simple/pom.xml<co id="coDef-simple-fs-pom" linkends="coRef-simple-fs-pom" />
      /src/
      /src/main/<co id="coDef-simple-fs-main" linkends="coRef-simple-fs-main" />
          /main/java
      /src/test/<co id="coDef-simple-fs-test" linkends="coRef-simple-fs-test" />
          /test/java</screen>

    <para>Ce répertoire suit les recommandations de la disposition Maven standard des répertoires.<indexterm>
        <primary>Standard Directory Layout</primary>
      </indexterm><indexterm>
        <primary>Maven Standard Directory Layout</primary>
      </indexterm> Nous détaillerons cela plus tard dans ce chapitre, pour l'instant essayons de comprendre ces
    quelques <phrase role="keep-together">répertoires</phrase> :</para>

    <calloutlist>
      <callout arearefs="coDef-simple-fs-root" id="coRef-simple-fs-root">
        <para>Le plugin Maven Archetype crée un répertoire <filename>simple/</filename> dont le nom correspond à
        l'<varname>artifactId</varname>. C'est ce qu'on appelle le répertoire racine<indexterm>
            <primary>base directory</primary>
          </indexterm> du projet.</para>
      </callout>

      <callout arearefs="coDef-simple-fs-pom" id="coRef-simple-fs-pom">
        <para>Chaque projet Maven possède ce qu'on appelle un Project Object Model (<acronym>POM</acronym>) dans un
        fichier <filename>pom.xml</filename>. Ce fichier décrit le projet, configure les plugins, et déclare les
        dépendances.</para>
      </callout>

      <callout arearefs="coDef-simple-fs-main" id="coRef-simple-fs-main">
        <para>Les sources et les ressources de notre projet se retrouvent sous le répertoire
        <filename>src/main</filename>. Dans le cas de notre projet Java simple, cela consistera en quelques classes Java
        et fichiers de propriétés. Pour un autre projet, on pourrait y trouver le répertoire racine d'une application
        web ou les fichiers de configuration d'un serveur d'applications. Dans un projet Java, les classes Java sont
        dans <filename>src/main/java</filename> et les ressources disponibles dans le classpath vont dans
        <filename>src/main/resources</filename>.</para>
      </callout>

      <callout arearefs="coDef-simple-fs-test" id="coRef-simple-fs-test">
        <para>Les tests de notre projet vont dans <filename>src/test</filename>. Dans ce répertoire, les classes Java,
        comme par exemple les tests JUnit ou TestNG, sont dans <filename>src/test/java</filename> et les ressources du
        classpath pour les tests vont dans <filename>src/test/resources</filename>.</para>
      </callout>
    </calloutlist>

    <para>Le plugin Maven Archetype a produit une classe unique
    <classname>org.sonatype.mavenbook.</classname><classname>App</classname>, qui contient 13 lignes de Java avec une
    fonction statique main qui affiche un message :</para>

    <programlisting language="java">package org.sonatype.mavenbook;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        System.out.println( "Hello World!" );
    }
}</programlisting>

    <para>Le plus simple des archétypes Maven produit le programme le plus simple possible : un programme qui affiche
    "Hello World!" sur la sortie standard.</para>
  </section>

  <section id="simple-project-sect-building-simple">
    <title>Construire le projet Simple</title>

    <para>Une fois le projet créé grâce au plugin Maven Archetype suivant les instructions de la section précédente 
    (<xref linkend="simple-project-sect-create-simple" />), il faut construire et packager l'application. Afin
    d'y parvenir, exécutez <command>mvn install</command> depuis<indexterm>
        <primary>mvn install command</primary></indexterm><indexterm>
        <primary>building applications</primary>
      </indexterm><indexterm>
        <primary>packaging applications</primary>
      </indexterm><indexterm>
        <primary> applications, building and packaging</primary>
      </indexterm> le répertoire qui contient le fichier <filename>pom.xml</filename> :</para>

    <screen><command>$ cd simple
$ mvn install</command>
[INFO] Scanning for projects...
[INFO] ----------------------------------------------------------------------
[INFO] Building simple
[INFO]    task-segment: [install]
[INFO] ----------------------------------------------------------------------
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Compiling 1 source file to /simple/target/classes
[INFO] [resources:testResources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:testCompile]
[INFO] Compiling 1 source file to /simple/target/test-classes
[INFO] [surefire:test]
[INFO] Surefire report directory: /simple/target/surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running org.sonatype.mavenbook.AppTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.105 sec

Results:

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO] [jar:jar]
[INFO] Building jar: /simple/target/simple-1.0-SNAPSHOT.jar
[INFO] [install:install]
[INFO] Installing /simple/target/simple-1.0-SNAPSHOT.jar to \
  ~/.m2/repository/com/sonatype/maven/simple/simple/1.0-SNAPSHOT/ \
  simple-1.0-SNAPSHOT.jar</screen>

    <para>Vous venez juste de créer, compiler, tester, packager et installer le projet Maven le plus simple possible.
    Pour vous prouver que ce programme fonctionne, exécutez-le depuis la ligne de commande.</para>

    <screen><command>$ java -cp target/simple-1.0-SNAPSHOT.jar org.sonatype.mavenbook.App
      </command>Hello World!
    </screen>
  </section>

  <section id="simple-project-sect-pom">
    <title>Modèle Objet du projet Simple</title>

    <para>Lors de son exécution, Maven lit les informations du projet dans le Project Object Model<indexterm>
        <primary>POM (Project Object Model)</primary>
      </indexterm><indexterm>
        <primary>Project Object Model</primary>
        <see>POM; pom.xml file</see>
      </indexterm><indexterm>
        <primary>pom.xml file</primary>
      </indexterm>. Le <acronym>POM</acronym> répond aux questions telles que : De quel
    type de projet s'agit-il ? Quel est le nom du projet ? Ce projet a-t-il été personnalisé ? L'<xref
    linkend="example_simple-project-pom" /> montre le fichier <filename>pom.xml</filename> par défaut créé par le goal
    <varname>generate</varname> du plugin Maven Archetype.</para>

    <example id="example_simple-project-pom">
      <title>Fichier <filename>pom.xml</filename> du projet Simple</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.simple&lt;/groupId&gt;
  &lt;artifactId&gt;simple&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;name&gt;simple&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
    </example>

    <para>Ce fichier <filename>pom.xml</filename> est le <acronym>POM</acronym> le plus basique que vous rencontrerez
    dans un projet Maven. La plupart du temps un fichier <acronym>POM</acronym> est considérablement plus complexe : il
    définit de nombreuses dépendances et personnalise le comportement des plugins. Les premiers éléments —
    <sgmltag>groupId</sgmltag>, <sgmltag>artifactId</sgmltag>, <sgmltag>packaging</sgmltag>,
    <sgmltag>version</sgmltag> — sont ce que l'on appelle les coordonnées Maven qui identifient de manière unique un
    projet. Les balises <sgmltag>name</sgmltag> et <sgmltag>url</sgmltag> sont des éléments descriptifs du <acronym>POM</acronym>
    donnant un nom compréhensible par un être humain et associant le projet à un site web. L'élément
    <sgmltag>dependencies</sgmltag> définit une dépendance unique, dans le scope <varname>test</varname>, sur un 
    framework de test appelé JUnit. Nous reverrons ces sujets par la suite dans
    la <xref linkend="simple-project-sect-simple-core" />. Tout ce que vous devez savoir, pour le moment, c'est que
    c'est le fichier <filename>pom.xml</filename> qui permet à Maven de s'exécuter.</para>

    <para>Maven s'exécute toujours selon un <acronym>POM</acronym> effectif, une combinaison de la configuration du
    fichier <filename>pom.xml</filename> du projet, de l'ensemble des <acronym>POM</acronym>s parents, d'un
    super-<acronym>POM</acronym> défini dans Maven, de la configuration de l'utilisateur et des profils actifs. Tous
    les projets étendent au final le super-<acronym>POM</acronym>, qui définit une configuration par défaut raisonnable
    et que nous décrivons en détails dans le <xref linkend="pom-relationships" />. Même si votre projet a un fichier
    <filename>pom.xml</filename> minimal, le contenu du <acronym>POM</acronym> de celui-ci est interpolé à partir
    des contenus des <acronym>POM</acronym>s parents, de la configuration de l'utilisateur et de tout profil actif. Pour
    voir ce <acronym>POM</acronym> "effectif", exécutez la commande suivante depuis le répertoire racine de votre simple
    projet.</para>

    <screen>$<command>mvn help:effective-pom</command></screen>

    <para>Lorsque vous exécutez cette commande vous pouvez voir un <acronym>POM</acronym> nettement plus consistent qui
    montre la configuration par défaut de Maven. Ce goal devient vite pratique lorsque vous essayez de débogguer un
    build et que vous voulez voir comment les POMs des parents de ce projet contribuent au POM effectif. Pour plus
    d'informations sur le plugin Maven Help, lisez la <xref linkend="installation-sect-help-plugin-install" />.</para>
  </section>

  <section id="simple-project-sect-simple-core">
    <title>Les concepts principaux</title>

    <para>Maintenant que nous avons exécuté Maven pour la première fois, il est temps de s'intéresser aux concepts qui
    sont au cœur de Maven. Dans l'exemple précédent, vous avez généré un projet qui consistait en un
    <acronym>POM</acronym> et un peu de code respectant la disposition Maven standard des répertoires. Puis vous avez
    exécuté Maven en lui passant une phase de son cycle de vie, ce qui a demandé à Maven d'exécuter toute une série de
    goals de plugins Maven. Enfin, vous avez installé l'artefact produit par Maven dans votre dépôt local. Une minute ? Qu'est ce
    que le "cycle de vie" ? Qu'est donc un "dépôt local" ? La section qui suit définit certains des concepts au cœur de
    Maven.</para>

    <section id="simple-project-sect-plugins-goals">
      <title>Plugins Maven et Goals</title>

      <para>Dans la section précédente, nous avons exécuté Maven en ligne de commande avec deux types d'arguments différents.<indexterm>
          <primary>Maven plugins</primary>

          <see>plugins</see>
        </indexterm> <indexterm>
          <primary>goals</primary>

          <seealso>plugins</seealso>
        </indexterm>La première commande appelait uniquement
      un goal d'un plugin, le goal <varname>generate</varname> du plugin Archetype. La deuxième exécution de Maven était
      une phase du cycle de vie, <varname>install</varname>. Pour<indexterm>
          <primary>executing goals</primary>
        </indexterm><indexterm>
          <primary>executing goals</primary>
          <seealso>goals</seealso>
        </indexterm> exécuter un unique goal d'un plugin Maven, nous avons utilisé la syntaxe <command>mvn
      archetype:generate</command>, où <varname>archetype</varname> est l'identifiant du plugin et
      <varname>generate</varname> l'identifiant du goal. Lorsque Maven exécute le goal d'un plugin, il affiche
      l'identifiant du plugin et l'identifiant du goal sur la sortie standard :</para>

      <screen><command>$ mvn archetype:generate -DgroupId=org.sonatype.mavenbook.simple \
                                        -DartifactId=simple \
                                        -DpackageName=org.sonatype.mavenbook
</command>...
<emphasis>[INFO] [archetype:generate]</emphasis>
[INFO] artifact org.apache.maven.archetypes:maven-archetype-quickstart: \
       checking for updates from central
...</screen>

      <para>Un plugin Maven se compose d'un ou plusieurs goals. On peut prendre comme exemples de plugins Maven ceux
      qui constituent le cœur de Maven comme le plugin Jar dont les goals permettent de créer des fichiers
      <acronym>JAR</acronym>, le plugin Compiler avec ses goals pour compiler le code source et le code des tests
      unitaires, ou le plugin Surefire dont les goals permettent l'exécution des tests unitaires et la production des
      rapports. On trouve aussi d'autres plugins, plus spécialisés, comme le plugin Hibernate3 pour l'intégration de la 
      bibliothèque très connue de persistence Hibernate, le plugin JRuby qui permet l'exécution de code Ruby durant un
      build Maven ou l'écriture de plugins Maven en Ruby. Maven permet aussi de définir ses propres plugins. Vous pouvez
      écrire votre propre plugin en Java ou dans de nombreux autres langages dont Ant, Groovy, Beanshell et, comme
      indiqué plus haut, Ruby.</para>

      <figure id="fig-plugin-goals">
        <title>Un plugin possède des Goals</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/simple-project_plugin.png" />
          </imageobject>

          <imageobject role="print">
            <imagedata align="center" fileref="figs/print/simple-project_plugin.pdf" format="PDF" scalefit="0"
                       width="100%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Un goal est une tâche spécifique qui peut être exécutée individuellement<indexterm>
          <primary>goals</primary>
          <secondary>defined</secondary>
        </indexterm> ou combinée à d'autres goals pour un build plus large. Un goal est une "tâche unitaire" dans Maven.
      On peut prendre comme exemple le goal <varname>compile</varname> du plugin Compiler, qui, comme son nom
      l'indique, compile tout le code source du projet, ou le goal <varname>test</varname> du plugin Surefire, qui
      exécute les tests unitaires. La configuration des goals s'effectue au travers de propriétés qui sont utilisées
      pour personnaliser le comportement. Par exemple, le goal <varname>compile</varname> du plugin Compiler définit un
      ensemble de <phrase role="keep-together">paramètres</phrase> de configuration qui vous permettent de préciser la
      version du JDK cible ou les options d'optimisation du compilateur. Dans l'exemple précédent, nous avons passé les
      paramètres de configuration <varname>groupId</varname> et <varname>artifactId</varname> au goal
      <varname>generate</varname> du plugin Archetype via les paramètres de la ligne de commande
      <command>-DgroupId=org.sonatype.mavenbook.simple</command> et <command>-DartifactId=simple</command>. Nous avons
      <phrase role="keep-together">aussi</phrase> passé le paramètre <varname>packageName</varname> au goal
      <literal>generate</literal> avec la valeur <package>org.sonatype.mavenbook</package>. Si nous n'avions pas précisé
      le paramètre <varname>packageName</varname>, le nom du package aurait été par défaut
      <package>org.sonatype.mavenbook.simple</package>.</para>

      <para><note>
          <para>Lorsque l'on fait référence au goal d'un plugin, il est courant d'utiliser le raccourci :
          <replaceable>pluginId</replaceable><literal>:</literal><replaceable>goalId</replaceable>. Par exemple, pour
          utiliser le goal <literal>generate</literal> du plugin Archetype, nous pouvons écrire <varname>archetype:generate</varname>.</para>
        </note></para>

      <para>Les goals ont des paramètres qui peuvent avoir des valeurs par défaut raisonnables. Dans l'exemple de
      <varname>archetype:generate</varname>, nous n'avons pas précisé, via la ligne de commande, quel type d'archétype
      devait être utilisé pour créer le projet ; nous avons simplement indiqué un <varname>groupId</varname> et un
      <varname>artifactId</varname>. Comme nous n'avons pas fourni le type d'archétype à créer, le goal
      <varname>generate</varname> nous a demandé d'intervenir, le goal <varname>generate</varname> s'est donc interrompu et nous a demandé
      de choisir dans une liste. Par contre, si nous avions utilisé le goal <varname>archetype:create</varname>, Maven
      aurait supposé que nous voulions créer un nouveau projet avec l'archétype
      <varname>maven-archetype-quickstart</varname>. C'est notre premier contact avec le concept<indexterm>
          <primary>convention over configuration</primary>
        </indexterm> <emphasis> de convention plutôt que configuration</emphasis>. La convention, ou le comportement par
      défaut, pour le goal <varname>create</varname> est de créer un projet basique à partir de l'archétype Quickstart.
      Le goal <varname>create</varname> définit une propriété de configuration <varname>archetypeArtifactId</varname>
      dont la valeur par défaut est <varname>maven-archetype-</varname> <varname>quickstart</varname>. L'archétype
      Quickstart génère le squelette d'un projet minimal qui contient un <acronym>POM</acronym> et une unique classe. Le
      plugin Archetype est bien plus puissant que cet exemple ne le laisse supposer, mais c'est une façon efficace de
      commencer rapidement de nouveaux projets. Plus tard dans ce livre, nous vous montrerons comment il est possible
      d'utiliser le plugin Archetype pour produire des projets plus complexes, comme des applications web, et comment
      utiliser le plugin Archetype pour définir vos propres structures de projets.</para>

      <para>Le cœur de Maven n'intervient que très peu dans les tâches spécifiques qui composent le build de votre
      projet. Maven, tout seul, ignore comment compiler votre code ou produire un fichier <acronym>JAR</acronym>. Il
      délègue tout cela à des plugins Maven comme le plugin Compiler et le plugin Jar, qui sont téléchargés selon les
      besoins et mis à jour régulièrement depuis le dépôt central de Maven. Lorsque vous téléchargez Maven, vous
      n'obtenez que le cœur de la plateforme qui ne sait que parser une ligne de commande, gérer un classpath, parser un
      fichier <acronym>POM</acronym> et télécharger des plugins Maven selon les besoins. Les utilisateurs ont
      facilement accès aux dernières options du compilateur grâce à Maven qui maintient le plugin Compiler en dehors de
      son cœur et fournit un mécanisme de mise à jour. Ainsi, les plugins Maven apportent une logique de build
      réutilisable universellement. Vous ne définissez pas la tâche de compilation dans un fichier de build ; vous
      utilisez le plugin Compiler plugin qui est partagé par tous les utilisateurs de Maven. Si le plugin Compiler est
      amélioré, tout projet qui utilise Maven en bénéficie immédiatement. (Et, si vous n'aimez pas le plugin Compiler,
      vous pouvez le remplacer par votre propre implémentation.)</para>
    </section>

    <section id="simple-project-sect-lifecycle">
      <title>Cycle de vie de Maven</title>

      <para>La deuxième commande que nous avons exécutée dans la section précédente<indexterm>
          <primary>Maven lifecycle</primary>
          <see>build lifecycle</see>
        </indexterm><indexterm>
          <primary>lifecycle, Maven</primary>
          <see>build lifecycle</see>
        </indexterm><indexterm class="startofrange" id="buildlife">
          <primary>build lifecycle</primary>
        </indexterm><indexterm>
          <primary>phases, lifecycle</primary>
          <see>build lifecycle</see>
        </indexterm> était <command>mvn install</command>. Cette commande n'appelle pas le goal d'un plugin, mais une
      phase du cycle de vie de Maven. Une phase est une des étapes de ce que Maven appelle "le cycle de vie du build".
      Le cycle de vie du build est une suite ordonnée de phases aboutissant à la construction d'un projet. Maven peut
      supporter différents cycles de vie, mais celui qui reste le plus utilisé est le cycle de vie<indexterm>
          <primary>default Maven lifecycle</primary>
        </indexterm><indexterm>
          <primary>build lifecycle</primary>
          <secondary>default Maven lifecycle</secondary>
        </indexterm> par défaut de Maven, qui commence par une phase de validation de l'intégrité du projet et se
      termine par une phase qui déploie le projet en production. Les phases du cycle de vie sont laissées vagues
      intentionnellement, définies comme validation, test, ou déploiement elles peuvent avoir un sens différent selon le
      contexte des projets. Par exemple, pour un projet qui produit une archive Java, la phase <varname>package</varname>
      va construire un <acronym>JAR</acronym> ; pour un projet qui produit une application web, elle produira un fichier
      <acronym>WAR</acronym>.</para>

      <para>Les goals des plugins peuvent être rattachés<indexterm>
          <primary>plugin goals</primary>
          <see>goals</see>
        </indexterm><indexterm>
          <primary>goals</primary>
          <secondary>attaching to lifecycle phases</secondary>
        </indexterm> à une phase du cycle de vie. Pendant que Maven parcourt les phases du cycle de vie, il exécute les
      goals rattachés à chacune d'entre elles. On peut rattacher de zéro à plusieurs goals à chaque phase. Dans la
      section précédente, quand vous avez exécuté <command>mvn install</command>, il se peut que vous ayez remarqué que
      plusieurs goals s'étaient exécutés. Regardez la sortie après avoir exécuté <command>mvn install</command> et relevez les
      différents goals qui ont été exécutés. Lorsque ce simple exemple atteint la phase <varname>package</varname>, il
      exécute le goal <varname>jar</varname> du plugin Jar. Puisque notre projet Quickstart a (par défaut) un packaging
      de type <varname>jar</varname>, le goal <varname>jar:</varname><varname>jar</varname> est rattaché à la phase
      <varname>package</varname>.</para>

      <para><figure id="fig-goals-bind-to-phases">
          <title>Un goal est rattaché à une phase</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/simple-project_phasebinding.png" />
            </imageobject>

            <imageobject role="print">
              <imagedata align="center" fileref="figs/print/simple-project_phasebinding.pdf" format="PDF" scalefit="0"
                         width="100%" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>Nous savons que la phase <varname>package</varname> va créer un fichier <acronym>JAR</acronym> pour un
      projet ayant un packaging de type <varname>jar</varname>. Mais qu'en est-il des goals qui la précèdent, comme
      <varname>compiler:</varname><varname>compile</varname> et <varname
      role="keep-together">surefire:</varname><varname role="keep-together">test</varname> ? Ces goals s'exécutent lors
      des phases qui précèdent la phase <varname>package</varname> selon le<indexterm>
          <primary>executing lifecycle phases</primary>
        </indexterm> cycle de vie de Maven ; exécuter une phase provoque l'exécution de l'ensemble des phases qui la
      précèdent, le tout se terminant par la phase spécifiée sur la ligne de commande. Chaque phase se compose de zéro à
      plusieurs goals, et puisque nous n'avons configuré ou personnalisé aucun plugin, cet exemple rattache un ensemble
      de goals standards au cycle de vie par défaut. Les goals suivants ont été exécutés dans l'ordre pendant que Maven
      parcourait le cycle de vie par défaut jusqu'à la phase <varname>package</varname> :</para>

      <variablelist>
        <varlistentry>
          <term><varname>resources:resources</varname></term>

          <listitem>
            <para>Le goal <varname>resources</varname> du plugin<indexterm>
                <primary>Resources plugin</primary>

                <secondary>resources goal</secondary>
              </indexterm> Resources est rattaché à la phase <varname>process-resources</varname>. Ce goal copie toutes
            les ressources du répertoire <filename>src/main/resources</filename> et des autres répertoires configurés
            comme contenant des ressources dans le répertoire cible.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>compiler:compile</varname></term>

          <listitem>
            <para>Le goal <varname>compile</varname> du plugin Compiler<indexterm>
                <primary>compile:compile goal</primary>
              </indexterm> <indexterm>
                <primary>Compiler plugin</primary>

                <secondary>compile goal</secondary>
              </indexterm>est lié à la phase <varname>compile</varname>. Ce goal compile tout le code source  du
            répertoire <filename>src/main/java</filename> et des autres répertoires configurés comme contenant du code
            source dans le répertoire cible.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>resources:testResources</varname></term>

          <listitem>
            <para>Le goal <varname>testResources</varname> du plugin Resources<indexterm>
                <primary>Resources plugin</primary>

                <secondary>testResources goal</secondary>
              </indexterm> est lié à la phase <varname>process-test-resources</varname>. Ce goal copie toutes les
            ressources du répertoire <filename>src/test/resources</filename> et des autres répertoires configurés comme
            contenant des ressources de test dans le répertoire cible pour les tests.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>compiler:testCompile</varname></term>

          <listitem>
            <para>Le goal <varname>testCompile</varname> du plugin Compiler<indexterm>
                <primary>Compiler plugin</primary>

                <secondary>testCompile goal</secondary>
              </indexterm> est rattaché à la phase <varname>test-compile</varname>. Ce goal compile les tests unitaires
            du répertoire <filename>src/test/java</filename> et des autres répertoires configurés comme contenant du
            code source de test dans le répertoire cible pour les tests.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>surefire:test</varname></term>

          <listitem>
            <para>Le goal <varname>test</varname> du plugin Surefire est<indexterm>
                <primary>Surefire plugin</primary>
                <secondary>test goal</secondary>
              </indexterm><indexterm>
                <primary>Maven Surefire plugin</primary>
                <secondary>test goal</secondary>
              </indexterm><indexterm>
                <primary>testing</primary>
                <secondary>Surefire:test goal</secondary>
              </indexterm> rattaché à la phase <varname>test</varname>. Ce goal exécute tous les tests et produit des
            fichiers contenant leurs résultats détaillés. Par défaut, le goal arrêtera le build en cas d'échec de l'un des tests.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>jar:jar</varname></term>

          <listitem>
            <para>Le goal <varname>jar</varname> du plugin Jar est lié<indexterm>
                <primary>jar:jar goal</primary>
              </indexterm> à la phase <varname>package</varname>. Ce goal package le contenu du répertoire cible en un
            fichier JAR.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para><figure id="fig-goals-bind-to-default-lifecycle">
          <title>Les goals sont lancés à l'exécution de la phase à laquelle ils sont rattachés</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/simple-project_lifecyclebinding.png" />
            </imageobject>

            <imageobject role="print">
              <imagedata align="center" fileref="figs/print/simple-project_lifecyclebinding.pdf" format="PDF"
                         scalefit="0" width="100%" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>Pour résumer, lorsque nous avons exécuté <command>mvn install</command>, Maven exécute toutes les phases
      jusqu'à la phase <varname>install</varname>, et pour cela il parcourt toutes les phases du cycle de vie, exécutant tous les goals
      liés à chacune de ces phases. Au lieu d'exécuter une des phases du cycle de vie de Maven, vous pourriez obtenir le
      même résultat en spécifiant une liste de goals de plugin de la manière suivante :</para>

      <screen><command>mvn resources:resources \
    compiler:compile \
    resources:testResources \
    compiler:testCompile \
    surefire:test \
    jar:jar \
    install:install
        </command></screen>

      <para>Il est beaucoup plus simple d'exécuter les phases du cycle de vie plutôt que de lister explicitement les
      goals à exécuter en ligne de commande, de plus, ce cycle de vie commun permet à chaque projet utilisant Maven
      d'adhérer à un ensemble de standards bien définis. C'est ce cycle de vie qui permet à un développeur de passer
      d'un projet à l'autre sans connaître tous les détails du build de chacun d'entre eux. Si vous savez construire un
      projet Maven, vous savez tous les construire.</para>
    </section>

    <section id="simple-project-sect-maven-coordinates">
      <title>Les coordonnées Maven</title>

      <para>Le plugin Archetype a créé un projet avec un fichier<indexterm class="startofrange" id="coord1">
          <primary>Maven coordinates</primary>
        </indexterm><indexterm class="startofrange" id="coord2">
          <primary>coordinates</primary>
        </indexterm> <filename>pom.xml</filename>. Ceci est le Project Object Model (<acronym>POM</acronym>), une
      description déclarative d'un projet. Quand Maven exécute un goal, celui-ci a accès aux informations définies dans
      le <acronym>POM</acronym> du projet. Lorsque le goal <varname>jar:</varname><varname>jar</varname> veut créer un
      fichier <acronym>JAR</acronym>, il va chercher dans le <acronym>POM</acronym> le nom du fichier JAR. Quand le goal
      <varname>compiler:</varname><varname>compile</varname> compile le source code Java en bytecode, il va regarder
      dans le <acronym>POM</acronym> pour voir si on a précisé des options de compilation. Les goals s'exécutent dans le
      contexte d'un <acronym>POM</acronym>. Les goals sont les actions que nous voulons appliquer à un projet et un
      projet est défini par un <acronym>POM</acronym>. Le <acronym>POM</acronym> donne son nom au projet, il fournit un
      ensemble d'identifiants uniques (les coordonnées) du projet et précise les relations entre ce projet et d'autres
      qu'il s'agisse de dépendances, de parents ou de prérequis. Un <acronym>POM</acronym> permet aussi de personnaliser
      le comportement d'un plugin, et de fournir des informations sur la communauté et les développeurs du
      projet.</para>

      <para>Les coordonnées Maven définissent un ensemble d'identifiants qui permet d'identifier de manière unique un
      projet, une dépendance, ou un plugin dans un <acronym>POM</acronym> Maven. Regardez le <acronym>POM</acronym> qui
      va suivre.</para>

      <para><figure id="fig-project-coords">
          <title>Coordonnées d'un projet Maven</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/simple-project_annopom.png" />
            </imageobject>

            <imageobject role="print">
              <imagedata align="center" fileref="figs/print/simple-project_annopom.pdf" scalefit="0" width="100%" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>Nous avons mis en évidence les coordonnées Maven de ce projet : <varname>groupId</varname>, 
      <varname>artifactId</varname>, <varname>version</varname> et <varname>packaging</varname>. Ces identifiants
      combinés forment ce qu'on appelle les coordonnées d'un projet<footnote id="foot-simple-classify">
          <para>Il existe une cinquième coordonnée, plus rarement utilisée, appelée <varname>classifier</varname> dont
          nous parlerons plus tard dans le livre. Vous pouvez l'oublier pour l'instant.</para></footnote>.
          Comme dans tout système à coordonnées, les coordonnées Maven permettent de définir un point
      spécifique dans "l'espace". 
      Lorsqu'un projet est relié à un autre en tant que dépendance, plugin ou comme projet parent, Maven l'identifie via ses coordonnées.   
      Les coordonnées Maven sont souvent écrites en utilisant les deux points comme séparateur selon le format suivant :
      <code>groupId:artifactId:packaging:version</code>. Dans le fichier <filename>pom.xml</filename> ci-dessus, les
      coordonnées de notre projet sont les suivantes : <code>mavenbook:my-app:jar:1.0-SNAPSHOT</code>.</para>

      <variablelist>
        <varlistentry>
          <term><varname>groupId</varname></term>

          <listitem>
            <para>Le groupe, l'entreprise, l'équipe, l'organisation, le projet ou autre<indexterm>
                <primary>groupId attribute (pom.xml)</primary>
              </indexterm> groupe. La convention pour les identifiants du groupe est qu'ils commencent par le nom de
            domaine inversé de l'organisation qui crée le projet. Les projets de Sonatype devraient avoir un
            <varname>groupId</varname> qui commence par <package>com.sonatype</package>, et les projets de l'Apache
            Software Foundation devraient avoir un <varname>groupId</varname> qui commence par
            <package>org.apache</package>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>artifactId</varname></term>

          <listitem>
            <para>Identifiant unique sous le <varname>groupId</varname> qui<indexterm>
                <primary>artifactId attribute (pom.xml)</primary>
              </indexterm> représente un projet unique.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>version</varname></term>

          <listitem>
            <para>Version spécifique d'un projet. Les projets qui ont été<indexterm>
                <primary>version attribute (pom.xml)</primary>
              </indexterm> livrés ont un identifiant de version fixe qui fait référence à une version bien spécifique du
            projet. Les projets en cours de développement peuvent utiliser un identifiant de version qui indique que
            cette version n'est pas stable : <varname>SNAPSHOT</varname>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Le format de packaging est aussi un composant important des coordonnées Maven, mais il ne fait pas partie des
      identifiants uniques d'un projet. Le triplet 
      <varname>groupId:</varname><varname>artifactId:</varname><varname>version</varname> d'un projet identifie de
      manière unique un projet ; vous ne pouvez pas avoir un projet avec le même triplet 
      <varname>groupId</varname>, <varname>artifactId</varname>, et <varname>version</varname>.</para>

      <variablelist>
        <varlistentry>
          <term><varname>packaging</varname></term>

          <listitem>
            <para>Le type du projet, <varname>jar</varname> par défaut,<indexterm>
                <primary>packaging attribute (pom.xml)</primary>
              </indexterm> décrit le résultat packagé produit par le projet. Un projet avec un packaging
            <varname>jar</varname> produit une archive <acronym>JAR</acronym> ; un projet avec un packaging
            <varname>war</varname> produit, quant à lui, une application web.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Ces quatre éléments sont la clef pour trouver et utiliser un projet particulier dans le vaste monde des
      projets "Mavenisés". Les dépôts Maven (publics,<indexterm>
          <primary>repositories</primary>
        </indexterm><indexterm>
          <primary>Maven repositories</primary>
        </indexterm> privés, et locaux) sont organisés autour de ces identifiants. Lorsque ce projet est installé dans
      le dépôt Maven local, il devient immédiatement disponible pour tout autre projet qui voudrait l'utiliser. Tout ce
      que vous avez à faire est de l'ajouter comme dépendance à un autre projet<indexterm class="endofrange"
      startref="coord1"></indexterm><indexterm class="endofrange" startref="coord2"></indexterm> en utilisant les
      coordonnées Maven uniques propres à l'artefact.</para>

      <para><figure id="fig-simple-mavenspace">
          <title>L'Espace des projets Maven est un système à coordonnées</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/simple-project_mavenspace.png" />
            </imageobject>

            <imageobject role="print">
              <imagedata align="center" fileref="figs/print/simple-project_mavenspace.pdf" scalefit="0" width="100%" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </section>

    <section id="simple-project-section-simple-repo">
      <title>Les dépôts Maven</title>

      <para>Lors de sa première exécution, vous allez vous apercevoir que Maven télécharge un grand nombre de fichiers
      depuis un dépôt Maven distant. Si vous exécutez Maven pour la première fois pour le projet simple, la première
      chose qu'il va faire est de télécharger la dernière version du plugin Resources lorsqu'il va déclencher le goal
      <varname>resources:</varname><varname>resource</varname>. Avec Maven, artefacts et plugins sont téléchargés depuis
      des dépôts distants au moment où on en a besoin. Une des raisons pour lesquelles Maven est si léger à télécharger
      (1.5 MiB) est que cette version initiale ne vient qu'avec très peu de plugins. Maven est livré avec le strict
      minimum et récupère de dépôts distants ce dont il a besoin quand il en a besoin. Maven est livré avec
      l'emplacement d'un dépôt distant par défaut (<ulink
      url="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</ulink>) qu'il utilise pour télécharger les
      principaux plugins et les dépendances Maven.</para>

      <para>Souvent vous aurez des projets qui dépendent de bibliothèques propriétaires ou qui ne sont pas disponibles publiquement.
      Dans ce cas vous devrez installer votre propre dépôt au sein du réseau de votre organisation, ou télécharger et
      installer ces dépendances manuellement. Les dépôts distants par défaut peuvent être remplacés ou complétés par des
      références à des dépôts Maven personnalisés gérés par votre organisation. Il existe de nombreux produits sur le
      marché pour permettre à des organisations de gérer et maintenir des miroirs des dépôts Maven publics.</para>

      <para>Quelles sont les caractéristiques d'un dépôt qui en font un dépôt Maven ? Un dépôt Maven est un ensemble d'artefacts de projet
      rangés selon une structure de répertoires correspondant aux coordonnées Maven. Vous pouvez voir cette organisation
      en ouvrant un navigateur internet et en parcourant le dépôt central de Maven sur <ulink
      url="http://repo1.maven.org/maven2/">http://repo1.maven.org/maven2/</ulink>. Vous verrez qu'un artefact ayant
      pour coordonnées
      <varname>org.</varname><varname>apache.commons:</varname><varname>commons-email:</varname><varname>1.1</varname>
      se retrouve dans le répertoire <filename>/org/apache/commons/commons-email/1.1/</filename> dans le fichier qui
      s'appelle <filename>commons-email-1.1.jar</filename>. Le comportement standard pour un dépôt Maven est de ranger
      un artefact sous le répertoire racine du dépôt dans un répertoire respectant le format suivant.
      <screen>/&lt;<varname>groupId</varname>&gt;/&lt;<varname>artifactId</varname>&gt;/&lt;<varname>version</varname>&gt;/&lt;<varname>artifactId</varname>&gt;-&lt;<varname>version</varname>&gt;.&lt;<varname>packaging</varname>&gt;</screen></para>

      <para>Maven télécharge artefacts et plugins depuis un dépôt distant et les enregistre dans le dépôt Maven local de
      votre machine. Une fois que Maven a téléchargé un artefact depuis un dépôt distant, il n'a plus besoin de le
      télécharger à nouveau. En effet, Maven cherchera toujours dans le dépôt local avant d'aller chercher ailleurs. Sur
      Windows XP, votre dépôt local se trouvera probablement dans <filename>C:\Documents and
      Settings\USERNAME\.m2\repository</filename> et sur Windows Vista, il se trouve dans
      <filename>C:\Users\USERNAME\.m2\repository</filename>. Sur les systèmes Unix, votre dépôt local Maven se trouve
      dans <filename>~/.m2/repository</filename>. Quand vous construisez un projet comme celui de la section précédente,
      la phase <varname>install</varname> exécute un goal qui installe les artefacts de votre projet dans votre dépôt
      Maven local.</para>

      <para>Dans votre dépôt local, vous devriez voir l'artefact créé par notre projet simple. Si vous exécutez la
      commande <command>mvn install</command>, Maven installera l'artefact de notre projet dans votre dépôt local.
      Essayez-le.</para>

      <screen>$<command>mvn install</command>
...
[INFO] [install:install]
[INFO] Installing .../simple-1.0-SNAPSHOT.jar to \
       ~/.m2/repository/com/sonatype/maven/simple/1.0-SNAPSHOT/ \
       simple-1.0-SNAPSHOT.jar</screen>

      <para>Comme le montrent les traces de cette commande, Maven a installé le fichier <acronym>JAR</acronym> de notre
      projet dans notre dépôt Maven local. Maven utilise le dépôt local pour partager les dépendances entre projets
      locaux. Si vous développez deux projets — projet A et projet B — où le projet B dépend de l'artefact produit par le
      projet A. Maven récupérera l'artefact du projet A depuis votre dépôt local quand il construira le projet B. Les
      dépôts Maven sont à la fois un cache local des artefacts téléchargés depuis un dépôt distant et un mécanisme qui
      permet à vos projets de dépendre les uns des autres.</para>
    </section>

    <section id="simple-project-sect-dep-management">
      <title>La gestion des dépendances de Maven</title>

      <para>Dans l'exemple de ce chapitre, Maven a résolu les coordonnées de la dépendance JUnit —
      <varname>junit:</varname><varname>junit:</varname><varname>3.8.1</varname> — sous la forme d'un chemin dans un dépôt
      Maven <filename>/junit/junit/3.8.1/junit-3.8.1.jar</filename>. C'est cette capacité à trouver un artefact dans un
      dépôt à partir de ses coordonnées qui nous permet de définir les dépendances dans le <acronym>POM</acronym> du
      projet. Si vous examinez le fichier <filename>pom.xml</filename> du projet simple, vous verrez qu'il comporte une
      section <sgmltag>dependencies</sgmltag> pour traiter des dépendances et que cette section contient une seule
      dépendance — JUnit.</para>

      <para>Un projet plus complexe contiendrait sûrement plusieurs dépendances, ou pourrait avoir des dépendances qui
      dépendent elles-mêmes d'autres artefacts. L'une des principales forces de Maven<indexterm>
          <primary>transitive dependencies</primary>
          <secondary>support for</secondary>
        </indexterm> est sa gestion des dépendances transitives. Supposons que votre projet dépende d'une bibliothèque
      qui à son tour dépend de 5 ou 10 autres bibliothèques (comme Spring ou Hibernate par exemple). Au lieu d'avoir à
      trouver et lister explicitement toutes ces dépendances dans votre fichier <filename>pom.xml</filename>, vous pouvez ne
      déclarer que la dépendance à la bibliothèque qui vous intéresse, Maven se chargera d'ajouter ses dépendances à
      votre projet implicitement. Maven va aussi gérer les conflits de dépendances, vous fournira le moyen de modifier
      son comportement par défaut et d'exclure certaines dépendances transitives.</para>

      <para>Regardons la dépendance téléchargée dans votre dépôt local lors de l'exemple précédent. Ouvrez dans votre
      dépôt local le répertoire <filename>~/.m2/repository/junit/junit/3.8.1/</filename>. Si vous avez suivi les
      instructions de ce chapitre vous trouverez un fichier <filename>junit-3.8.1.jar</filename> et un fichier
      <filename>junit-3.8.1.pom</filename> avec quelques fichiers de checksum que Maven utilise pour vérifier
      l'intégrité des artefacts téléchargés. Remarquez que Maven n'a pas juste téléchargé le <acronym>
      JAR</acronym> de JUnit, mais aussi un fichier <acronym>POM</acronym> pour les dépendances de JUnit. C'est le
      téléchargement des fichiers <acronym>POM</acronym> en plus des artefacts qui est au cœur de la gestion des
      dépendances transitives par Maven.</para>

      <para>Quand vous installez l'artefact produit par votre projet dans le dépôt local, vous noterez que Maven publie
      une version légèrement modifiée du fichier <filename>pom.xml</filename> de votre projet dans le répertoire contenant le
      fichier <acronym>JAR</acronym>. Ce fichier <acronym>POM</acronym> enregistré dans le dépôt fournit aux autres
      projets des informations sur ce projet, dont notamment ses dépendances. Si le Projet B dépend du Projet A, il
      dépend aussi des dépendances du Projet A. Quand Maven résout une dépendance à partir de ses coordonnées, il
      récupère, en plus de l'artefact, le <acronym>POM</acronym>, puis il analyse les dépendances de ce
      <acronym>POM</acronym> pour trouver les dépendances transitives. Ces dépendances transitives sont ensuite ajoutées
      à la liste des dépendances du projet.</para>

      <para>Dans le monde de Maven, une dépendance n'est plus simplement un fichier <acronym>JAR</acronym> ; c'est un
      fichier <acronym>POM</acronym> qui à son tour peut déclarer de nouvelles dépendances. Ce sont ces dépendances de
      dépendances que l'on appelle dépendances transitives et cela est rendu possible par le fait que les dépôts Maven
      contiennent plus que du bytecode ; ils contiennent des métadonnées sur les artefacts.</para>

      <figure id="fig-resolve-transitive">
        <title>Résolution des dépendances transitives par Maven</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/simple-project_depgraph.png" />
          </imageobject>

          <imageobject role="print">
            <imagedata align="center" fileref="figs/print/simple-project_depgraph.pdf" format="PDF" scalefit="0"
                       width="100%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Dans le schéma précédent, le projet A dépend des projets B et C. Le Projet B dépend du projet D et le
      projet C dépend du projet E. L'ensemble des dépendances directes et transitives du projet A serait donc les
      projets B, C, D et E, mais tout ce que le projet A doit faire, c'est de déclarer ses dépendances aux projets B et
      C. Les dépendances transitives sont pratiques lorsque votre projet dépend d'autres projets qui ont leurs propres
      dépendances (comme Hibernate, Apache Struts, ou Spring Framework). Maven vous permet d'exclure certaines
      dépendances transitives du classpath du projet.</para>

      <para>Maven fournit enfin différentes portées pour les dépendances. Le fichier <indexterm>
          <primary>scope, dependency</primary>
        </indexterm> <filename>pom.xml</filename> du projet simple contient une unique dépendance —
      <varname>junit:</varname><varname>junit:</varname><varname>jar:</varname><varname>3.8.1</varname> — ayant pour
      portée <varname>test</varname> indiquée dans la balise scope. Lorsqu'une dépendance Maven a une portée de type
      <varname>test</varname>, elle n'est pas disponible pour le goal <varname>compile</varname> du plugin Compiler.
      Cette dépendance sera ajoutée au classpath des goals <varname>compiler:</varname><varname>testCompile</varname> et
      <varname>surefire:</varname><varname>test</varname>.</para>

      <para>Durant la création du <acronym>JAR</acronym> d'un projet, les dépendances ne sont pas intégrées à l'artefact
      produit ; elles ne sont utilisées que lors de la compilation. Par contre lorsque vous utilisez Maven pour produire
      un <acronym>WAR</acronym> ou un <acronym>EAR</acronym>, vous pouvez le configurer de manière à packager les
      dépendances avec l'artefact produit et vous pouvez même configurer Maven pour exclure certaines dépendances du
      fichier <acronym>WAR</acronym> par l'utilisation de la portée <varname>provided</varname>. La portée
      <varname>provided</varname> indique à Maven que la dépendance est nécessaire à la compilation, mais qu'elle ne doit
      pas être intégrée à l'artefact produit par le build. Cette portée est donc très pratique lorsque vous développez
      une application web. Vous aurez besoin du jar des spécifications Servlet pour compiler, mais vous ne voulez pas
      inclure le <acronym>JAR</acronym> de l'<acronym>API</acronym> Servlet dans le répertoire
      <filename>WEB-INF/lib</filename>.</para>
    </section>

    <section id="simple-project-sect-site-generation">
      <title>Rapports et production du site</title>

      <para>Une fonction importante de Maven est sa capacité à produire<indexterm>
          <primary>documentation generation</primary>
        </indexterm><indexterm>
          <primary>site generation</primary>
        </indexterm><indexterm>
          <primary>report generation</primary>
        </indexterm><indexterm>
          <primary>site lifecycle phase</primary>
        </indexterm> de la documentation et des rapports. Dans le répertoire de votre projet simple, exécutez la commande
      suivante :</para>

      <screen>$<command>mvn site</command></screen>

      <para>Cette commande exécute la phase <varname>site</varname> du cycle de vie. Contrairement au cycle de vie du build, qui
      gère la génération de code, la manipulation des ressources, la compilation, le packaging, etc., ce cycle de vie ne
      concerne que le traitement du contenu du site qui se trouve dans le répertoire <filename>src/site</filename> et la
      production de rapports. Une fois la commande exécutée, vous devriez voir un site web du projet dans le répertoire
      <filename>target/site</filename>. Ouvrez <filename>target/site/index.html</filename> et vous devriez voir le
      squelette du site du projet Simple. Ce squelette contient certains rapports sous le menu de navigation "Project
      Reports" à gauche, ainsi que des informations sur le projet, les dépendances et les développeurs dans le menu
      "Project Information". Le site web du projet simple est quasiment vide puisque le <acronym>POM</acronym> contient
      très peu d'informations, juste des coordonnées Maven, un nom, une <acronym>URL</acronym> et une unique dépendance 
      de test.</para>

      <para>Sur ce site, vous noterez que des rapports par défaut sont disponibles. Un rapport de test fournit les
      succès et les échecs de l'ensemble des tests unitaires du projet. Un autre rapport produit la javadoc pour
      l'<acronym>API</acronym> du projet. Maven fournit un ensemble de rapports configurables, comme le rapport Clover qui
      examine la couverture des tests unitaires, le rapport <acronym>JXR</acronym> qui produit des listings de code
      source en <acronym>HTML</acronym> avec des références croisées, utile pour les revues de code, le rapport
      <acronym>PMD</acronym> qui analyse le code source à la recherche de différentes erreurs de codage et le rapport
      <acronym>JDepend</acronym> qui analyse les dépendances entre packages dans un code source. Vous pouvez personnaliser les rapports du
      site en configurant quels sont ceux qui seront inclus dans le build via le fichier
      <filename>pom.xml</filename>.</para>
    </section>
  </section>

  <section id="simple-project-sect-summary">
    <title>En résumé</title>

    <para>Dans ce chapitre, nous avons créé un projet simple que nous avons packagé sous la forme d'un fichier JAR, puis
    nous avons installé ce JAR dans le dépôt local de Maven pour qu'il soit utilisable par d'autres projets, enfin nous
    avons produit un site web contenant de la documentation. Nous avons fait tout cela sans écrire une seule ligne de
    code ni modifier un seul fichier de configuration. Nous nous sommes arrêtés en chemin pour développer les
    définitions de certains concepts au cœur de Maven. Dans le chapitre suivant, nous allons commencer à personnaliser
    et modifier le fichier <filename>pom.xml</filename> de notre projet pour lui ajouter des dépendances et configurer
    les tests unitaires.</para>
  </section>
</chapter>