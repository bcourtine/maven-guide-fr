<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="lifecycle" lang="fr">
  <title>Cycle de vie du build</title>

  <section id="lifecycle-sect-structure">
    <title>Introduction</title>

    <para>
    Maven modélise les projets en entités qui sont définies par un <acronym>POM</acronym>.
    Le <acronym>POM</acronym> capture donc l'identité d'un projet : Quel est son contenu ?
    De quel type de packaging a t-il besoin ? Le projet a-t-il un parent ? Quelles sont ses dépendances ?
    Nous avons exploré les principes de description d'un projet dans les chapitres précédents,
    mais nous n'avons pas introduit le mécanisme qui permet à Maven d'agir sur ces objets.
    Dans Maven, les "actions" (ou verbe) sont représentées par des goals. Ceux-ci sont packagés dans des plugins qui sont attachés à des phases du cycle de vie du build.
    Le cycle de vie Maven se compose d'une séquence de phases nommées comme <varname>prepare-resources</varname>, <varname>compile</varname>, <varname>package</varname> ou <varname>install</varname>.
    Il y a donc, entre autres, une phase pour la compilation et une autre pour le packaging.
    Il existe également des phases du type <varname>pre-</varname> et <varname>post-</varname>. 
    Celles-ci peuvent être utilisées, par exemple, pour enregistrer des goals devant être exécutés avant la compilation 
    ou effectuer certaines tâches après l'exécution d'une phase spécifique.
    Quand vous demandez à Maven de construire un projet, 
    vous lui demandez de parcourir la liste des différentes phases du cycle de vie et d'exécuter chacun des goals associés à celles-ci.</para>

    <para>Le cycle de vie d'un build est organisé en une séquence de phases qui permettent d'ordonner des groupes de goals.
    Ces goals sont choisis et rattachés en fonction du type de packaging de leur projet. 
    Il existe trois types de cycle de vie : clean, default (quelquefois appelé build) et site.
    Dans ce chapitre, vous allez apprendre comment Maven rattache des goals aux phases de ces cycles de vie et comment personnaliser un cycle de vie. 
    Vous apprendrez également les différentes phases du cycle de vie par défaut.</para>

    <section id="lifecycle-sect-clean">
      <title>Cycle de vie Clean (clean)</title>

      <para>Le premier cycle de vie auquel nous allons nous intéresser est le cycle de vie le plus simple de Maven.
      L'exécution de la commande <command>mvn clean</command> invoque le cycle de vie 'clean'. Celui-ci contient trois phases :</para>

      <itemizedlist>
        <listitem>
          <para><varname>pre-clean</varname></para>
        </listitem>

        <listitem>
          <para><varname>clean</varname></para>
        </listitem>

        <listitem>
          <para><varname>post-clean</varname></para>
        </listitem>
      </itemizedlist>

      <para>La phase la plus intéressante de ce cycle de vie est celle nommée <varname>clean</varname>.
      Le goal 'clean' du plugin Clean (<varname>clean:clean</varname>) est attaché à la phase <varname>clean</varname> du cycle de vie <varname>clean</varname>.
      Le goal <varname>clean:clean</varname> efface les traces laissées par la dernière construction en supprimant le répertoire de build.
      Si vous n'avez pas modifié l'emplacement du répertoire de build, celui-ci se trouve par défaut dans le répertoire <filename>\${basedir}/target</filename>.
      Lorsque vous exécutez le goal <varname>clean:clean</varname>, vous ne l'exécutez pas directement avec <command>mvn clean:clean</command>, 
      vous l'utilisez par l'intermédiaire de la phase <varname>clean</varname> du cycle de vie du même nom. 
      Exécuter la phase <varname>clean</varname> donne à Maven l'opportunité d'exécuter les autres goals rattachés à la phase <varname>pre-clean</varname>.</para>

      <para>Par exemple, supposez que vous vouliez exécuter un goal <varname>antrun:run</varname> pour afficher une notification lors du <varname>pre-clean</varname>,
      ou archiver le répertoire de build du projet avant qu'il ne soit supprimé.      
      Exécuter directement le goal <varname>clean:clean</varname> ne lancera pas le cycle de vie, vos tâches annexes ne seront donc pas exécutées. 
      Par contre, si vous utilisez la phase <varname>clean</varname>, vous utiliserez le cycle de vie du même nom (<varname>clean</varname>) 
      et traverserez de ce fait les trois phases du cycle de vie de jusqu'à la phase <varname>clean</varname>.
      L'<xref linkend="ex-trigger-pre-clean" /> montre une configuration de build qui permet de rattacher le goal <varname>antrun:run</varname>
      à la phase <varname>pre-clean</varname> pour afficher une alerte avant la suppression de l'artefact en cours de nettoyage.  
      Dans cet exemple, le goal <varname>antrun:run</varname> est utilisé pour exécuter des commandes Ant qui permettent de tester l'existence d'un artefact de projet.
      Ainsi, si l'artefact du projet est trouvé et est donc sur le point d'être effacé, une alerte s'affichera à l'écran.</para>

      <example id="ex-trigger-pre-clean">
        <title>Exécuter un goal lors du pre-clean</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;... &lt;plugin&gt;
    &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;id&gt;file-exists&lt;/id&gt;
        &lt;phase&gt;pre-clean&lt;/phase&gt;
        &lt;goals&gt;
          &lt;goal&gt;run&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
          &lt;tasks&gt;
            &lt;!-- adds the ant-contrib tasks (if/then/else used below) --&gt;
            &lt;taskdef resource="net/sf/antcontrib/antcontrib.properties" /&gt;
            &lt;available 
      file="\${project.build.directory}/\${project.build.finalName}.\${project.packaging}"
      property="file.exists" value="true" /&gt;

            &lt;if&gt;
              &lt;not&gt;
                &lt;isset property="file.exists" /&gt;
              &lt;/not&gt;
              &lt;then&gt;
                &lt;echo&gt;No
                  \${project.build.finalName}.\${project.packaging} to
                  delete&lt;/echo&gt;
              &lt;/then&gt;
              &lt;else&gt;
                &lt;echo&gt;Deleting
                  \${project.build.finalName}.\${project.packaging}&lt;/echo&gt;
              &lt;/else&gt;
            &lt;/if&gt;
          &lt;/tasks&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;ant-contrib&lt;/groupId&gt;
        &lt;artifactId&gt;ant-contrib&lt;/artifactId&gt;
        &lt;version&gt;1.0b2&lt;/version&gt;
      &lt;/dependency&gt;
    &lt;/dependencies&gt;
  &lt;/plugin&gt;
  &lt;/plugins&gt;
  &lt;/build&gt; 
&lt;/project&gt;
</programlisting>

        <para>Exécuter la commande <command>mvn clean</command> avec une telle configuration sur un projet produira un résultat ressemblant à celui-ci :</para>
      </example>

      <screen>[INFO] Scanning for projects...
[INFO] ----------------------------------------------------------------------
[INFO] Building Your Project
[INFO]    task-segment: [clean]
[INFO] ----------------------------------------------------------------------
[INFO] [antrun:run {execution: file-exists}]
[INFO] Executing tasks
     [echo] Deleting your-project-1.0-SNAPSHOT.jar
[INFO] Executed tasks
[INFO] [clean:clean]
[INFO] Deleting directory ~/corp/your-project/target
[INFO] Deleting directory ~/corp/your-project/target/classes
[INFO] Deleting directory ~/corp/your-project/target/test-classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1 second
[INFO] Finished at: Wed Nov 08 11:46:26 CST 2006
[INFO] Final Memory: 2M/5M
[INFO] ------------------------------------------------------------------------
</screen>

      <para>En plus de configurer Maven pour exécuter un goal lors de la phase <varname>pre-clean</varname>,
      vous pouvez personnaliser le plugin Clean pour effacer des dossiers en plus du répertoire contenant le build. 
      Vous pouvez configurer le plugin pour supprimer une liste de fichier en lui spécifiant un <sgmltag>fileSet</sgmltag>.
      L'exemple ci-dessous configure le plugin Clean pour supprimer tous les fichiers du répertoire <filename>target-other/</filename> en utilisant des wildcards standard Ant :   
      <varname>*</varname> et <varname>**</varname>.</para>
      

      <para><example>
          <title>Personaliser le comportement du plugin Clean</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;filesets&gt;
            &lt;fileset&gt;
              &lt;directory&gt;target-other&lt;/directory&gt;
              &lt;includes&gt;
                &lt;include&gt;*.class&lt;/include&gt;
              &lt;/includes&gt;
            &lt;/fileset&gt;
          &lt;/filesets&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>
        </example></para>
    </section>

    <section id="lifecycle-sect-default">
      <title>Cycle de vie par défaut (default)</title>

      <para>La plupart des utilisateurs Maven sont familiers avec le cycle de vie par défaut. 
      C'est un modèle général de processus de build pour une application.
      Ce cycle de vie commence par la phase <varname>validate</varname> et se termine avec la phase <varname>deploy</varname>. 
      Les phases du cycle de vie Maven par défaut sont présentées dans le <xref linkend="tbl-default-lifecycle" />.</para>

      <table id="tbl-default-lifecycle">
        <title>Phases du cycle de vie Maven</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Phase du cycle de vie</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>validate</entry>

              <entry>Valide le projet et la disponibilité de toutes les informations requises pour le build</entry>
            </row>

            <row>
              <entry>generate-sources</entry>

              <entry>Génère le code source nécessaire pour l'inclure à la compilation</entry> 
            </row>

            <row>
              <entry>process-sources</entry>

              <entry>Traite le code source, pour filtrer certaines valeurs par exemple</entry>
            </row>

            <row>
              <entry>generate-resources</entry>

              <entry>Génère les ressources à inclure dans le package</entry>
            </row>

            <row>
              <entry>process-resources</entry>

              <entry>Copie et traite les ressources dans leur répertoire destination, afin qu'elles soient prêtes pour le packaging</entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>Compile le code source du projet</entry>
            </row>

            <row>
              <entry>process-classes</entry>

              <entry>Traitre à posteriori les fichiers générés par la compilation, pour modifier du bytecode par exemple</entry>
            </row>

            <row>
              <entry>generate-test-sources</entry>

              <entry>Génère le code source des tests pour l'inclure à la compilation</entry>
            </row>

            <row>
              <entry>process-test-sources</entry>

              <entry>Traite le code source des tests, pour filtrer certaines valeurs par exemple</entry>
            </row>

            <row>
              <entry>generate-test-resources</entry>

              <entry>Génère les ressources pour les tests</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>Copie et traite les ressources de test dans le répertoire destination des tests</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>Compile le code source des tests dans le répertoire destination des tests</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>Exécute les tests en utilisant le framework de test approprié. 
              Le code de ces tests ne doit pas être nécessaire au packaging ni au déploiement.</entry>
            </row>

            <row>
              <entry>prepare-package</entry>

              <entry>Effectue les opérations nécessaires pour la préparation du package avant que celui-ci ne soit réellement créé.
              Il en résulte souvent une version dézippée et prête à été packagée du futur package (Maven 2.1+)</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>Package le code compilé dans un format distribuable tel que <acronym>JAR</acronym>, 
              <acronym>WAR</acronym> ou <acronym>EAR</acronym></entry>
            </row>

            <row>
              <entry>pre-integration-test</entry>

              <entry>Effectue les actions nécessaires avant de lancer les tests d'intégration, comme configurer un environnement par exemple.</entry>
            </row>

            <row>
              <entry>integration-test</entry>

              <entry>Traite et déploie si nécessaire le package dans l'environnement où les tests pourront être exécutés</entry>
            </row>

            <row>
              <entry>post-integration-test</entry>

              <entry>Effectue les actions nécessaires à la fin de l'exécution des tests d'intégration, comme nettoyer l'environnement par exemple</entry> 
            </row>

            <row>
              <entry>verify</entry>

              <entry>Lance des points de contrôle pour vérifier que le package est valide et qu'il passe les critères qualité</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>Installe le package dans le dépôt local, celui-ci pourra ainsi être utilisé comme dépendance par d'autres projets locaux</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>Copie le package final sur le dépôt distant. Permet de partager le package avec d'autres utilisateurs et projets (souvent pertinent pour une vraie livraison)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-site">
      <title>Cycle de vie Site (site)</title>

      <para>Maven fait plus que construire des artefacts,
      il peut également produire de la documentation et différents rapports d'un ou plusieurs projets.
      La documentation du projet et la génération du site web ont un cycle de vie séparé. 
      Celui-ci contient quatre phases :</para>

      <orderedlist>
        <listitem>
          <para>pre-site</para>
        </listitem>

        <listitem>
          <para>site</para>
        </listitem>

        <listitem>
          <para>post-site</para>
        </listitem>

        <listitem>
          <para>site-deploy</para>
        </listitem>
      </orderedlist>

      <para>Les goals suivants sont rattachés par défaut à ce cycle de vie :</para>

      <orderedlist>
        <listitem>
          <para>site - site:site</para>
        </listitem>

        <listitem>
          <para>site-deploy - site:deploy</para>
        </listitem>
      </orderedlist>

      <para>Le type de packaging n'a aucune influence sur ce cycle de vie. 
      Les types de packaging influent sur la création des artefacts, pas sur le type de site généré. 
      Le plugin Site lance l'exécution de la production d'un document <ulink url="http://maven.apache.org/doxia/">Doxia</ulink> et de différents plugins permettant de générer des rapports.
      Vous pouvez générer un site à partir d'un projet Maven en exécutant la commande suivante :</para>

      <screen>$ <command>mvn site</command>
</screen>

      <para>Pour plus d'informations à propos de la génération de site Maven, consultez le <xref linkend="site-generation" />.</para>
    </section>
  </section>

  <section id="lifecycle-sect-package-specific">
    <title>Cycles de vie spécifiques par type de package</title>

    <para>Des goals spécifiques sont rattachés à chaque phase en fonction du packaging du projet.
    Un projet de type <varname>jar</varname> ne dispose pas des mêmes goals par défaut qu'un projet de type <varname>war</varname>.
    La balise <sgmltag>packaging</sgmltag> influe donc sur les étapes requises pour construire un projet.      
    Pour illustrer cela, prenons un exemple avec deux projets :
    l'un avec un packaging de type <varname>pom</varname> et l'autre avec un packaging de type <varname>jar</varname>.
    Le projet avec le packaging de type <varname>pom</varname> lancera le goal <varname>site:attach-descriptor</varname> durant la phase <varname>package</varname>,
    alors que le projet de type <varname>jar</varname> exécutera le goal <varname>jar:jar</varname>.</para>

    <para>Les paragraphes suivants décrivent le cycle de vie pour tous les types de packaging disponibles dans Maven.
    Ils vous permettront de trouver quels goals sont rattachés au cycle de vie par défaut.</para> 

    <section id="lifecycle-sect-jar">
      <title>JAR</title>

      <para><acronym>JAR</acronym> est le type de packaging par défaut, c'est également le plus commun et le plus souvent rencontré. 
      Les goals par défaut rattachés au cycle de vie pour un projet possédant ce type de packaging sont montrés dans le 
      <xref linkend="tbl-jar-lifecycle" />.</para>

      <table id="tbl-jar-lifecycle">
        <title>Goals par défaut pour le packaging de type JAR</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Phase du cycle de vie</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>compiler:compile</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>resources:testResources</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>compiler:testCompile</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>surefire:test</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>jar:jar</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-pom">
      <title>POM</title>

      <para><acronym>POM</acronym> est le plus simple des types de packaging. 
      L'artefact généré est le pom lui-même plutôt qu'un fichier <acronym>JAR</acronym>, <acronym>SAR</acronym> ou <acronym>EAR</acronym>. 
      Il ne possède pas de code à tester ni même à compiler, et n'a pas de ressources à traiter.
      Les goals par défaut d'un projet du type POM sont affichés dans le <xref linkend="tbl-pom-lifecycle" />.</para>

      <table id="tbl-pom-lifecycle">
        <title>Goals par défaut d'un projet du type POM</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Phase du cycle de vie</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>package</entry>

              <entry>site:attach-descriptor</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-plugin-lifecycle">
      <title>Plugin Maven</title>

      <para>Ce type de packaging ressemble au packaging <acronym>JAR</acronym> avec trois particularités : 
      <varname>plugin:descriptor</varname>, <varname>plugin:addPluginArtifactMetadata</varname> et <varname>plugin:updateRegistry</varname>.
      Ces goals génèrent un descripteur de fichier et effectuent quelques modifications sur les données. 
      Les goals par défaut des projets possédant un packaging de type Plugin sont présentés sur le <xref linkend="tbl-plugin-lifecycle" />.</para>

      <table id="tbl-plugin-lifecycle">
        <title>Goals par défaut d'un projet du type Plugin</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Phase du cycle de vie</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>generate-resources</entry>

              <entry>plugin:descriptor</entry>
            </row>

            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>compiler:compile</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>resources:testResources</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>compiler:testCompile</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>surefire:test</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>jar:jar, plugin:addPluginArtifactMetadata</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install, plugin:updateRegistry</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-ejb">
      <title>EJB</title>

      <para>Les <acronym>EJB</acronym>s (Enterprise Java Beans) proposent un mécanisme standard d'accès aux données.
      Ils proposent une approche orientée modèle (model-driven development) pour le développement d'applications Java d'entreprise.   
      Maven fournit un support pour les <acronym>EJB</acronym> 2 et 3.
      Les paramètres par défaut du plugin recherchent la présence des fichiers de configuration <acronym>EJB</acronym> 2.1,
      vous devez configurer le plugin <acronym>EJB</acronym> pour packager spécifiquement un <acronym>EJB3</acronym>.
      Les goals par défaut pour des projets du type <acronym>EJB</acronym> sont présentés dans le <xref linkend="tbl-ejb-lifecycle" />.</para>

      <table id="tbl-ejb-lifecycle">
        <title>Goals par défaut d'un projet du type EJB</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Phase du cycle de vie</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>compiler:compile</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>resources:testResources</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>compiler:testCompile</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>surefire:test</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>ejb:ejb</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-war">
      <title>WAR</title>

      <para>Le packaging de type <acronym>WAR</acronym> ressemble également aux types <acronym> JAR</acronym> et <acronym>EJB</acronym>,
      à l'exception près du goal <varname>war:war</varname> de la phase <varname>package</varname>.
      Notez que le plugin <varname>war:war</varname> nécessite la présence d'un fichier de configuration <filename>web.xml</filename> dans le répertoire <filename>src/main/webapp/WEB-INF</filename>.
      Les goals par défaut d'un projet de type <acronym>WAR</acronym> sont présentés dans le <xref linkend="tbl-war-lifecycle" />.</para> 

      <table id="tbl-war-lifecycle">
        <title>Goals par défaut d'un projet de type WAR</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Phase du cycle de vie</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>compiler:compile</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>resources:testResources</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>compiler:testCompile</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>surefire:test</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>war:war</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-ear">
      <title>EAR</title>

      <para>Les <acronym>EAR</acronym>s sont probablement les artefacts les plus simples d'une application Java <acronym>EE</acronym>. 
      Ils sont constitués d'un descripteur de déploiement nommé <filename>application.xml</filename>, de ressources et de modules.  
      Le plugin <acronym>EAR</acronym> possède un goal nommé <varname>generate-application-xml</varname>. 
      Celui-ci génère le fichier <filename>application.xml</filename> à partir de la configuration définie dans le POM du projet <acronym>EAR</acronym>.
      Les goals par défaut d'un projet de type <acronym>EAR</acronym> sont présentés dans le <xref linkend="tbl-ear-lifecycle" />.</para>

      <table id="tbl-ear-lifecycle">
        <title>Goals par défaut d'un projet de type EAR</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Phase du cycle de vie</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>generate-resources</entry>

              <entry>ear:generate-application-xml</entry>
            </row>

            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>ear:ear</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-other-packaging">
      <title>Autres types de packaging</title>

      <para>La liste que nous venons de parcourir n'est pas exhaustive.
      Nombre d'autres types de packaging sont disponibles par l'intermédiaire de projets externes et de plugins, dont :
      le type de packaging <acronym>NAR</acronym> (native archive), les types <acronym>SWF</acronym> et <acronym>SWC</acronym>
      pour les projets qui produisent des contenus Adobe Flash et Flex.  
      Vous pouvez également définir un type de packaging personnalisé et modifier le cycle de vie par défaut pour répondre à vos contraintes.</para> 

      <para>Pour utiliser l'un de ces types de packaging personnalisé, vous avez besoin de deux choses :
      un plugin qui définit le cycle de vie de ce type de packaging personnalisé et un dépôt qui contient ce plugin.
      Plusieurs types de packaging personnalisés sont définis dans des plugins téléchargeables à partir du dépôt Maven central.
      Voici l'exemple d'un projet qui référence le plugin Israfil Flex et qui utilise un type de packaging personnalisé 
      <acronym>SWF</acronym> comme résultat de la construction du code source Adobe Flex.</para>

      <para><example>
          <title>Type de packaging personnalisé pour Adobe Flex (SWF)</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;packaging&gt;swf&lt;/packaging&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;net.israfil.mojo&lt;/groupId&gt;
        &lt;artifactId&gt;maven-flex2-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.4-SNAPSHOT&lt;/version&gt;
        &lt;extensions&gt;true&lt;/extensions&gt;
        &lt;configuration&gt;
          &lt;debug&gt;true&lt;/debug&gt;
          &lt;flexHome&gt;\${flex.home}&lt;/flexHome&gt;
          &lt;useNetwork&gt;true&lt;/useNetwork&gt;
          &lt;main&gt;org/sonatype/mavenbook/Main.mxml&lt;/main&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  ...
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>Dans la <xref linkend="writing-plugins-sect-plugins-lifecycle" />, 
      nous vous montrons comment créer votre propre type de packaging avec un cycle de vie personnalisé. 
      Cet exemple devrait vous donner une idée de ce que vous avez à faire pour référencer un nouveau type de packaging.
      Tout ce dont vous avez besoin est de référencer le plugin qui fournit votre nouveau type de packaging. 
      Le plugin Israfil Flex est un plugin Maven non officiel hébergé sur Google Code, pour plus
      d'informations sur son fonctionnement et son utilisation, rendez-vous à l'adresse <ulink
      url="http://code.google.com/p/israfil-mojo">http://code.google.com/p/israfil-mojo</ulink>.
      Ce plugin fournit le cycle de vie suivant pour les projets de type <acronym>SWF</acronym> :</para>

      <table>
        <title>Cycle de vie par défaut d'un projet de type SWF</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Phase du cycle de vie</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>compile</entry>

              <entry>flex2:compile-swc</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </section>

  <section id="lifecycle-sect-common-goals">
    <title>Goals communs aux cycles de vie</title>

    <para>La plupart des cycles de vie de packaging possèdent des goals en commun.
    Si vous regardez les goals rattachés aux cycles de vie <acronym>WAR</acronym> et <acronym>JAR</acronym>,
    vous remarquerez que seule la phase <varname>package</varname> diffère.
    La phase <varname>package</varname> du cycle de vie <acronym>WAR</acronym> appelle <varname>war:war</varname> alors
    que cette même phase appelle <varname>jar:jar</varname> pour le cycle de vie <acronym>JAR</acronym>. 
    La plupart des cycles de vie que vous rencontrerez partageront certains goals pour gérer les ressources,
    exécuter les tests et compiler votre code. 
    Dans cette section, nous explorerons quelques-uns des goals utilisés sur plusieurs cycles de vie.</para>

    <section id="lifecycle-sect-process-resources-phase">
      <title>Traiter les resources</title>

      <para>La plupart des cycles de vie rattachent le goal <varname>resources:resources</varname> à la phase <varname>process-resources</varname>.
      La phase <varname>process-resources</varname> "traite" les ressources et les copie dans le répertoire destination.
      Si vous n'avez pas personnalisé les répertoires par défaut définis dans le Super <acronym>POM</acronym>, Maven copiera
      les fichiers du répertoire <filename>\${basedir}/src/main/resources</filename> dans le répertoire
      <filename>\${basedir}/target/classes</filename> ou dans le répertoire défini dans <filename>\${project.build.outputDirectory}</filename>.
      En plus de les copier, Maven peut également appliquer des filtres aux ressources pour remplacer certains de leurs éléments.
      Tout comme dans le <acronym>POM</acronym> où les variables étaient définies par la notation <varname>\${...}</varname>,
      vous pouvez référencer des variables dans les ressources de votre projet en utilisant cette même syntaxe.
      Couplée aux profils, cette fonctionnalité peut être utilisée pour construire des artefacts configurés pour différentes plateformes de déploiement. 
      Il est courant d'avoir besoin de construire des artefacts multi-environnement, en effet, 
      un projet a souvent plusieurs environnements cibles : développement, tests, recette, production.
      Pour plus d'informations à propos des profils, consultez le <xref linkend="profiles" />.</para>

      <para>Pour illustrer ce filtrage des ressources, prenons l'exemple d'un projet possédant un fichier <acronym>XML</acronym> : <filename>src/main/resources/META-INF/service.xml</filename>.
      Vous voulez externaliser certaines variables de configuration dans un fichier properties. 
      En d'autres termes, vous voulez référencer l'<acronym>URL</acronym> <acronym>JDBC</acronym>, l'utilisateur et le mot de passe de votre base de données,
      sans directement mettre ces valeurs en dur dans le fichier <filename>service.xml</filename>.
      À la place, vous désirez utiliser un fichier properties pour centraliser toutes les valeurs de configuration de votre programme.
      Cela vous permet de consolider toute la configuration dans un seul fichier properties, 
      et simplifie la mise à jour des valeurs de configuration lors de la configuration d'un nouvel environnement.        
      Commençons par regarder le contenu du fichier <filename>service.xml</filename> du répertoire <filename>src/main/resources/META-INF</filename>.</para> 
     
      <para><example>
          <title>Utilisation des propriétés dans les ressources du projet</title>

          <programlisting language="xml">&lt;service&gt;
  &lt;!-- This URL was set by project version \${project.version} --&gt;
  &lt;url&gt;\${jdbc.url}&lt;/url&gt;
  &lt;user&gt;\${jdbc.username}&lt;/user&gt;
  &lt;password&gt;\${jdbc.password}&lt;/password&gt;
&lt;/service&gt;
</programlisting>
        </example></para>

      <para>Ce fichier <acronym>XML</acronym> utilise la même syntaxe pour gérer ses propriétés que celle que du <acronym>POM</acronym>. 
      La première variable référencée est la variable <varname>project</varname>, 
      celle-ci est une variable implicite qui est également disponible dans le <acronym>POM</acronym>.   
      La variable <varname>project</varname> propose un moyen d'accéder à certaines informations du <acronym>POM</acronym>. 
      Les trois variables suivantes sont <varname>jdbc.url</varname>, <varname>jdbc.username</varname> et <varname>jdbc.password</varname>.
      Ces variables sont définies dans un fichier de properties <filename>src/main/filters/default.properties</filename>.</para>


      <example>
        <title>default.properties dans src/main/filters</title>

        <programlisting>jdbc.url=jdbc:hsqldb:mem:mydb
jdbc.username=sa
jdbc.password=
</programlisting>
      </example>

      <para>Pour configurer le filtrage des ressources avec le fichier <filename>default.properties</filename>,
      nous avons besoin de préciser deux choses dans le <acronym>POM</acronym> du projet :
      une liste de fichiers de propriétés dans la balise <sgmltag>filters</sgmltag> de la configuration du build
      et un booléen qui permet à Maven de savoir si un répertoire doit être filtré. 
      Le comportement par défaut de Maven est de ne pas effectuer de filtre mais de juste copier les ressources dans le répertoire destination :
      vous devez donc configurer explicitement le filtrage des ressources.
      Ce comportement par défaut permet d'éviter les mauvaises surprises comme, par exemple, filtrer sans que vous le désiriez des fichiers contenant des éléments <varname>\${...}</varname>.</para>

      <para><example>
          <title>Filtrage des ressources (remplacer les propriétés)</title>

          <programlisting language="xml">&lt;build&gt;
  &lt;filters&gt;
    &lt;filter&gt;src/main/filters/default.properties&lt;/filter&gt;
  &lt;/filters&gt;
  &lt;resources&gt;
    &lt;resource&gt;
      &lt;directory&gt;src/main/resources&lt;/directory&gt;
      &lt;filtering&gt;true&lt;/filtering&gt;
    &lt;/resource&gt;
  &lt;/resources&gt;
&lt;/build&gt;
</programlisting>
        </example></para>

      <para>Comme pour tous les répertoires dans Maven, celui contenant les ressources du projet ne se trouve pas forcément dans <filename>src/main/resources</filename>.   
      Il ne s'agit que de la valeur par défaut définie dans le Super <acronym>POM</acronym>.
      Notez également que vous n'avez pas besoin de centraliser toutes vos ressources dans un unique répertoire.
      Vous pouvez les séparer dans plusieurs sous-répertoires dans <filename>src/main</filename>.
      Imaginez que votre projet contienne des centaines de fichiers <acronym>XML</acronym> et des centaines d'images.
      Au lieu de centraliser toutes vos ressources dans le répertoire <filename>src/main/resources</filename>,
      il voudrez probablement créer deux répertoires <filename>src/main/xml</filename> et <filename>src/main/images</filename>.
      Pour ajouter des répertoires à la liste des répertoires contenant les ressources,
      ajoutez la balise <sgmltag>resource</sgmltag> suivante dans la configuration de votre build.</para>

      <example>
        <title>Ajouter des répertoire ressources complémentaires</title>

        <programlisting language="xml">&lt;build&gt;
  ...
  &lt;resources&gt;
    &lt;resource&gt;
      &lt;directory&gt;src/main/resources&lt;/directory&gt;
    &lt;/resource&gt;
    &lt;resource&gt;
      &lt;directory&gt;src/main/xml&lt;/directory&gt;
    &lt;/resource&gt;
    &lt;resource&gt;
      &lt;directory&gt;src/main/images&lt;/directory&gt;
    &lt;/resource&gt;
  &lt;/resources&gt;
  ...
&lt;/build&gt;</programlisting>
      </example>

      <para>Lorsque vous construisez un projet qui produit une application en ligne de commande ou console,
      vous voudrez souvent écrire des scripts shell et les référencer dans le <acronym>JAR</acronym> produit par un build.
      Quand vous utilisez le plugin Assembly pour distribuer votre application via un <acronym>ZIP</acronym> ou un <acronym>TAR</acronym>,
      vous pouvez placer tous vos scripts dans un répertoire du type <filename>src/main/command</filename>.
      Dans la configuration des ressources du <acronym>POM</acronym> suivant, 
      vous verrez comment nous pouvons utiliser le filtrage des ressources et 
      avec une référence vers une variable pour modifier le nom du <acronym>JAR</acronym>.
      Pour plus d'informations sur le plugin Maven Assembly, consultez le <xref linkend="assemblies" />.</para>      

      <para><example id="ex-filter-script">
          <title>Fitrage de resources Scripts</title>

          <programlisting language="xml">&lt;build&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;simple-cmd&lt;/artifactId&gt;
  &lt;version&gt;2.3.1&lt;/version&gt;
  ...
  &lt;resources&gt;
    &lt;resource&gt;
      &lt;filtering&gt;true&lt;/filtering&gt;
      &lt;directory&gt;\${basedir}/src/main/command&lt;/directory&gt;
      &lt;includes&gt;
        &lt;include&gt;run.bat&lt;/include&gt;
        &lt;include&gt;run.sh&lt;/include&gt;
      &lt;/includes&gt;
      &lt;targetPath&gt;\${basedir}&lt;/targetPath&gt;
    &lt;/resource&gt;
    &lt;resource&gt;
      &lt;directory&gt;\${basedir}/src/main/resources&lt;/directory&gt;
    &lt;/resource&gt;
  &lt;/resources&gt;
  ...
&lt;/build&gt;</programlisting>
        </example></para>

      <para>Si vous exécutez la commande <filename>mvn process-resources</filename> dans ce projet, 
      vous vous retrouverez avec deux fichiers dans <varname>\${basedir}</varname> : <filename>run.sh</filename> et <filename>run.bat</filename>.
      Nous avons inclus ces deux fichiers dans la balise <sgmltag>resource</sgmltag>, configuré le filtrage, 
      et affecté le <sgmltag>targetPath</sgmltag> à la valeur <varname>\${basedir}</varname>.
      Dans une seconde balise <sgmltag>resource</sgmltag>, 
      nous avons configuré le chemin par défaut des ressources pour qu'elles soient copiées sans filtrage dans le répertoire de destination.
      L'<xref linkend="ex-filter-script" /> montre comment déclarer deux répertoires ressources et les configurer différemment.  
      Le projet de l'<xref linkend="ex-filter-script" /> doit disposer un fichier <filename>run.bat</filename> dans le dossier
      <filename>src/main/command</filename> qui contient le code suivant :</para>

      <programlisting>@echo off
java -jar \${project.build.finalName}.jar %*
</programlisting>

      <para>Après avoir exécuté la commande <command>mvn process-resources</command>, 
      un fichier nommé <filename>run.bat</filename> devrait apparaître dans 
      <varname>\${basedir}</varname>, en voici son contenu :</para>

      <programlisting>@echo off
java -jar simple-cmd-2.3.1.jar %*
</programlisting>

      <para>La possibilité de personnaliser le filtrage pour un sous-ensemble spécifique de ressources 
      est l'une des raisons de séparer vos ressources par type sur un projet. 
      Plus un projet est complexe, plus il sera avantageux de séparer les ressources dans différents répertoires.
      L'alternative au fait de conserver différentes sortes de ressources nécessitant différentes configurations de filtre dans des répertoires différents
      est d'utiliser un ensemble complexe de pattern 'include' et 'exclude' pour différencier les types de configuration.
      Cette seconde solution est beaucoup plus complexe à maintenir et à mettre en place.</para>
    </section>

    <section id="lifecycle-sect-compile-phase">
      <title>Compilation</title>

      <para>La plupart des cycles de vie rattachent le goal <varname>compile</varname> du plugin Compiler à la phase <varname>compile</varname>. 
      Cette phase appelle <varname>compile:compile</varname> qui est configuré pour compiler tout le code source et copier le bytecode dans le répertoire destination du build.
      Si vous n'avez pas personnalisé les valeurs définies dans le Super <acronym>POM</acronym>, <varname>compile:compile</varname>
      compilera toutes les sources du répertoire <filename>src/main/java</filename> dans <filename>target/classes</filename>.
      Le plugin Compiler appelle <filename>javac</filename> et utilise les paramétrages par défaut : 1.3 pour le code source, et 1.1 pour le bytecode produit.
      Autrement dit, le plugin Compiler présume que le code source de votre projet est conforme Java 1.3 et qu'il doit tourner sur une JVM Java 1.1.
      Si vous voulez modifier ce paramétrage, vous devez fournir la configuration suivante du plugin Compiler dans le POM de votre projet.</para> 

      <para><example id="ex-compilesrc-target">
          <title>Modifier les versions du code source et du bytecode pour le plugin Compiler</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    ...
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;source&gt;1.5&lt;/source&gt;
          &lt;target&gt;1.5&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
    ...
  &lt;/build&gt;
  ...
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>Notez que nous avons configuré le plugin Compiler, pas le goal <varname>compile:compile</varname>.
      Si nous voulions configurer le source et le bytecode généré juste pour le goal <varname>compile:compile</varname>,
      nous aurions placé la balise <sgmltag>configuration</sgmltag> sous la balise <sgmltag>execution</sgmltag> du goal <varname>compile:compile</varname>.
      Nous avons effectué cette configuration au niveau du plugin, car <varname>compile:compile</varname> n'est pas le seul goal intéressé par cette configuration.
      Le plugin Compiler est réutilisé pour la compilation des tests via le goal <varname>compile:testCompile</varname>,
      cette configuration nous permet donc de faire d'une pierre deux coups.</para>

      <para>Si vous voulez personnaliser l'emplacement du code source, vous pouvez modifier la configuration du build.
      Si vous désirez placer le code source de votre projet dans le répertoire <filename>src/java</filename> au lieu du répertoire <filename>src/main/java</filename>,
      et si vous voulez que votre projet soit généré dans <filename>classes</filename> au lieu <filename>target/classes</filename>,
      vous pouvez toujours modifier la configuration par défaut du <sgmltag>sourceDirectory</sgmltag> définie dans le Super <acronym>POM</acronym>.</para>

      <example>
        <title>Modifier le répertoire du code source par défaut</title>

        <programlisting language="xml">&lt;build&gt;
  ...
  &lt;sourceDirectory&gt;src/java&lt;/sourceDirectory&gt;
  &lt;outputDirectory&gt;classes&lt;/outputDirectory&gt;
  ...
&lt;/build&gt;</programlisting>
      </example>

      <warning>
        <para>Alors qu'il pourrait vous sembler nécessaire de configurer Maven pour qu'il utilise votre propre structure de répertoires,
        nous n'essayerons jamais assez de vous disuader de modifier la configuration Maven par défaut.
        Nous n'essayons pas ici de vous laver le cerveau pour vous forcer à utiliser la structure Maven,
        mais il reste beaucoup simple de suivre quelques conventions pour que tout le monde puisse comprendre rapidement votre projet.</para>
      </warning>
    </section>

    <section id="lifecycle-sect-process-test-resources-phase">
      <title>Traiter les ressources des tests</title>

      <para>La phase <varname>process-test-resources</varname> est quasi-identique à la phase <varname>process-resources</varname>.
      Si le <acronym>POM</acronym> comporte quelques légères différences, la plus grande partie de la configuration reste identique.
      Vous pouvez filtrer les ressources de vos tests de la même manière que les ressources du projet.
      L'emplacement par défaut des ressources pour les tests, défini dans le Super <acronym>POM</acronym>, est <filename>src/test/resources</filename>,
      le répertoire destination est configuré par défaut dans la variable <varname>\${project.build.testOutputDirectory}</varname> et correspond à <filename>target/test-classes</filename>.</para>
    </section>

    <section id="lifecycle-sect-test-compile-phase">
      <title>Compilation des tests</title>

      <para>La phase <varname>test-compile</varname> est quasiment identique à la phase <varname>compile</varname>.
      La seule différence est que <varname>test-compile</varname> appelle <varname>compile:testCompile</varname> pour compiler le code source des tests.  
      Si vous n'avez pas personnalisé les répertoires par défaut du Super <acronym>POM</acronym>,
      <varname>compile:testCompile</varname> compilera le code source contenu du répertoire <filename>src/test/java</filename> dans <filename>target/test-classes</filename>.</para>

      <para>Comme pour le répertoire du code source, si vous désirez personnaliser l'emplacement du code source des tests ou du répertoire destination de la compilation,
      vous pouvez surcharger <varname>testSourceDirectory</varname> et <varname>testOutputDirectory</varname>.
      Si vous voulez stocker le code source de vos tests dans <filename>src-test/</filename> au lieu du répertoire <filename>src/test/java</filename>
      et que vous voulez enregistrer le bytecode dans le répertoire <filename>classes-test/</filename> au
      lieu <filename>target/test-classes</filename>, utilisez la configuration suivante.</para>

      <example>
        <title>Modifier l'emplacement du code source et du bytecode des tests</title>

        <programlisting language="xml">&lt;build&gt;
  ...
  &lt;testSourceDirectory&gt;src-test&lt;/testSourceDirectory&gt;
  &lt;testOutputDirectory&gt;classes-test&lt;/testOutputDirectory&gt;
  ...
&lt;/build&gt;</programlisting>
      </example>
    </section>

    <section id="lifecycle-sect-test-phase">
      <title>Tester</title>

      <para>La plupart des cycles de vie rattachent le goal test du plugin Surefire à leur phase test. 
      Le plugin Surefire est un plugin Maven permettant d'exécuter des tests unitaires. 
      Le comportement par défaut du plugin Surefire est de rechercher toutes les class se terminant par '*Test'
      dans le répertoire source des tests, puis de les exécuter comme des tests <ulink url="http://www.junit.org">JUnit</ulink>.
      Le plugin Surefire peut également être configuré pour exécuter des tests unitaires <ulink url="http://www.testng.org">TestNG</ulink>.</para> 

      <para>Après avoir exécuté la commande <command>mvn test</command>, 
      vous aurez probablement noté que le plugin Surefire a produit des rapports d'exécution dans le répertoire <filename>target/surefire-reports</filename>.  
      Ce répertoire de rapports contient deux fichiers pour chaque test exécuté par le plugin :
      un fichier <acronym>XML</acronym> qui contient les informations d'exécution du test,
      un fichier texte qui contient la sortie des tests unitaires. 
      Si un problème est survenu durant la phase de test et qu'un test unitaire a échoué,
      vous pouvez utiliser la sortie standard de Maven et ce répertoire pour trouver la cause du problème.
      Ce répertoire <filename>surefire-reports/</filename> est également utilisé durant la génération du site
      pour créer un résumé 'facile à lire' du résultat des tests unitaires.</para>

      <para>Si vous travaillez sur un projet qui contient des tests unitaires qui échouent, mmais que vous
      voulez tout de même générer votre artefact, vous devez configurer le plugin Surefire pour qu'il poursuive le build même en cas d'échec.
      Le comportement par défaut est d'arrêter le build lorsqu'un test unitaire échoue.      
      Pour modifier ce comportement, vous devez affecter la propriété <varname>testFailureIgnore</varname> du plugin Surefire à 'true'.</para>

      <example>
        <title>Configurez le plugin Surefire pour ignorer les tests en échec</title>

        <programlisting language="xml">&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
      &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
     &lt;configuration&gt;
       &lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt;
     &lt;/configuration&gt;
    &lt;/plugin&gt;
    ...
  &lt;/plugins&gt;
&lt;/build&gt;</programlisting>
      </example>
 
      <para>Si vous souhaitez ne pas exécuter l'ensemble des tests, vous pouvez exécuter la commande suivante :</para>

      <screen>$ mvn install -Dmaven.test.skip=true</screen>

      <para>La variable <varname>maven.test.skip</varname> agit sur les plugins Compiler et 
      Surefire. En précisant cette variable, vous demandez à Maven d'ignorer les tests.</para>

    </section>

    <section id="lifecycle-sect-install-phase">
      <title>Installer l'artefact</title>

      <para>Le goal <varname>install</varname> du plugin Install est toujours rattaché à la phase <varname>install</varname> du cycle de vie.  
      Ce goal <varname>install:install</varname> installe simplement les artefacts d'un projet dans le dépôt local.
      Si vous avez un projet avec un <sgmltag>groupId</sgmltag> à <package>org.sonatype.mavenbook</package>,
      un <sgmltag>artifactId</sgmltag> à <varname>simple-test</varname>, et une <sgmltag>version</sgmltag> à 1.0.2,
      le goal <varname>install:install</varname> copiera le fichier <acronym>JAR</acronym> de <filename>target/simple-test-1.0.2.jar</filename>
      vers <filename>~/.m2/repository/org/sonatype/mavenbook/simple-test/1.0.2/simple-test-1.0.2.jar</filename>.
      Si le projet a un type de packaging <acronym>POM</acronym>, ce goal copiera le <acronym>POM</acronym> dans le dépôt local.</para>        
    </section>

    <section id="lifecycle-sect-deploy-phase">
      <title>Déploiement</title>

      <para>Le goal <varname>deploy</varname> du plugin Deploy est souvent rattaché à la phase <varname>deploy</varname> du cycle de vie.  
      Cette phase est utilisée pour déployer un artefact sur un dépôt Maven distant. Cela est
      souvent utilisé pour mettre à jour un dépôt distant quand vous effectuez une release.
      La procédure de déploiement peut aller d'une simple copie de fichier d'un répertoire dans un autre, à un ensemble complexe de transferts <acronym>SCP</acronym> de fichiers en utilisant une clé publique.
      Les préférences de déploiement nécessitent souvent des accès à un dépôt distant, et donc,
      elles sont souvent stockées hors du fichier <filename>pom.xml</filename>.
      Ces préférences se retrouvent donc souvent dans un fichier propre à chaque utilisateur : <filename>~/.m2/settings.xml</filename>.
      Tout ce que vous avez besoin de savoir pour le moment est que le goal <varname>deploy:deploy</varname> est rattaché à la phase <varname>deploy</varname>
      et qu'il permet le transfert d'un artefact sur un dépôt de publication et la mise à jour des informations d'un dépôt qui peuvent être affectées par un tel déploiement.</para>
    </section>
  </section>
</chapter>