<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="lifecycle">
  <title>Cycle de vie du Build</title>

  <section id="lifecycle-sect-structure">
    <title>Introduction</title>

    <para>
    Maven modélise les projets en noms qui sont définis par un <acronym>POM</acronym>.
    Le <acronym>POM</acronym> capture l'identité d'un projet : Que contient un projet ?
    De quel genre de packaging a t-il besoin ? Le projet a-t-il un parent ? Quelles sont les dépendances ? 
    Nous avons exploré les principes de description d'un projet dans les chapitres précédents,
    mais nous n'avons pas introduit le mécanisme qui permet à Maven d'agir sur ces objets.
    Dans Maven, les "verbes" sont des goals packagés dans des plugins Maven qui sont attachés à des phases du cycle de vie du build.
    Le cycle de vie Maven se compose d'une séquence de phases nommées dont : prepare-resources, compile, package, install.
    Il y a une phase qui capture la compilation et une autre qui capture le packaging. 
    Il existe également des phases pre- et post-. 
    Celles-ci peuvent être utilisées, par exemple, pour enregistrer des goals devant être exécutés avant la compilation 
    ou effectuer des tâches après l'exécution d'une phase bien précise.
    Quand vous demandez à Maven de construire un projet, 
    vous lui demandez de parcourir la liste des différentes phases du cycle de vie et  
    d'exécuter chacun des goals associés à celles-ci.</para>

    <para>Le cycle de vie d'un build est organisé en une séquence de phases qui permettent d'ordonner des groupes de goals.
    Ces goals sont choisis et rattachés par le type de packaging de leur projet. 
    Il existe trois types de cycle de vie : clean, default (quelquefois appelé build) et site.
    Dans ce chapitre, vous allez apprendre comment Maven rattache des goals aux phases du cycle de vie, et comment customiser un cycle de vie. 
    Vous connaîtrez également les différentes phases du cycle de vie par défaut.</para>

    <section id="lifecycle-sect-clean">
      <title>Cycle de vie Clean (clean)</title>

      <para>Le premier cycle de vie auquel vous vous intéresserez est le cycle de vie le plus simple de Maven. 
      Exécuter la commande <command>mvn clean</command> invoque le cycle de vie 'clean', celui-ci contient trois phases :</para>

      <itemizedlist>
        <listitem>
          <para><varname>pre-clean</varname></para>
        </listitem>

        <listitem>
          <para><varname>clean</varname></para>
        </listitem>

        <listitem>
          <para><varname>post-clean</varname></para>
        </listitem>
      </itemizedlist>

      <para>La phase la plus intéressante de ce cycle de vie est la phase <varname>clean</varname>.
      Le goal 'clean' du plugin Clean (<varname>clean:clean</varname>) est attaché à la phase <varname>clean</varname> du cycle de vie <varname>clean</varname>.
      Le goal <varname>clean:clean</varname> efface les traces de la dernière construction en supprimant le répertoire de build.
      Si vous n'avez pas modifié l'emplacement du répertoire de build, celui-ci se trouve dans le répertoire <filename>\${basedir}/target</filename>.
      Lorsque vous exécutez le goal <varname>clean:clean</varname>, vous ne l'exécutez pas directement avec <command>mvn clean:clean</command>, 
      vous l'utilisez par l'intermédiaire de la phase <varname>clean</varname> du cycle de vie du même nom. 
      Exécuter la phase <varname>clean</varname> donne à Maven l'opportunité d'exécuter les autres goals rattachés à la phase <varname>pre-clean</varname>.</para>

      <para>Par exemple, supposez que vous voulez exécuter un goal <varname>antrun:run</varname> pour afficher une notification lors du <varname>pre-clean</varname>,
      ou archiver le répertoire de build du projet avant qu'il ne soit supprime.      
      Exécuter directement le goal <varname>clean:clean</varname> ne lancera pas le cycle de vie,
      mais en spécifiant la phase <varname>clean</varname> vous utiliserez le cycle de vie <varname>clean</varname> 
      et traverserez de ce fait les trois phases du cycle de vie de jusqu'à la phase <varname>clean</varname>.
      L'<xref linkend="ex-trigger-pre-clean" /> montre un exemple de configuration de build qui permet de rattacher le goal <varname>antrun:run</varname>
      à la phase <varname>pre-clean</varname> pour afficher une alerte avant la suppression de l'artefact en cours de nettoyage.  
      Dans cet exemple, le goal <varname>antrun:run</varname> est utilisé pour exécuter des commandes Ant qui permettent de tester l'existence d'un artefact de projet.
      Si l'artefact du projet est sur le point d'être effacé, il d'affichera à l'écran.</para>

      <example id="ex-trigger-pre-clean">
        <title>Exécuter un Goal lors du pre-clean</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;... &lt;plugin&gt;
    &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;id&gt;file-exists&lt;/id&gt;
        &lt;phase&gt;pre-clean&lt;/phase&gt;
        &lt;goals&gt;
          &lt;goal&gt;run&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
          &lt;tasks&gt;
            &lt;!-- adds the ant-contrib tasks (if/then/else used below) --&gt;
            &lt;taskdef resource="net/sf/antcontrib/antcontrib.properties" /&gt;
            &lt;available 
      file="\${project.build.directory}/\${project.build.finalName}.\${project.packaging}"
      property="file.exists" value="true" /&gt;

            &lt;if&gt;
              &lt;not&gt;
                &lt;isset property="file.exists" /&gt;
              &lt;/not&gt;
              &lt;then&gt;
                &lt;echo&gt;No
                  \${project.build.finalName}.\${project.packaging} to
                  delete&lt;/echo&gt;
              &lt;/then&gt;
              &lt;else&gt;
                &lt;echo&gt;Deleting
                  \${project.build.finalName}.\${project.packaging}&lt;/echo&gt;
              &lt;/else&gt;
            &lt;/if&gt;
          &lt;/tasks&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;ant-contrib&lt;/groupId&gt;
        &lt;artifactId&gt;ant-contrib&lt;/artifactId&gt;
        &lt;version&gt;1.0b2&lt;/version&gt;
      &lt;/dependency&gt;
    &lt;/dependencies&gt;
  &lt;/plugin&gt;
  &lt;/plugins&gt;
  &lt;/build&gt; 
&lt;/project&gt;
</programlisting>

        <para>Exécuter la commande <command>mvn clean</command> avec une telle configuration sur un projet produira un résultat ressemblant à celui-ci :</para>
      </example>

      <screen>[INFO] Scanning for projects...
[INFO] ----------------------------------------------------------------------
[INFO] Building Your Project
[INFO]    task-segment: [clean]
[INFO] ----------------------------------------------------------------------
[INFO] [antrun:run {execution: file-exists}]
[INFO] Executing tasks
     [echo] Deleting your-project-1.0-SNAPSHOT.jar
[INFO] Executed tasks
[INFO] [clean:clean]
[INFO] Deleting directory ~/corp/your-project/target
[INFO] Deleting directory ~/corp/your-project/target/classes
[INFO] Deleting directory ~/corp/your-project/target/test-classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1 second
[INFO] Finished at: Wed Nov 08 11:46:26 CST 2006
[INFO] Final Memory: 2M/5M
[INFO] ------------------------------------------------------------------------
</screen>

      <para>En plus de configurer Maven pour exécuter un goal lors de la phase <varname>pre-clean</varname>,
      vous pouvez personnaliser le plugin Clean pour effacer des dossiers en plus du répertoire contenant le build. 
      Vous pouvez configurer le plugin pour supprimer certains fichiers d'un <sgmltag>fileSet</sgmltag>.
      L'exemple ci-dessous configure le plugin Clean pour supprimer tous les fichiers du répertoire <filename>target-other/</filename> en utilisant le wildcards standard Ant :   
      <varname>*</varname> and <varname>**</varname>.</para>
      

      <para><example>
          <title>Personaliser le Comportement du Plugin Clean</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;filesets&gt;
            &lt;fileset&gt;
              &lt;directory&gt;target-other&lt;/directory&gt;
              &lt;includes&gt;
                &lt;include&gt;*.class&lt;/include&gt;
              &lt;/includes&gt;
            &lt;/fileset&gt;
          &lt;/filesets&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>
        </example></para>
    </section>

    <section id="lifecycle-sect-default">
      <title>Default Lifecycle (default)</title>

      <para>La Plupart des utilisateurs Maven seront familiers avec le cycle de vie par défaut. 
      C'est un modèle général pour processus de build pour une application de logiciel.
      Ce cycle de vie commence par la phase <varname>validate</varname> et se termine avec la phase <varname>deploy</varname>. 
      Les phases du cycle de vie Maven par défaut sont présentés dans le <xref linkend="tbl-default-lifecycle" />.</para>

      <table id="tbl-default-lifecycle">
        <title>Phase du Cycle de vie Maven</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Phase du cycle de vie</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>validate</entry>

              <entry>Valide que le projet soit correct et que toutes les informations nécessaires au build soient disponibles</entry>
            </row>

            <row>
              <entry>generate-sources</entry>

              <entry>Génère le code source nécessaire pour l'inclure à la compilation</entry> 
            </row>

            <row>
              <entry>process-sources</entry>

              <entry>Traite le code source, pour filtrer certaines valeurs par exemple</entry>
            </row>

            <row>
              <entry>generate-resources</entry>

              <entry>Génère les ressources à inclure dans le package</entry>
            </row>

            <row>
              <entry>process-resources</entry>

              <entry>Copie et traite les ressources dans leur répertoire destination, pour les rendre prêtes pour le packaging</entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>Compile le code source du projet</entry>
            </row>

            <row>
              <entry>process-classes</entry>

              <entry>Traitre a posteriori les fichiers générés par la compilation, pour modifier du bytecode par exemple</entry>
            </row>

            <row>
              <entry>generate-test-sources</entry>

              <entry>Génère le code source des tests pour l'inclure à la compilation</entry>
            </row>

            <row>
              <entry>process-test-sources</entry>

              <entry>Traite le code source des tests, pour filtrer certaines valeurs par exemple</entry>
            </row>

            <row>
              <entry>generate-test-resources</entry>

              <entry>Crée les ressources pour le test</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>Copie et traite les ressources dans le répertoire destination des tests</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>Compile le code source des tests dans le répertoire destination</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>Exécute les tests en utilisant le framework de test approprié. 
              Le code de ces tests ne doit pas être requis par le packaging ni le déploiement.</entry> 
            </row>

            <row>
              <entry>prepare-package</entry>

              <entry>Effectue les opérations nécessaires pour la préparation du package avant que celui-ci ne soit réellement créé.
              Il en résulte souvent une version dézippée et prête à été packagée du futur package (Maven 2.1+)</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>Package le code compilé dans un format distribuable, tel que <acronym>JAR</acronym>, un
              <acronym>WAR</acronym>, un <acronym>EAR</acronym></entry>
            </row>

            <row>
              <entry>pre-integration-test</entry>

              <entry>Effectue les actions nécessaires avant de lancer les tests d'intégration, comme configurer un environnement par exemple.</entry>
            </row>

            <row>
              <entry>integration-test</entry>

              <entry>Traite et déploie si nécessaire le package dans l'environnement où les tests pourront être exécutés</entry>
            </row>

            <row>
              <entry>post-integration-test</entry>

              <entry>Effectue les actions nécessaires à la fin de l'exécution des tests d'intégration, comme nettoyer l'environnement par exemple</entry> 
            </row>

            <row>
              <entry>verify</entry>

              <entry>Lance des points de contrôle pour vérifier que le package est valide et qu'il passe les critères qualité</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>Installe le package dans le repository local, celui-ci pourra ainsi être utilisé comme dépendance par d'autres projets locaux</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>Copie le package final sur le repository distant. Permet de partager le package à d'autres utilisateurs et projets (souvent pertinent pour une vraie release)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-site">
      <title>Cycle de vie Site (site)</title>

      <para>Maven est plus que construire les artefacts de votre projet,
      il peut également générer de la documentation et différents rapports d'un ou plusieurs projets.
      La documentation du projet et la génération du site web ont un cycle de vie séparé. 
      Celui-ci contient quatre phases :</para>

      <orderedlist>
        <listitem>
          <para>pre-site</para>
        </listitem>

        <listitem>
          <para>site</para>
        </listitem>

        <listitem>
          <para>post-site</para>
        </listitem>

        <listitem>
          <para>site-deploy</para>
        </listitem>
      </orderedlist>

      <para>Les goals suivants sont rattachés par défaut à ce cycle de vie :</para>

      <orderedlist>
        <listitem>
          <para>site - site:site</para>
        </listitem>

        <listitem>
          <para>site-deploy -site:deploy</para>
        </listitem>
      </orderedlist>

      <para>Le type de packaging n'a aucune influence sur ce cycle de vie. 
      Les types de packaging influent sur la création des artefacts, pas sur le type de site généré. 
      Le plugin Site lance l'exécution de la génération d'un document <ulink url="http://maven.apache.org/doxia/">Doxia</ulink> et de différents plugins permettant de générer des rapports.
      Vous pouvez générer un site à partir d'un projet Maven en exécutant la commande suivante :</para>

      <screen>$ <command>mvn site</command>
</screen>

      <para>Pour plus d'informations à propose de la génération de Maven Site, consultez <xref linkend="site-generation" />.</para>
    </section>
  </section>

  <section id="lifecycle-sect-package-specific">
    <title>Cycles de vie spécifiques par type de Package</title>

    <para>Des goals spécifiques sont rattachés à chaque phase en fonction du packaging du projet.
    Un projet du type <varname>jar</varname> ne dispose pas des mêmes goals par défaut qu'un projet du type <varname>war</varname>.  
    La balise <sgmltag>packaging</sgmltag> influe donc sur les étapes requises pour construire un projet.      
    Pour illustrer cela, prenons en exemple avec deux projets :
    l'un avec un packaging du type <varname>pom</varname> et l'autre avec un packaging du type <varname>jar</varname>.   
    le projet avec le packaging de type <varname>pom</varname> lancera le goal <varname>site:attach-descriptor</varname> durant la phase <varname>package</varname>,
    alors que le projet du type <varname>jar</varname> exécutera le goal <varname>jar:jar</varname>.</para>

    <para>Les paragraphes suivants décrivent le cycle de vie pour tous les types de packaging disponible dans Maven.
    Ils vous permettront donc de trouver quels goals sont rattachés au cycle de vie par défaut.</para> 

    <section id="lifecycle-sect-jar">
      <title>JAR</title>

      <para><acronym>JAR</acronym> est le type de packaging par défaut, le plus commun, 
      et le plus souvent rencontré. Les goals par défaut rattachés au cycle de vie pour un projet possédant ce type de packaging sont montrés dans le 
      <xref linkend="tbl-jar-lifecycle" />.</para>

      <table id="tbl-jar-lifecycle">
        <title>Goals par défaut pour le packaging du type JAR</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Phase du cycle de vie</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>compiler:compile</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>resources:testResources</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>compiler:testCompile</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>surefire:test</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>jar:jar</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-pom">
      <title>POM</title>

      <para><acronym>POM</acronym> est le plus simple des types de packaging. 
      L'artefact qu'il correspond à son propre contenu, rien de comparable à un <acronym>JAR</acronym>, <acronym>SAR</acronym> ou <acronym>EAR</acronym>. 
      Il ne possède pas de code à tester ou à compiler, et n'a pas de ressources à traiter.
      Les goals par défaut d'un projet du type POM sont affichés dans le <xref linkend="tbl-pom-lifecycle" />.</para>

      <table id="tbl-pom-lifecycle">
        <title>Goals par défaut d'un projet du type POM</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Phase du cycle de vie</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>package</entry>

              <entry>site:attach-descriptor</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-plugin-lifecycle">
      <title>Plugin Maven</title>

      <para>Ce type de packaging ressemble au packaging <acronym>JAR</acronym> avec trois particularités : 
      <varname>plugin:descriptor</varname>, <varname>plugin:addPluginArtifactMetadata</varname> et <varname>plugin:updateRegistry</varname>.
      Ces goals génèrent un descripteur de fichier et effectuent quelques modifications sur les données. 
      Les goals par défaut des projets possédant un packaging de type Plugin sont présentés sur le <xref linkend="tbl-plugin-lifecycle" />.</para>

      <table id="tbl-plugin-lifecycle">
        <title>Goals par défaut d'un projet du type Plugin</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Phase du cycle de vie</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>generate-resources</entry>

              <entry>plugin:descriptor</entry>
            </row>

            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>compiler:compile</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>resources:testResources</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>compiler:testCompile</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>surefire:test</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>jar:jar, plugin:addPluginArtifactMetadata</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install, plugin:updateRegistry</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-ejb">
      <title>EJB</title>

      <para>Les <acronym>EJB</acronym>s (Enterprise Java Beans) proposent un mécanisme standard d'accès aux données.
      Ils proposent une approche orientée modèle (model-driven development) pour le développement d'applications Java d'entreprise.   
      Maven fournit un support pour les <acronym>EJB</acronym> 2 et 3.
      Si vous devez configurer le plugin <acronym>EJB</acronym> pour packager spécifiquement un <acronym>EJB3</acronym>,
      les pamarètres par défaut du plugin recherchent la présence des fichiers de configuration <acronym>EJB</acronym> 2.1.
      Les goals par défaut pour des projets du type <acronym>EJB</acronym> sont présentés dans le <xref linkend="tbl-ejb-lifecycle" />.</para>

      <table id="tbl-ejb-lifecycle">
        <title>Goals par défaut d'un projet du type EJB</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Phase du cycle de vie</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>compiler:compile</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>resources:testResources</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>compiler:testCompile</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>surefire:test</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>ejb:ejb</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-war">
      <title>WAR</title>

      <para>Le packaging de type <acronym>WAR</acronym> ressemble également aux types <acronym> JAR</acronym> et <acronym>EJB</acronym>,
      a l'exception du goal de la phase <varname>package</varname> : <varname>war:war</varname>.
      Notez que le plugin <varname>war:war</varname> nécessite la présence d'un fichier de configuration <filename>web.xml</filename> dans le répertoire <filename>src/main/webapp/WEB-INF</filename>.
      Les goals par défaut d'un projet de type <acronym>WAR</acronym> sont présentés dans le <xref linkend="tbl-war-lifecycle" />.</para> 

      <table id="tbl-war-lifecycle">
        <title>Goals par défaut d'un projet du type WAR</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Phase du cycle de vie</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>compile</entry>

              <entry>compiler:compile</entry>
            </row>

            <row>
              <entry>process-test-resources</entry>

              <entry>resources:testResources</entry>
            </row>

            <row>
              <entry>test-compile</entry>

              <entry>compiler:testCompile</entry>
            </row>

            <row>
              <entry>test</entry>

              <entry>surefire:test</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>war:war</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-ear">
      <title>EAR</title>

      <para>Les <acronym>EAR</acronym>s sont probablement les artefacts les plus simples d'une application Java <acronym>EE</acronym>. 
      Ils sont constitués d'un descripteur de déploiement nommé <filename>application.xml</filename>, des ressources et de modules.  
      Le plugin <acronym>EAR</acronym> possède un goal nommé <varname>generate-application-xml</varname>. 
      Celui-ci génère le fichier <filename>application.xml</filename> à partir de la configuration définit dans le POM du projet <acronym>EAR</acronym>.   
      Les goals par défaut d'un projet de type <acronym>EAR</acronym> sont présentés dans le <xref linkend="tbl-ear-lifecycle" />.</para>

      <table id="tbl-ear-lifecycle">
        <title>Goals par défaut d'un projet du type EAR</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Phase du cycle de vie</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>generate-resources</entry>

              <entry>ear:generate-application-xml</entry>
            </row>

            <row>
              <entry>process-resources</entry>

              <entry>resources:resources</entry>
            </row>

            <row>
              <entry>package</entry>

              <entry>ear:ear</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install:install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy:deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="lifecycle-sect-other-packaging">
      <title>Autres Types de Packaging</title>

      <para>La liste que nous venons de parcourir n'est pas exhaustive.
      Nombre d'autres types de packaging sont disponibles par l'intermédiaire de projets externes et de plugins, dont :
      le type de packaging <acronym>NAR</acronym> (native archive), les types <acronym>SWF</acronym> et <acronym>SWC</acronym>
      pour les projets qui produisent des contenus Adobe Flash et Flex.  
      Vous pouvez également définir un type de packaging personnalisé et modifier le cycle de vie par défaut pour répondre à vos contraintes.</para> 

      <para>Pour utiliser l'un de ces types de packaging personnalisé, vous avez besoin de deux choses :
      un plugin qui définit le cycle de vie d'un type de packaging personnalisé et un dépôt qui contient ce plugin.
      Plusieurs types de packaging personnalisés sont définis dans des plugins disponibles à partir du Maven repository central.  
      Voici l'exemple d'un projet qui référence le plugin Israfil Flex et qui utilise un type de packaging personnalisé 
      <acronym>SWF</acronym> comme résultat de la construction du code source Adobe Flex.</para>

      <para><example>
          <title>Type de Packaging personnalisé pour Adobe Flex (SWF)</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;packaging&gt;swf&lt;/packaging&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;net.israfil.mojo&lt;/groupId&gt;
        &lt;artifactId&gt;maven-flex2-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.4-SNAPSHOT&lt;/version&gt;
        &lt;extensions&gt;true&lt;/extensions&gt;
        &lt;configuration&gt;
          &lt;debug&gt;true&lt;/debug&gt;
          &lt;flexHome&gt;\${flex.home}&lt;/flexHome&gt;
          &lt;useNetwork&gt;true&lt;/useNetwork&gt;
          &lt;main&gt;org/sonatype/mavenbook/Main.mxml&lt;/main&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  ...
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>Dans la <xref linkend="writing-plugins-sect-plugins-lifecycle" />, 
      nous vous montrons comment créer votre propre type de packaging avec un cycle de vie personnalisé. 
      Cet exemple devrait vous donner une idée de ce que vous avez à faire pour référencer un type de packaging personnalisé.
      Tout ce dont vous avez besoin est de référencer le plugin qui fournit votre nouveau type de packaging. 
      Le plugin Israfil Flex est un plugin Maven non officiel hébergé sur Google Code, 
      pour plus d'information sur le fonctionnement et l'utilisation, rendez-vous à l'adresse <ulink
      url="http://code.google.com/p/israfil-mojo">http://code.google.com/p/israfil-mojo</ulink>.
      Ce plugin fournit le cycle de vie suivant pour les projets du type <acronym>SWF</acronym> :</para>

      <table>
        <title>Cycle de vie par défaut d'un projet du type SWF</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Phase du cycle de vie</entry>

              <entry>Goal</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>compile</entry>

              <entry>flex2:compile-swc</entry>
            </row>

            <row>
              <entry>install</entry>

              <entry>install</entry>
            </row>

            <row>
              <entry>deploy</entry>

              <entry>deploy</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </section>

  <section id="lifecycle-sect-common-goals">
    <title>Goals Communs de Cycle de vie</title>

    <para>La plupart des cycles de vie de packaging possèdent des goals en commun.
    Si vous regarder les goals rattachés aux cycles de vie <acronym>WAR</acronym> et <acronym>JAR</acronym>,
    vous remarquerez que seule la phase <varname>package</varname> diffère.
    La phase <varname>package</varname> du cycle de vie <acronym>WAR</acronym> appelle <varname>war:war</varname> alors
    que la cette même phase est appelle <varname>jar:jar</varname> pour le cycle de vie <acronym>JAR</acronym>. 
    La plupart des cycles de vie que vous rencontrerez partageront certains goals pour gérer les ressources,
    exécuter les tests et compiler votre code. 
    Dans cette section, nous explorerons quelques-uns des goals utilisés sur plusieurs cycles de vie.</para>

    <section id="lifecycle-sect-process-resources-phase">
      <title>Traiter les Resources</title>

      <para>La plupart des cycles de vie rattachent le goal <varname>resources:resources</varname> à la phase <varname>process-resources</varname>.
      La phase <varname>process-resources</varname> "traite" les ressources et les copies dans le répertoire destination.
      Si vous n'avez pas personnalisé les répertoires par défaut définis dans le Super <acronym>POM</acronym>,
      Maven copiera les fichiers du répertoire <filename>\${basedir}/src/main/resources</filename> au répertoire
      <filename>\${basedir}/target/classes</filename> ou au répertoire définit dans <filename>\${project.build.outputDirectory}</filename>.
      En plus de les copier, Maven peut également appliquer des filtres aux ressources pour remplacer certains de leurs éléments.
      Tout comme dans le <acronym>POM</acronym> où les variables étaient définies par la notation <varname>\${...}</varname>,
      vous pouvez référencer des variables dans les ressources de votre projet en utilisant cette même syntaxe.
      Couplée aux profils, cette fonctionnalité peut être utilisée pour construire des artefacts configurés pour différentes plateformes de déploiement. 
      C'est quelque chose de courant d'avoir besoin de construire des artefacts multi-environnement, 
      un projet à souvent plusieurs cibles : développement, tests, recette, production.    
      Pour plus d'informations à propos des profils, consultez le <xref linkend="profiles" />.</para>

      <para>Pour illustrer le filtering des ressources, prenons l'exemple d'un projet possédant un fichier <acronym>XML</acronym> 
      dans le répertoire <filename>src/main/resources/META-INF/service.xml</filename>.  
      Vous voulez externaliser certaines variables de configuration dans un fichier properties. 
      En d'autre terme, vous voulez référencer l'<acronym>URL</acronym> <acronym>JDBC</acronym>, l'utilisateur et le mot de passe de votre base de données,
      sans directement mettre ces valeurs en dur dans le fichier <filename>service.xml</filename>.
      À la place, vous désirez utiliser un fichier properties pour centraliser toutes les valeurs de configuration de votre programme.
      Cela vous permet de consolider toute la configuration dans un seul fichier properties, 
      et simplifie la mise à jour des valeurs de configuration lors de la configuration d'un nouvel environnement.        
      Commençons par regarder le contenu du fichier <filename>service.xml</filename> du répertoire <filename>src/main/resources/META-INF</filename>.</para> 
     
      <para><example>
          <title>Utilisation des Properties dans les Ressources du Projet</title>

          <programlisting language="xml">&lt;service&gt;
  &lt;!-- This URL was set by project version \${project.version} --&gt;
  &lt;url&gt;\${jdbc.url}&lt;/url&gt;
  &lt;user&gt;\${jdbc.username}&lt;/user&gt;
  &lt;password&gt;\${jdbc.password}&lt;/password&gt;
&lt;/service&gt;
</programlisting>
        </example></para>

      <para>Ce fichier <acronym>XML</acronym> utilise la même syntaxe pour gérer ses properties que le celle que du <acronym>POM</acronym>. 
      La première variable référencée est la variable <varname>project</varname>, 
      celle-ci est une variable implicite qui est également disponible dans le <acronym>POM</acronym>.   
      La variable <varname>project</varname> propose un moyen d'accéder à certaines informations du <acronym>POM</acronym>. 
      Les trois variables suivantes sont <varname>jdbc.url</varname>, <varname>jdbc.username</varname> et <varname>jdbc.password</varname>.
      Ces variables sont définies dans un fichier de properties <filename>src/main/filters/default.properties</filename>.</para>


      <example>
        <title>default.properties dans src/main/filters</title>

        <programlisting>jdbc.url=jdbc:hsqldb:mem:mydb
jdbc.username=sa
jdbc.password=
</programlisting>
      </example>

      <para>Pour configurer le filtre des ressources avec le fichier <filename>default.properties</filename>,
      nous avons besoin de préciser deux choses dans le <acronym>POM</acronym> du projet :
      une liste de fichier de propriétés dans la balise <sgmltag>filters</sgmltag> de la configuration du build,
      et un flag qui permet à Maven de savoir si un répertoire doit être filtré. 
      Le comportement par défaut de Maven est de ne pas effectuer de filtre mais de juste copier les ressources dans le répertoire destination :
      vous devez donc configurer explicitement le filtre des ressources. 
      Ce comportement par défaut permet d'éviter les mauvaises surprises. 
      Cette fonctionnalité pourrait filtrer sans que vous le désiriez des fichiers contenant des éléments <varname>\${...}</varname>.</para> 

      <para><example>
          <title>Filter Resources (Replacing Properties)</title>

          <programlisting language="xml">&lt;build&gt;
  &lt;filters&gt;
    &lt;filter&gt;src/main/filters/default.properties&lt;/filter&gt;
  &lt;/filters&gt;
  &lt;resources&gt;
    &lt;resource&gt;
      &lt;directory&gt;src/main/resources&lt;/directory&gt;
      &lt;filtering&gt;true&lt;/filtering&gt;
    &lt;/resource&gt;
  &lt;/resources&gt;
&lt;/build&gt;
</programlisting>
        </example></para>

      <para>As with all directories in Maven, the resources directory does not
      need to be in <filename>src/main/resources</filename>. This is just the
      default value defined in the Super <acronym>POM</acronym>. You should
      also note that you don't need to consolidate all of your resources into
      a single directory. You can always separate resources into separate
      directories under <filename>src/main</filename>. Assume that you have
      project which contains hundreds of <acronym>XML</acronym> documents and
      hundreds of images. Instead of mixing the resources in the
      <filename>src/main/resources</filename> directory, you might want to
      create two directories <filename>src/main/xml</filename> and
      <filename>src/main/images</filename> to hold this content. To add
      directories to the list of resource directories, you would add the
      following <sgmltag>resource</sgmltag> elements to your build
      configuration.</para>

      <example>
        <title>Configuring Additional Resource Directories</title>

        <programlisting language="xml">&lt;build&gt;
  ...
  &lt;resources&gt;
    &lt;resource&gt;
      &lt;directory&gt;src/main/resources&lt;/directory&gt;
    &lt;/resource&gt;
    &lt;resource&gt;
      &lt;directory&gt;src/main/xml&lt;/directory&gt;
    &lt;/resource&gt;
    &lt;resource&gt;
      &lt;directory&gt;src/main/images&lt;/directory&gt;
    &lt;/resource&gt;
  &lt;/resources&gt;
  ...
&lt;/build&gt;</programlisting>
      </example>

      <para>When you are building a project that produces a console
      application or a command-line tool, you'll often find yourself writing
      simple shell scripts that need to reference the <acronym>JAR</acronym>
      produced by a build. When you are using the assembly plugin to produce a
      distribution for an application as a <acronym>ZIP</acronym> or
      <acronym>TAR</acronym>, you might place all of you scripts in a
      directory like <filename>src/main/command</filename>. In the following
      <acronym>POM</acronym> resource configuration, you'll see how we can use
      resource filtering and a reference to the project variable to capture
      the final output name of the <acronym>JAR</acronym>. For more
      information about the Maven Assembly plugin, see <xref
      linkend="assemblies" />.</para>

      <para><example id="ex-filter-script">
          <title>Filtering Script Resources</title>

          <programlisting language="xml">&lt;build&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;simple-cmd&lt;/artifactId&gt;
  &lt;version&gt;2.3.1&lt;/version&gt;
  ...
  &lt;resources&gt;
    &lt;resource&gt;
      &lt;filtering&gt;true&lt;/filtering&gt;
      &lt;directory&gt;\${basedir}/src/main/command&lt;/directory&gt;
      &lt;includes&gt;
        &lt;include&gt;run.bat&lt;/include&gt;
        &lt;include&gt;run.sh&lt;/include&gt;
      &lt;/includes&gt;
      &lt;targetPath&gt;\${basedir}&lt;/targetPath&gt;
    &lt;/resource&gt;
    &lt;resource&gt;
      &lt;directory&gt;\${basedir}/src/main/resources&lt;/directory&gt;
    &lt;/resource&gt;
  &lt;/resources&gt;
  ...
&lt;/build&gt;</programlisting>
        </example></para>

      <para>If you run <filename>mvn process-resources</filename> in this
      project, you will end up with two files, <filename>run.sh</filename> and
      <filename>run.bat</filename>, in <varname>\${basedir}</varname>. We've
      singled out these two files in a <sgmltag>resource</sgmltag> element,
      configuring filtering, and set the <sgmltag>targetPath</sgmltag> to be
      <varname>\${basedir}</varname>. In a second <sgmltag>resource</sgmltag>
      element, we've configured the default resources path to be copied to the
      default output directory without any filtering. <xref
      linkend="ex-filter-script" /> shows you how to declare two resource
      directories and supply them with different filtering and target
      directory preferences. The project from <xref
      linkend="ex-filter-script" /> would contain a
      <filename>run.bat</filename> file in
      <filename>src/main/command</filename> with the following content:</para>

      <programlisting>@echo off
java -jar \${project.build.finalName}.jar %*
</programlisting>

      <para>After running <command>mvn process-resources</command>, a file
      named <filename>run.bat</filename> would appear in
      <varname>\${basedir}</varname> with the following content:</para>

      <programlisting>@echo off
java -jar simple-cmd-2.3.1.jar %*
</programlisting>

      <para>The ability to customize filtering for specific subsets of
      resources is another reason why complex projects with many different
      kinds of resources often find it advantageous to separate resources into
      multiple directories. The alternative to storing different kinds of
      resources with different filtering requirements in different directories
      is to use a more complex set of include and exclude patterns to match
      all resource files which match a certain pattern.</para>
    </section>

    <section id="lifecycle-sect-compile-phase">
      <title>Compile</title>

      <para>Most lifecycles bind the Compiler plugin's
      <varname>compile</varname> goal to the <varname>compile</varname> phase.
      This phase calls out to <varname>compile:compile</varname> which is
      configured to compile all of the source code and copy the bytecode to
      the build output directory. If you haven't customized the values defined
      in the Super <acronym>POM</acronym>, <varname>compile:compile</varname>
      is going to compile everything from <filename>src/main/java</filename>
      to <filename>target/classes</filename>. The Compiler plugin calls out to
      <filename>javac</filename> and uses default source and target settings
      of 1.3 and 1.1. In other words, the compiler plugin assumes that your
      Java source conforms to Java 1.3 and that you are targeting a Java 1.1
      JVM. If you would like to change these settings, you'll need to supply
      the target and source configuration to the Compiler plugin in your
      project's POM as shown in <xref
      linkend="ex-compilesrc-target" />.</para>

      <para><example id="ex-compilesrc-target">
          <title>Setting the Source and Target Versions for the Compiler
          Plugin</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    ...
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;source&gt;1.5&lt;/source&gt;
          &lt;target&gt;1.5&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
    ...
  &lt;/build&gt;
  ...
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>Notice we are configuring the Compiler plugin, and not the
      specific <varname>compile:compile</varname> goal. If we were going to
      configure the source and target for just the
      <varname>compile:compile</varname> goal, we would place the
      <sgmltag>configuration</sgmltag> element below an
      <sgmltag>execution</sgmltag> element for the
      <varname>compile:compile</varname> goal. We've configured the target and
      source for the plugin because <varname>compile:compile</varname> isn't
      the only goal we're interested in configuring. The Compiler plugin is
      reused when Maven compiles tests using the
      <varname>compile:testCompile</varname> goal, and configuring target and
      source at the plugin level allows us to define it once for all goals in
      a plugin.</para>

      <para>If you need to customize the location of the source code, you can
      do so by changing the build configuration. If you wanted to store your
      project's source code in <filename>src/java</filename> instead of
      <filename>src/main/java</filename> and if you wanted build output to go
      to <filename>classes</filename> instead of
      <filename>target/classes</filename>, you could always override the
      default <sgmltag>sourceDirectory</sgmltag> defined by the Super
      <acronym>POM</acronym>.</para>

      <example>
        <title>Overriding the Default Source Directory</title>

        <programlisting language="xml">&lt;build&gt;
  ...
  &lt;sourceDirectory&gt;src/java&lt;/sourceDirectory&gt;
  &lt;outputDirectory&gt;classes&lt;/outputDirectory&gt;
  ...
&lt;/build&gt;</programlisting>
      </example>

      <warning>
        <para>While it might seem necessary to bend Maven to your own idea of
        project directory structure, we can't emphasize enough that you should
        sacrifice your own ideas of directory structure in favor of the Maven
        defaults. This isn't because we're trying to brainwash you into
        accepting the Maven Way, but it will be easier for people to
        understand your project if it adheres to the most basic conventions.
        Just forget about this. Don't do it.</para>
      </warning>
    </section>

    <section id="lifecycle-sect-process-test-resources-phase">
      <title>Process Test Resources</title>

      <para>The <varname>process-test-resources</varname> phase is almost
      indistinguishable from the <varname>process-resources</varname> phase.
      There are some trivial differences in the <acronym>POM</acronym>, but
      most everything the same. You can filter test resources just as you
      filter regular resources. The default location for test resources is
      defined in the Super <acronym>POM</acronym> as
      <filename>src/test/resources</filename>, and the default output
      directory for test resources is <filename>target/test-classes</filename>
      as defined in
      <varname>\${project.build.testOutputDirectory}</varname>.</para>
    </section>

    <section id="lifecycle-sect-test-compile-phase">
      <title>Test Compile</title>

      <para>The <varname>test-compile</varname> phase is almost identical to
      the <varname>compile</varname> phase. The only difference is that
      <varname>test-compile</varname> is going to invoke
      <varname>compile:testCompile</varname> to compile source from the test
      source directory to the test build output directory. If you haven't
      customized the default directories from the Super
      <acronym>POM</acronym>, <varname>compile:testCompile</varname> is going
      to compile the source in <filename>src/test/java</filename> to the
      <filename>target/test-classes</filename> directory.</para>

      <para>As with the source code directory, if you want to customize the
      location of the test source code and the output of test compilation, you
      can do so by overriding the <varname>testSourceDirectory</varname> and
      the testOutputDirectory. If you wanted to store test source in
      <filename>src-test/</filename> instead of
      <filename>src/test/java</filename> and you wanted to save test bytecode
      to <filename>classes-test/</filename> instead of
      <filename>target/test-classes</filename>, you would use the following
      configuration.</para>

      <example>
        <title>Overriding the Location of Test Source and Output</title>

        <programlisting language="xml">&lt;build&gt;
  ...
  &lt;testSourceDirectory&gt;src-test&lt;/testSourceDirectory&gt;
  &lt;testOutputDirectory&gt;classes-test&lt;/testOutputDirectory&gt;
  ...
&lt;/build&gt;</programlisting>
      </example>
    </section>

    <section id="lifecycle-sect-test-phase">
      <title>Test</title>

      <para>Most lifecycles bind the test goal of the Surefire plugin to the
      test phase. The Surefire plugin is Maven's unit testing plugin, the
      default behavior of Surefire is to look for all classes ending in *Test
      in the test source directory and to run them as <ulink
      url="http://www.junit.org">JUnit</ulink> tests. The Surefire plugin can
      also be configured to run <ulink
      url="http://www.testng.org">TestNG</ulink> unit tests.</para>

      <para>After running <command>mvn test</command>, you should also notice
      that the Surefire produces a number of reports in
      <filename>target/surefire-reports</filename>. This reports directory
      will have two files for each test executed by the Surefire plugin: an
      <acronym>XML</acronym> document containing execution information for the
      test, and a text file containing the output of the unit test. If there
      is a problem during the test phase and a unit test has failed, you can
      use the output of Maven and the contents of this directory to track down
      the cause of a test failure. This <filename>surefire-reports/</filename>
      directory is also used during site generation to create an easy to read
      summary of all the unit tests in a project.</para>

      <para>If you are working on a project that has some failing unit tests,
      but you want the project to produce output, you'll need to configure the
      Surefire plugin to continue a build even if it encounters a failure. The
      default behavior is to stop a build whenever a unit test failure is
      encountered. To override this behavior, you'll need to set the
      <varname>testFailureIgnore</varname> configuration property on the
      Surefire plugin to true.</para>

      <example>
        <title>Configuring Surefire to Ignore Test Failures</title>

        <programlisting language="xml">&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
      &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
     &lt;configuration&gt;
       &lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt;
     &lt;/configuration&gt;
    &lt;/plugin&gt;
    ...
  &lt;/plugins&gt;
&lt;/build&gt;</programlisting>
      </example>

      <para>If you would like to skip tests altogether, you can do so by
      executing the following command:</para>

      <screen>$ mvn install -Dmaven.test.skip=true</screen>

      <para>The <varname>maven.test.skip</varname> variable controls both the
      Compiler and the Surefire plugin, if you pass in
      <varname>maven.test.skip</varname> you've told Maven to ignore tests
      altogether.</para>
    </section>

    <section id="lifecycle-sect-install-phase">
      <title>Install</title>

      <para>The <varname>install</varname> goal of the Install plugin is
      almost always bound to the <varname>install</varname> lifecycle phase.
      This <varname>install:install</varname> goal simply installs a project's
      main artifact to the local repository. If you have a project with a
      <sgmltag>groupId</sgmltag> of <package>org.sonatype.mavenbook</package>,
      an <sgmltag>artifactId</sgmltag> of <varname>simple-test</varname>, and
      a <sgmltag>version</sgmltag> of 1.0.2, the
      <varname>install:install</varname> goal is going to copy the
      <acronym>JAR</acronym> file from
      <filename>target/simple-test-1.0.2.jar</filename> to
      <filename>~/.m2/repository/org/sonatype/mavenbook/simple-test/1.0.2/simple-test-1.0.2.jar</filename>.
      If the project has <acronym>POM</acronym> packaging, this goal will copy
      the <acronym>POM</acronym> to the local repository.</para>
    </section>

    <section id="lifecycle-sect-deploy-phase">
      <title>Deploy</title>

      <para>The <varname>deploy</varname> goal of the Deploy plugin is usually
      bound to the <varname>deploy</varname> lifecycle phase. This phase is
      used to deploy an artifact to a remote Maven repository, this is usually
      required to update a remote repository when you are performing a
      release. The deployment procedure can be as simple as copying a file to
      another directory or as complex as transferring a file over
      <acronym>SCP</acronym> using a public key. Deployment settings usually
      involve credentials to a remote repository, and, as such, deployment
      settings are usually not stored in a <filename>pom.xml</filename>.
      Instead, deployment settings are more frequently found in an individual
      user's <filename>~/.m2/settings.xml</filename>. For now, all you need to
      know is that the <varname>deploy:deploy</varname> goal is bound to the
      <varname>deploy</varname> phase and it takes care of transporting an
      artifact to a published repository and updating any repository
      information which might be affected by such a deployment.</para>
    </section>
  </section>
</chapter>